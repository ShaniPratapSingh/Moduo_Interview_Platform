import {
  FloatingArrow,
  FloatingFocusManager,
  FloatingList,
  FloatingOverlay,
  FloatingPortal,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __extends,
  __generator,
  __read,
  __spreadArray,
  __values,
  arrow,
  autoUpdate,
  clsx_default,
  flip,
  instance,
  offset,
  shift,
  size,
  useClick,
  useDismiss,
  useFloating,
  useHover,
  useInteractions,
  useListItem,
  useListNavigation,
  useRole,
  useTypeahead
} from "./chunk-V3WHHOAR.js";
import {
  require_jsx_runtime
} from "./chunk-ONA7IWOC.js";
import {
  require_shim
} from "./chunk-364JQC6W.js";
import {
  require_react_dom
} from "./chunk-TASTSHXU.js";
import {
  AxiosError,
  axios_default
} from "./chunk-YS7NBD6B.js";
import {
  require_react
} from "./chunk-KH2JZCNZ.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/sdp/sdp.js
var require_sdp = __commonJS({
  "node_modules/sdp/sdp.js"(exports, module) {
    "use strict";
    var SDPUtils2 = {};
    SDPUtils2.generateIdentifier = function() {
      return Math.random().toString(36).substring(2, 12);
    };
    SDPUtils2.localCName = SDPUtils2.generateIdentifier();
    SDPUtils2.splitLines = function(blob) {
      return blob.trim().split("\n").map((line) => line.trim());
    };
    SDPUtils2.splitSections = function(blob) {
      const parts = blob.split("\nm=");
      return parts.map((part, index) => (index > 0 ? "m=" + part : part).trim() + "\r\n");
    };
    SDPUtils2.getDescription = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      return sections && sections[0];
    };
    SDPUtils2.getMediaSections = function(blob) {
      const sections = SDPUtils2.splitSections(blob);
      sections.shift();
      return sections;
    };
    SDPUtils2.matchPrefix = function(blob, prefix) {
      return SDPUtils2.splitLines(blob).filter((line) => line.indexOf(prefix) === 0);
    };
    SDPUtils2.parseCandidate = function(line) {
      let parts;
      if (line.indexOf("a=candidate:") === 0) {
        parts = line.substring(12).split(" ");
      } else {
        parts = line.substring(10).split(" ");
      }
      const candidate = {
        foundation: parts[0],
        component: { 1: "rtp", 2: "rtcp" }[parts[1]] || parts[1],
        protocol: parts[2].toLowerCase(),
        priority: parseInt(parts[3], 10),
        ip: parts[4],
        address: parts[4],
        // address is an alias for ip.
        port: parseInt(parts[5], 10),
        // skip parts[6] == 'typ'
        type: parts[7]
      };
      for (let i2 = 8; i2 < parts.length; i2 += 2) {
        switch (parts[i2]) {
          case "raddr":
            candidate.relatedAddress = parts[i2 + 1];
            break;
          case "rport":
            candidate.relatedPort = parseInt(parts[i2 + 1], 10);
            break;
          case "tcptype":
            candidate.tcpType = parts[i2 + 1];
            break;
          case "ufrag":
            candidate.ufrag = parts[i2 + 1];
            candidate.usernameFragment = parts[i2 + 1];
            break;
          default:
            if (candidate[parts[i2]] === void 0) {
              candidate[parts[i2]] = parts[i2 + 1];
            }
            break;
        }
      }
      return candidate;
    };
    SDPUtils2.writeCandidate = function(candidate) {
      const sdp2 = [];
      sdp2.push(candidate.foundation);
      const component = candidate.component;
      if (component === "rtp") {
        sdp2.push(1);
      } else if (component === "rtcp") {
        sdp2.push(2);
      } else {
        sdp2.push(component);
      }
      sdp2.push(candidate.protocol.toUpperCase());
      sdp2.push(candidate.priority);
      sdp2.push(candidate.address || candidate.ip);
      sdp2.push(candidate.port);
      const type = candidate.type;
      sdp2.push("typ");
      sdp2.push(type);
      if (type !== "host" && candidate.relatedAddress && candidate.relatedPort) {
        sdp2.push("raddr");
        sdp2.push(candidate.relatedAddress);
        sdp2.push("rport");
        sdp2.push(candidate.relatedPort);
      }
      if (candidate.tcpType && candidate.protocol.toLowerCase() === "tcp") {
        sdp2.push("tcptype");
        sdp2.push(candidate.tcpType);
      }
      if (candidate.usernameFragment || candidate.ufrag) {
        sdp2.push("ufrag");
        sdp2.push(candidate.usernameFragment || candidate.ufrag);
      }
      return "candidate:" + sdp2.join(" ");
    };
    SDPUtils2.parseIceOptions = function(line) {
      return line.substring(14).split(" ");
    };
    SDPUtils2.parseRtpMap = function(line) {
      let parts = line.substring(9).split(" ");
      const parsed = {
        payloadType: parseInt(parts.shift(), 10)
        // was: id
      };
      parts = parts[0].split("/");
      parsed.name = parts[0];
      parsed.clockRate = parseInt(parts[1], 10);
      parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
      parsed.numChannels = parsed.channels;
      return parsed;
    };
    SDPUtils2.writeRtpMap = function(codec) {
      let pt2 = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt2 = codec.preferredPayloadType;
      }
      const channels = codec.channels || codec.numChannels || 1;
      return "a=rtpmap:" + pt2 + " " + codec.name + "/" + codec.clockRate + (channels !== 1 ? "/" + channels : "") + "\r\n";
    };
    SDPUtils2.parseExtmap = function(line) {
      const parts = line.substring(9).split(" ");
      return {
        id: parseInt(parts[0], 10),
        direction: parts[0].indexOf("/") > 0 ? parts[0].split("/")[1] : "sendrecv",
        uri: parts[1],
        attributes: parts.slice(2).join(" ")
      };
    };
    SDPUtils2.writeExtmap = function(headerExtension) {
      return "a=extmap:" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== "sendrecv" ? "/" + headerExtension.direction : "") + " " + headerExtension.uri + (headerExtension.attributes ? " " + headerExtension.attributes : "") + "\r\n";
    };
    SDPUtils2.parseFmtp = function(line) {
      const parsed = {};
      let kv;
      const parts = line.substring(line.indexOf(" ") + 1).split(";");
      for (let j2 = 0; j2 < parts.length; j2++) {
        kv = parts[j2].trim().split("=");
        parsed[kv[0].trim()] = kv[1];
      }
      return parsed;
    };
    SDPUtils2.writeFmtp = function(codec) {
      let line = "";
      let pt2 = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt2 = codec.preferredPayloadType;
      }
      if (codec.parameters && Object.keys(codec.parameters).length) {
        const params = [];
        Object.keys(codec.parameters).forEach((param) => {
          if (codec.parameters[param] !== void 0) {
            params.push(param + "=" + codec.parameters[param]);
          } else {
            params.push(param);
          }
        });
        line += "a=fmtp:" + pt2 + " " + params.join(";") + "\r\n";
      }
      return line;
    };
    SDPUtils2.parseRtcpFb = function(line) {
      const parts = line.substring(line.indexOf(" ") + 1).split(" ");
      return {
        type: parts.shift(),
        parameter: parts.join(" ")
      };
    };
    SDPUtils2.writeRtcpFb = function(codec) {
      let lines = "";
      let pt2 = codec.payloadType;
      if (codec.preferredPayloadType !== void 0) {
        pt2 = codec.preferredPayloadType;
      }
      if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
        codec.rtcpFeedback.forEach((fb) => {
          lines += "a=rtcp-fb:" + pt2 + " " + fb.type + (fb.parameter && fb.parameter.length ? " " + fb.parameter : "") + "\r\n";
        });
      }
      return lines;
    };
    SDPUtils2.parseSsrcMedia = function(line) {
      const sp = line.indexOf(" ");
      const parts = {
        ssrc: parseInt(line.substring(7, sp), 10)
      };
      const colon = line.indexOf(":", sp);
      if (colon > -1) {
        parts.attribute = line.substring(sp + 1, colon);
        parts.value = line.substring(colon + 1);
      } else {
        parts.attribute = line.substring(sp + 1);
      }
      return parts;
    };
    SDPUtils2.parseSsrcGroup = function(line) {
      const parts = line.substring(13).split(" ");
      return {
        semantics: parts.shift(),
        ssrcs: parts.map((ssrc) => parseInt(ssrc, 10))
      };
    };
    SDPUtils2.getMid = function(mediaSection) {
      const mid = SDPUtils2.matchPrefix(mediaSection, "a=mid:")[0];
      if (mid) {
        return mid.substring(6);
      }
    };
    SDPUtils2.parseFingerprint = function(line) {
      const parts = line.substring(14).split(" ");
      return {
        algorithm: parts[0].toLowerCase(),
        // algorithm is case-sensitive in Edge.
        value: parts[1].toUpperCase()
        // the definition is upper-case in RFC 4572.
      };
    };
    SDPUtils2.getDtlsParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=fingerprint:"
      );
      return {
        role: "auto",
        fingerprints: lines.map(SDPUtils2.parseFingerprint)
      };
    };
    SDPUtils2.writeDtlsParameters = function(params, setupType) {
      let sdp2 = "a=setup:" + setupType + "\r\n";
      params.fingerprints.forEach((fp) => {
        sdp2 += "a=fingerprint:" + fp.algorithm + " " + fp.value + "\r\n";
      });
      return sdp2;
    };
    SDPUtils2.parseCryptoLine = function(line) {
      const parts = line.substring(9).split(" ");
      return {
        tag: parseInt(parts[0], 10),
        cryptoSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3)
      };
    };
    SDPUtils2.writeCryptoLine = function(parameters) {
      return "a=crypto:" + parameters.tag + " " + parameters.cryptoSuite + " " + (typeof parameters.keyParams === "object" ? SDPUtils2.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? " " + parameters.sessionParams.join(" ") : "") + "\r\n";
    };
    SDPUtils2.parseCryptoKeyParams = function(keyParams) {
      if (keyParams.indexOf("inline:") !== 0) {
        return null;
      }
      const parts = keyParams.substring(7).split("|");
      return {
        keyMethod: "inline",
        keySalt: parts[0],
        lifeTime: parts[1],
        mkiValue: parts[2] ? parts[2].split(":")[0] : void 0,
        mkiLength: parts[2] ? parts[2].split(":")[1] : void 0
      };
    };
    SDPUtils2.writeCryptoKeyParams = function(keyParams) {
      return keyParams.keyMethod + ":" + keyParams.keySalt + (keyParams.lifeTime ? "|" + keyParams.lifeTime : "") + (keyParams.mkiValue && keyParams.mkiLength ? "|" + keyParams.mkiValue + ":" + keyParams.mkiLength : "");
    };
    SDPUtils2.getCryptoParameters = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=crypto:"
      );
      return lines.map(SDPUtils2.parseCryptoLine);
    };
    SDPUtils2.getIceParameters = function(mediaSection, sessionpart) {
      const ufrag = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=ice-ufrag:"
      )[0];
      const pwd = SDPUtils2.matchPrefix(
        mediaSection + sessionpart,
        "a=ice-pwd:"
      )[0];
      if (!(ufrag && pwd)) {
        return null;
      }
      return {
        usernameFragment: ufrag.substring(12),
        password: pwd.substring(10)
      };
    };
    SDPUtils2.writeIceParameters = function(params) {
      let sdp2 = "a=ice-ufrag:" + params.usernameFragment + "\r\na=ice-pwd:" + params.password + "\r\n";
      if (params.iceLite) {
        sdp2 += "a=ice-lite\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseRtpParameters = function(mediaSection) {
      const description = {
        codecs: [],
        headerExtensions: [],
        fecMechanisms: [],
        rtcp: []
      };
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      description.profile = mline[2];
      for (let i2 = 3; i2 < mline.length; i2++) {
        const pt2 = mline[i2];
        const rtpmapline = SDPUtils2.matchPrefix(
          mediaSection,
          "a=rtpmap:" + pt2 + " "
        )[0];
        if (rtpmapline) {
          const codec = SDPUtils2.parseRtpMap(rtpmapline);
          const fmtps = SDPUtils2.matchPrefix(
            mediaSection,
            "a=fmtp:" + pt2 + " "
          );
          codec.parameters = fmtps.length ? SDPUtils2.parseFmtp(fmtps[0]) : {};
          codec.rtcpFeedback = SDPUtils2.matchPrefix(
            mediaSection,
            "a=rtcp-fb:" + pt2 + " "
          ).map(SDPUtils2.parseRtcpFb);
          description.codecs.push(codec);
          switch (codec.name.toUpperCase()) {
            case "RED":
            case "ULPFEC":
              description.fecMechanisms.push(codec.name.toUpperCase());
              break;
            default:
              break;
          }
        }
      }
      SDPUtils2.matchPrefix(mediaSection, "a=extmap:").forEach((line) => {
        description.headerExtensions.push(SDPUtils2.parseExtmap(line));
      });
      const wildcardRtcpFb = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-fb:* ").map(SDPUtils2.parseRtcpFb);
      description.codecs.forEach((codec) => {
        wildcardRtcpFb.forEach((fb) => {
          const duplicate = codec.rtcpFeedback.find((existingFeedback) => {
            return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;
          });
          if (!duplicate) {
            codec.rtcpFeedback.push(fb);
          }
        });
      });
      return description;
    };
    SDPUtils2.writeRtpDescription = function(kind, caps) {
      let sdp2 = "";
      sdp2 += "m=" + kind + " ";
      sdp2 += caps.codecs.length > 0 ? "9" : "0";
      sdp2 += " " + (caps.profile || "UDP/TLS/RTP/SAVPF") + " ";
      sdp2 += caps.codecs.map((codec) => {
        if (codec.preferredPayloadType !== void 0) {
          return codec.preferredPayloadType;
        }
        return codec.payloadType;
      }).join(" ") + "\r\n";
      sdp2 += "c=IN IP4 0.0.0.0\r\n";
      sdp2 += "a=rtcp:9 IN IP4 0.0.0.0\r\n";
      caps.codecs.forEach((codec) => {
        sdp2 += SDPUtils2.writeRtpMap(codec);
        sdp2 += SDPUtils2.writeFmtp(codec);
        sdp2 += SDPUtils2.writeRtcpFb(codec);
      });
      let maxptime = 0;
      caps.codecs.forEach((codec) => {
        if (codec.maxptime > maxptime) {
          maxptime = codec.maxptime;
        }
      });
      if (maxptime > 0) {
        sdp2 += "a=maxptime:" + maxptime + "\r\n";
      }
      if (caps.headerExtensions) {
        caps.headerExtensions.forEach((extension) => {
          sdp2 += SDPUtils2.writeExtmap(extension);
        });
      }
      return sdp2;
    };
    SDPUtils2.parseRtpEncodingParameters = function(mediaSection) {
      const encodingParameters = [];
      const description = SDPUtils2.parseRtpParameters(mediaSection);
      const hasRed = description.fecMechanisms.indexOf("RED") !== -1;
      const hasUlpfec = description.fecMechanisms.indexOf("ULPFEC") !== -1;
      const ssrcs = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((parts) => parts.attribute === "cname");
      const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
      let secondarySsrc;
      const flows = SDPUtils2.matchPrefix(mediaSection, "a=ssrc-group:FID").map((line) => {
        const parts = line.substring(17).split(" ");
        return parts.map((part) => parseInt(part, 10));
      });
      if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {
        secondarySsrc = flows[0][1];
      }
      description.codecs.forEach((codec) => {
        if (codec.name.toUpperCase() === "RTX" && codec.parameters.apt) {
          let encParam = {
            ssrc: primarySsrc,
            codecPayloadType: parseInt(codec.parameters.apt, 10)
          };
          if (primarySsrc && secondarySsrc) {
            encParam.rtx = { ssrc: secondarySsrc };
          }
          encodingParameters.push(encParam);
          if (hasRed) {
            encParam = JSON.parse(JSON.stringify(encParam));
            encParam.fec = {
              ssrc: primarySsrc,
              mechanism: hasUlpfec ? "red+ulpfec" : "red"
            };
            encodingParameters.push(encParam);
          }
        }
      });
      if (encodingParameters.length === 0 && primarySsrc) {
        encodingParameters.push({
          ssrc: primarySsrc
        });
      }
      let bandwidth = SDPUtils2.matchPrefix(mediaSection, "b=");
      if (bandwidth.length) {
        if (bandwidth[0].indexOf("b=TIAS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substring(7), 10);
        } else if (bandwidth[0].indexOf("b=AS:") === 0) {
          bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8;
        } else {
          bandwidth = void 0;
        }
        encodingParameters.forEach((params) => {
          params.maxBitrate = bandwidth;
        });
      }
      return encodingParameters;
    };
    SDPUtils2.parseRtcpParameters = function(mediaSection) {
      const rtcpParameters = {};
      const remoteSsrc = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((obj) => obj.attribute === "cname")[0];
      if (remoteSsrc) {
        rtcpParameters.cname = remoteSsrc.value;
        rtcpParameters.ssrc = remoteSsrc.ssrc;
      }
      const rsize = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-rsize");
      rtcpParameters.reducedSize = rsize.length > 0;
      rtcpParameters.compound = rsize.length === 0;
      const mux = SDPUtils2.matchPrefix(mediaSection, "a=rtcp-mux");
      rtcpParameters.mux = mux.length > 0;
      return rtcpParameters;
    };
    SDPUtils2.writeRtcpParameters = function(rtcpParameters) {
      let sdp2 = "";
      if (rtcpParameters.reducedSize) {
        sdp2 += "a=rtcp-rsize\r\n";
      }
      if (rtcpParameters.mux) {
        sdp2 += "a=rtcp-mux\r\n";
      }
      if (rtcpParameters.ssrc !== void 0 && rtcpParameters.cname) {
        sdp2 += "a=ssrc:" + rtcpParameters.ssrc + " cname:" + rtcpParameters.cname + "\r\n";
      }
      return sdp2;
    };
    SDPUtils2.parseMsid = function(mediaSection) {
      let parts;
      const spec = SDPUtils2.matchPrefix(mediaSection, "a=msid:");
      if (spec.length === 1) {
        parts = spec[0].substring(7).split(" ");
        return { stream: parts[0], track: parts[1] };
      }
      const planB = SDPUtils2.matchPrefix(mediaSection, "a=ssrc:").map((line) => SDPUtils2.parseSsrcMedia(line)).filter((msidParts) => msidParts.attribute === "msid");
      if (planB.length > 0) {
        parts = planB[0].value.split(" ");
        return { stream: parts[0], track: parts[1] };
      }
    };
    SDPUtils2.parseSctpDescription = function(mediaSection) {
      const mline = SDPUtils2.parseMLine(mediaSection);
      const maxSizeLine = SDPUtils2.matchPrefix(mediaSection, "a=max-message-size:");
      let maxMessageSize;
      if (maxSizeLine.length > 0) {
        maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);
      }
      if (isNaN(maxMessageSize)) {
        maxMessageSize = 65536;
      }
      const sctpPort = SDPUtils2.matchPrefix(mediaSection, "a=sctp-port:");
      if (sctpPort.length > 0) {
        return {
          port: parseInt(sctpPort[0].substring(12), 10),
          protocol: mline.fmt,
          maxMessageSize
        };
      }
      const sctpMapLines = SDPUtils2.matchPrefix(mediaSection, "a=sctpmap:");
      if (sctpMapLines.length > 0) {
        const parts = sctpMapLines[0].substring(10).split(" ");
        return {
          port: parseInt(parts[0], 10),
          protocol: parts[1],
          maxMessageSize
        };
      }
    };
    SDPUtils2.writeSctpDescription = function(media, sctp) {
      let output = [];
      if (media.protocol !== "DTLS/SCTP") {
        output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.protocol + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctp-port:" + sctp.port + "\r\n"
        ];
      } else {
        output = [
          "m=" + media.kind + " 9 " + media.protocol + " " + sctp.port + "\r\n",
          "c=IN IP4 0.0.0.0\r\n",
          "a=sctpmap:" + sctp.port + " " + sctp.protocol + " 65535\r\n"
        ];
      }
      if (sctp.maxMessageSize !== void 0) {
        output.push("a=max-message-size:" + sctp.maxMessageSize + "\r\n");
      }
      return output.join("");
    };
    SDPUtils2.generateSessionId = function() {
      return Math.random().toString().substr(2, 22);
    };
    SDPUtils2.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {
      let sessionId;
      const version3 = sessVer !== void 0 ? sessVer : 2;
      if (sessId) {
        sessionId = sessId;
      } else {
        sessionId = SDPUtils2.generateSessionId();
      }
      const user = sessUser || "thisisadapterortc";
      return "v=0\r\no=" + user + " " + sessionId + " " + version3 + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n";
    };
    SDPUtils2.getDirection = function(mediaSection, sessionpart) {
      const lines = SDPUtils2.splitLines(mediaSection);
      for (let i2 = 0; i2 < lines.length; i2++) {
        switch (lines[i2]) {
          case "a=sendrecv":
          case "a=sendonly":
          case "a=recvonly":
          case "a=inactive":
            return lines[i2].substring(2);
          default:
        }
      }
      if (sessionpart) {
        return SDPUtils2.getDirection(sessionpart);
      }
      return "sendrecv";
    };
    SDPUtils2.getKind = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const mline = lines[0].split(" ");
      return mline[0].substring(2);
    };
    SDPUtils2.isRejected = function(mediaSection) {
      return mediaSection.split(" ", 2)[1] === "0";
    };
    SDPUtils2.parseMLine = function(mediaSection) {
      const lines = SDPUtils2.splitLines(mediaSection);
      const parts = lines[0].substring(2).split(" ");
      return {
        kind: parts[0],
        port: parseInt(parts[1], 10),
        protocol: parts[2],
        fmt: parts.slice(3).join(" ")
      };
    };
    SDPUtils2.parseOLine = function(mediaSection) {
      const line = SDPUtils2.matchPrefix(mediaSection, "o=")[0];
      const parts = line.substring(2).split(" ");
      return {
        username: parts[0],
        sessionId: parts[1],
        sessionVersion: parseInt(parts[2], 10),
        netType: parts[3],
        addressType: parts[4],
        address: parts[5]
      };
    };
    SDPUtils2.isValidSDP = function(blob) {
      if (typeof blob !== "string" || blob.length === 0) {
        return false;
      }
      const lines = SDPUtils2.splitLines(blob);
      for (let i2 = 0; i2 < lines.length; i2++) {
        if (lines[i2].length < 2 || lines[i2].charAt(1) !== "=") {
          return false;
        }
      }
      return true;
    };
    if (typeof module === "object") {
      module.exports = SDPUtils2;
    }
  }
});

// node_modules/sdp-transform/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/sdp-transform/lib/grammar.js"(exports, module) {
    var grammar = module.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{ name: "name" }],
      i: [{ name: "description" }],
      u: [{ name: "uri" }],
      e: [{ name: "email" }],
      p: [{ name: "phone" }],
      z: [{ name: "timezones" }],
      // TODO: this one can actually be parsed properly...
      r: [{ name: "repeats" }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o2) {
            return o2.encoding ? "rtpmap:%d %s/%s/%s" : o2.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o2) {
            return o2.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o2) {
            return o2.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o2) {
            return "extmap:%d" + (o2.direction ? "/%s" : "%v") + (o2["encrypt-uri"] ? " %s" : "%v") + " %s" + (o2.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o2) {
            return o2.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          name: "msid",
          reg: /^msid:(.*)/,
          format: "msid:%s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o2) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o2.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o2.tcptype != null ? " tcptype %s" : "%v";
            if (o2.generation != null) {
              str += " generation %d";
            }
            str += o2["network-id"] != null ? " network-id %d" : "%v";
            str += o2["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o2) {
            var str = "ssrc:%d";
            if (o2.attribute != null) {
              str += " %s";
              if (o2.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o2) {
            return o2.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o2) {
            return o2.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o2) {
            return "imageattr:%s %s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o2) {
            return "simulcast:%s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o2) {
            return "ts-refclk:%s" + (o2.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o2) {
            var str = "mediaclk:";
            str += o2.id != null ? "id=%s %s" : "%v%s";
            str += o2.mediaClockValue != null ? "=%s" : "";
            str += o2.rateNumerator != null ? " rate=%s" : "";
            str += o2.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar).forEach(function(key) {
      var objs = grammar[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
  }
});

// node_modules/sdp-transform/lib/parser.js
var require_parser = __commonJS({
  "node_modules/sdp-transform/lib/parser.js"(exports) {
    var toIntIfInt = function(v2) {
      return String(Number(v2)) === v2 ? Number(v2) : v2;
    };
    var attachProperties = function(match, location, names, rawName) {
      if (rawName && !names) {
        location[rawName] = toIntIfInt(match[1]);
      } else {
        for (var i2 = 0; i2 < names.length; i2 += 1) {
          if (match[i2 + 1] != null) {
            location[names[i2]] = toIntIfInt(match[i2 + 1]);
          }
        }
      }
    };
    var parseReg = function(obj, location, content) {
      var needsBlank = obj.name && obj.names;
      if (obj.push && !location[obj.push]) {
        location[obj.push] = [];
      } else if (needsBlank && !location[obj.name]) {
        location[obj.name] = {};
      }
      var keyLocation = obj.push ? {} : (
        // blank object that will be pushed
        needsBlank ? location[obj.name] : location
      );
      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
      if (obj.push) {
        location[obj.push].push(keyLocation);
      }
    };
    var grammar = require_grammar();
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    exports.parse = function(sdp2) {
      var session = {}, media = [], location = session;
      sdp2.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
        var type = l[0];
        var content = l.slice(2);
        if (type === "m") {
          media.push({ rtp: [], fmtp: [] });
          location = media[media.length - 1];
        }
        for (var j2 = 0; j2 < (grammar[type] || []).length; j2 += 1) {
          var obj = grammar[type][j2];
          if (obj.reg.test(content)) {
            return parseReg(obj, location, content);
          }
        }
      });
      session.media = media;
      return session;
    };
    var paramReducer = function(acc, expr) {
      var s2 = expr.split(/=(.+)/, 2);
      if (s2.length === 2) {
        acc[s2[0]] = toIntIfInt(s2[1]);
      } else if (s2.length === 1 && expr.length > 1) {
        acc[s2[0]] = void 0;
      }
      return acc;
    };
    exports.parseParams = function(str) {
      return str.split(/;\s?/).reduce(paramReducer, {});
    };
    exports.parseFmtpConfig = exports.parseParams;
    exports.parsePayloads = function(str) {
      return str.toString().split(" ").map(Number);
    };
    exports.parseRemoteCandidates = function(str) {
      var candidates = [];
      var parts = str.split(" ").map(toIntIfInt);
      for (var i2 = 0; i2 < parts.length; i2 += 3) {
        candidates.push({
          component: parts[i2],
          ip: parts[i2 + 1],
          port: parts[i2 + 2]
        });
      }
      return candidates;
    };
    exports.parseImageAttributes = function(str) {
      return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
      });
    };
    exports.parseSimulcastStreamList = function(str) {
      return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
          var scid, paused = false;
          if (format[0] !== "~") {
            scid = toIntIfInt(format);
          } else {
            scid = toIntIfInt(format.substring(1, format.length));
            paused = true;
          }
          return {
            scid,
            paused
          };
        });
      });
    };
  }
});

// node_modules/sdp-transform/lib/writer.js
var require_writer = __commonJS({
  "node_modules/sdp-transform/lib/writer.js"(exports, module) {
    var grammar = require_grammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i2 = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x2) {
        if (i2 >= len) {
          return x2;
        }
        var arg = args[i2];
        i2 += 1;
        switch (x2) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i2 = 0; i2 < obj.names.length; i2 += 1) {
          var n2 = obj.names[i2];
          if (obj.name) {
            args.push(location[obj.name][n2]);
          } else {
            args.push(location[obj.names[i2]]);
          }
        }
      } else {
        args.push(location[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = [
      "v",
      "o",
      "s",
      "i",
      "u",
      "e",
      "p",
      "c",
      "b",
      "t",
      "r",
      "z",
      "a"
    ];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    module.exports = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp2 = [];
      outerOrder.forEach(function(type) {
        grammar[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp2.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el) {
              sdp2.push(makeLine(type, obj, el));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp2.push(makeLine("m", grammar.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp2.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el) {
                sdp2.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp2.join("\r\n") + "\r\n";
    };
  }
});

// node_modules/sdp-transform/lib/index.js
var require_lib = __commonJS({
  "node_modules/sdp-transform/lib/index.js"(exports) {
    var parser = require_parser();
    var writer = require_writer();
    var grammar = require_grammar();
    exports.grammar = grammar;
    exports.write = writer;
    exports.parse = parser.parse;
    exports.parseParams = parser.parseParams;
    exports.parseFmtpConfig = parser.parseFmtpConfig;
    exports.parsePayloads = parser.parsePayloads;
    exports.parseRemoteCandidates = parser.parseRemoteCandidates;
    exports.parseImageAttributes = parser.parseImageAttributes;
    exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
  }
});

// node_modules/ua-parser-js/src/ua-parser.js
var require_ua_parser = __commonJS({
  "node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
    (function(window3, undefined2) {
      "use strict";
      var LIBVERSION = "1.0.41", EMPTY2 = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HONOR = "Honor", HUAWEI = "Huawei", LENOVO = "Lenovo", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", NVIDIA = "Nvidia", ONEPLUS = "OnePlus", OPERA = "Opera", OPPO = "OPPO", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS", SUFFIX_BROWSER = " Browser";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i2 in regexes2) {
          if (extensions[i2] && extensions[i2].length % 2 === 0) {
            mergedRegexes[i2] = extensions[i2].concat(regexes2[i2]);
          } else {
            mergedRegexes[i2] = regexes2[i2];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i2 = 0; i2 < arr.length; i2++) {
          enums[arr[i2].toUpperCase()] = arr[i2];
        }
        return enums;
      }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version3) {
        return typeof version3 === STR_TYPE ? version3.replace(/[^\d\.]/g, EMPTY2).split(".")[0] : undefined2;
      }, trim = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY2);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua2, arrays) {
        var i2 = 0, j2, k2, p2, q2, matches, match;
        while (i2 < arrays.length && !matches) {
          var regex = arrays[i2], props = arrays[i2 + 1];
          j2 = k2 = 0;
          while (j2 < regex.length && !matches) {
            if (!regex[j2]) {
              break;
            }
            matches = regex[j2++].exec(ua2);
            if (!!matches) {
              for (p2 = 0; p2 < props.length; p2++) {
                match = matches[++k2];
                q2 = props[p2];
                if (typeof q2 === OBJ_TYPE && q2.length > 0) {
                  if (q2.length === 2) {
                    if (typeof q2[1] == FUNC_TYPE) {
                      this[q2[0]] = q2[1].call(this, match);
                    } else {
                      this[q2[0]] = q2[1];
                    }
                  } else if (q2.length === 3) {
                    if (typeof q2[1] === FUNC_TYPE && !(q2[1].exec && q2[1].test)) {
                      this[q2[0]] = match ? q2[1].call(this, match, q2[2]) : undefined2;
                    } else {
                      this[q2[0]] = match ? match.replace(q2[1], q2[2]) : undefined2;
                    }
                  } else if (q2.length === 4) {
                    this[q2[0]] = match ? q2[3].call(this, match.replace(q2[1], q2[2])) : undefined2;
                  }
                } else {
                  this[q2] = match ? match : undefined2;
                }
              }
            }
          }
          i2 += 2;
        }
      }, strMapper = function(str, map2) {
        for (var i2 in map2) {
          if (typeof map2[i2] === OBJ_TYPE && map2[i2].length > 0) {
            for (var j2 = 0; j2 < map2[i2].length; j2++) {
              if (has(map2[i2][j2], str)) {
                return i2 === UNKNOWN ? undefined2 : i2;
              }
            }
          } else if (has(map2[i2], str)) {
            return i2 === UNKNOWN ? undefined2 : i2;
          }
        }
        return map2.hasOwnProperty("*") ? map2["*"] : str;
      };
      var oldSafariMap = {
        "1.0": "/8",
        "1.2": "/1",
        "1.3": "/3",
        "2.0": "/412",
        "2.0.2": "/416",
        "2.0.3": "/417",
        "2.0.4": "/419",
        "?": "/"
      }, windowsVersionMap = {
        "ME": "4.90",
        "NT 3.11": "NT3.51",
        "NT 4.0": "NT4.0",
        "2000": "NT 5.0",
        "XP": ["NT 5.1", "NT 5.2"],
        "Vista": "NT 6.0",
        "7": "NT 6.1",
        "8": "NT 6.2",
        "8.1": "NT 6.3",
        "10": ["NT 6.4", "NT 10.0"],
        "RT": "ARM"
      };
      var regexes = {
        browser: [
          [
            /\b(?:crmo|crios)\/([\w\.]+)/i
            // Chrome for Android/iOS
          ],
          [VERSION, [NAME, "Chrome"]],
          [
            /edg(?:e|ios|a)?\/([\w\.]+)/i
            // Microsoft Edge
          ],
          [VERSION, [NAME, "Edge"]],
          [
            // Presto based
            /(opera mini)\/([-\w\.]+)/i,
            // Opera Mini
            /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
            // Opera Mobi/Tablet
            /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
            // Opera
          ],
          [NAME, VERSION],
          [
            /opios[\/ ]+([\w\.]+)/i
            // Opera mini on iphone >= 8.0
          ],
          [VERSION, [NAME, OPERA + " Mini"]],
          [
            /\bop(?:rg)?x\/([\w\.]+)/i
            // Opera GX
          ],
          [VERSION, [NAME, OPERA + " GX"]],
          [
            /\bopr\/([\w\.]+)/i
            // Opera Webkit
          ],
          [VERSION, [NAME, OPERA]],
          [
            // Mixed
            /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
            // Baidu
          ],
          [VERSION, [NAME, "Baidu"]],
          [
            /\b(?:mxbrowser|mxios|myie2)\/?([-\w\.]*)\b/i
            // Maxthon
          ],
          [VERSION, [NAME, "Maxthon"]],
          [
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(lunascape|maxthon|netfront|jasmine|blazer|sleipnir)[\/ ]?([\w\.]*)/i,
            // Lunascape/Maxthon/Netfront/Jasmine/Blazer/Sleipnir
            // Trident based
            /(avant|iemobile|slim(?:browser|boat|jet))[\/ ]?([\d\.]*)/i,
            // Avant/IEMobile/SlimBrowser/SlimBoat/Slimjet
            /(?:ms|\()(ie) ([\w\.]+)/i,
            // Internet Explorer
            // Blink/Webkit/KHTML based                                         // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
            /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|duckduckgo|klar|helio|(?=comodo_)?dragon)\/([-\w\.]+)/i,
            // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ//Vivaldi/DuckDuckGo/Klar/Helio/Dragon
            /(heytap|ovi|115)browser\/([\d\.]+)/i,
            // HeyTap/Ovi/115
            /(weibo)__([\d\.]+)/i
            // Weibo
          ],
          [NAME, VERSION],
          [
            /quark(?:pc)?\/([-\w\.]+)/i
            // Quark
          ],
          [VERSION, [NAME, "Quark"]],
          [
            /\bddg\/([\w\.]+)/i
            // DuckDuckGo
          ],
          [VERSION, [NAME, "DuckDuckGo"]],
          [
            /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
            // UCBrowser
          ],
          [VERSION, [NAME, "UC" + BROWSER]],
          [
            /microm.+\bqbcore\/([\w\.]+)/i,
            // WeChat Desktop for Windows Built-in Browser
            /\bqbcore\/([\w\.]+).+microm/i,
            /micromessenger\/([\w\.]+)/i
            // WeChat
          ],
          [VERSION, [NAME, "WeChat"]],
          [
            /konqueror\/([\w\.]+)/i
            // Konqueror
          ],
          [VERSION, [NAME, "Konqueror"]],
          [
            /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
            // IE11
          ],
          [VERSION, [NAME, "IE"]],
          [
            /ya(?:search)?browser\/([\w\.]+)/i
            // Yandex
          ],
          [VERSION, [NAME, "Yandex"]],
          [
            /slbrowser\/([\w\.]+)/i
            // Smart Lenovo Browser
          ],
          [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
          [
            /(avast|avg)\/([\w\.]+)/i
            // Avast/AVG Secure Browser
          ],
          [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
          [
            /\bfocus\/([\w\.]+)/i
            // Firefox Focus
          ],
          [VERSION, [NAME, FIREFOX + " Focus"]],
          [
            /\bopt\/([\w\.]+)/i
            // Opera Touch
          ],
          [VERSION, [NAME, OPERA + " Touch"]],
          [
            /coc_coc\w+\/([\w\.]+)/i
            // Coc Coc Browser
          ],
          [VERSION, [NAME, "Coc Coc"]],
          [
            /dolfin\/([\w\.]+)/i
            // Dolphin
          ],
          [VERSION, [NAME, "Dolphin"]],
          [
            /coast\/([\w\.]+)/i
            // Opera Coast
          ],
          [VERSION, [NAME, OPERA + " Coast"]],
          [
            /miuibrowser\/([\w\.]+)/i
            // MIUI Browser
          ],
          [VERSION, [NAME, "MIUI" + SUFFIX_BROWSER]],
          [
            /fxios\/([\w\.-]+)/i
            // Firefox for iOS
          ],
          [VERSION, [NAME, FIREFOX]],
          [
            /\bqihoobrowser\/?([\w\.]*)/i
            // 360
          ],
          [VERSION, [NAME, "360"]],
          [
            /\b(qq)\/([\w\.]+)/i
            // QQ
          ],
          [[NAME, /(.+)/, "$1Browser"], VERSION],
          [
            /(oculus|sailfish|huawei|vivo|pico)browser\/([\w\.]+)/i
          ],
          [[NAME, /(.+)/, "$1" + SUFFIX_BROWSER], VERSION],
          [
            // Oculus/Sailfish/HuaweiBrowser/VivoBrowser/PicoBrowser
            /samsungbrowser\/([\w\.]+)/i
            // Samsung Internet
          ],
          [VERSION, [NAME, SAMSUNG + " Internet"]],
          [
            /metasr[\/ ]?([\d\.]+)/i
            // Sogou Explorer
          ],
          [VERSION, [NAME, "Sogou Explorer"]],
          [
            /(sogou)mo\w+\/([\d\.]+)/i
            // Sogou Mobile
          ],
          [[NAME, "Sogou Mobile"], VERSION],
          [
            /(electron)\/([\w\.]+) safari/i,
            // Electron-based App
            /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
            // Tesla
            /m?(qqbrowser|2345(?=browser|chrome|explorer))\w*[\/ ]?v?([\w\.]+)/i
            // QQ/2345
          ],
          [NAME, VERSION],
          [
            /(lbbrowser|rekonq)/i,
            // LieBao Browser/Rekonq
            /\[(linkedin)app\]/i
            // LinkedIn App for iOS & Android
          ],
          [NAME],
          [
            /ome\/([\w\.]+) \w* ?(iron) saf/i,
            // Iron
            /ome\/([\w\.]+).+qihu (360)[es]e/i
            // 360
          ],
          [VERSION, NAME],
          [
            // WebView
            /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
            // Facebook App for iOS & Android
          ],
          [[NAME, FACEBOOK], VERSION],
          [
            /(Klarna)\/([\w\.]+)/i,
            // Klarna Shopping Browser for iOS & Android
            /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
            // Kakao App
            /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
            // Naver InApp
            /(daum)apps[\/ ]([\w\.]+)/i,
            // Daum App
            /safari (line)\/([\w\.]+)/i,
            // Line App for iOS
            /\b(line)\/([\w\.]+)\/iab/i,
            // Line App for Android
            /(alipay)client\/([\w\.]+)/i,
            // Alipay
            /(twitter)(?:and| f.+e\/([\w\.]+))/i,
            // Twitter
            /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
            // Chromium/Instagram/Snapchat
          ],
          [NAME, VERSION],
          [
            /\bgsa\/([\w\.]+) .*safari\//i
            // Google Search Appliance on iOS
          ],
          [VERSION, [NAME, "GSA"]],
          [
            /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
            // TikTok
          ],
          [VERSION, [NAME, "TikTok"]],
          [
            /headlesschrome(?:\/([\w\.]+)| )/i
            // Chrome Headless
          ],
          [VERSION, [NAME, CHROME + " Headless"]],
          [
            / wv\).+(chrome)\/([\w\.]+)/i
            // Chrome WebView
          ],
          [[NAME, CHROME + " WebView"], VERSION],
          [
            /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
            // Android Browser
          ],
          [VERSION, [NAME, "Android " + BROWSER]],
          [
            /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
            // Chrome/OmniWeb/Arora/Tizen/Nokia
          ],
          [NAME, VERSION],
          [
            /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
            // Mobile Safari
          ],
          [VERSION, [NAME, "Mobile Safari"]],
          [
            /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
            // Safari & Safari Mobile
          ],
          [VERSION, NAME],
          [
            /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
            // Safari < 3.0
          ],
          [NAME, [VERSION, strMapper, oldSafariMap]],
          [
            /(webkit|khtml)\/([\w\.]+)/i
          ],
          [NAME, VERSION],
          [
            // Gecko based
            /(navigator|netscape\d?)\/([-\w\.]+)/i
            // Netscape
          ],
          [[NAME, "Netscape"], VERSION],
          [
            /(wolvic|librewolf)\/([\w\.]+)/i
            // Wolvic/LibreWolf
          ],
          [NAME, VERSION],
          [
            /mobile vr; rv:([\w\.]+)\).+firefox/i
            // Firefox Reality
          ],
          [VERSION, [NAME, FIREFOX + " Reality"]],
          [
            /ekiohf.+(flow)\/([\w\.]+)/i,
            // Flow
            /(swiftfox)/i,
            // Swiftfox
            /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror)[\/ ]?([\w\.\+]+)/i,
            // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror
            /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
            // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
            /(firefox)\/([\w\.]+)/i,
            // Other Firefox-based
            /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
            // Mozilla
            // Other
            /(amaya|dillo|doris|icab|ladybird|lynx|mosaic|netsurf|obigo|polaris|w3m|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
            // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Obigo/Mosaic/Go/ICE/UP.Browser/Ladybird
            /\b(links) \(([\w\.]+)/i
            // Links
          ],
          [NAME, [VERSION, /_/g, "."]],
          [
            /(cobalt)\/([\w\.]+)/i
            // Cobalt
          ],
          [NAME, [VERSION, /master.|lts./, ""]]
        ],
        cpu: [
          [
            /\b((amd|x|x86[-_]?|wow|win)64)\b/i
            // AMD64 (x64)
          ],
          [[ARCHITECTURE, "amd64"]],
          [
            /(ia32(?=;))/i,
            // IA32 (quicktime)
            /\b((i[346]|x)86)(pc)?\b/i
            // IA32 (x86)
          ],
          [[ARCHITECTURE, "ia32"]],
          [
            /\b(aarch64|arm(v?[89]e?l?|_?64))\b/i
            // ARM64
          ],
          [[ARCHITECTURE, "arm64"]],
          [
            /\b(arm(v[67])?ht?n?[fl]p?)\b/i
            // ARMHF
          ],
          [[ARCHITECTURE, "armhf"]],
          [
            // PocketPC mistakenly identified as PowerPC
            /( (ce|mobile); ppc;|\/[\w\.]+arm\b)/i
          ],
          [[ARCHITECTURE, "arm"]],
          [
            /((ppc|powerpc)(64)?)( mac|;|\))/i
            // PowerPC
          ],
          [[ARCHITECTURE, /ower/, EMPTY2, lowerize]],
          [
            / sun4\w[;\)]/i
            // SPARC
          ],
          [[ARCHITECTURE, "sparc"]],
          [
            /\b(avr32|ia64(?=;)|68k(?=\))|\barm(?=v([1-7]|[5-7]1)l?|;|eabi)|(irix|mips|sparc)(64)?\b|pa-risc)/i
            // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
          ],
          [[ARCHITECTURE, lowerize]]
        ],
        device: [
          [
            //////////////////////////
            // MOBILES & TABLETS
            /////////////////////////
            // Samsung
            /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
          [
            /\b((?:s[cgp]h|gt|sm)-(?![lr])\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
            /samsung[- ]((?!sm-[lr])[-\w]+)/i,
            /sec-(sgh\w+)/i
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
          [
            // Apple
            /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
            // iPod/iPhone
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
          [
            /\((ipad);[-\w\),; ]+apple/i,
            // iPad
            /applecoremedia\/[\w\.]+ \((ipad)/i,
            /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
          [
            /(macintosh);/i
          ],
          [MODEL, [VENDOR, APPLE]],
          [
            // Sharp
            /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
          [
            // Honor
            /\b((?:brt|eln|hey2?|gdi|jdn)-a?[lnw]09|(?:ag[rm]3?|jdn2|kob2)-a?[lw]0[09]hn)(?: bui|\)|;)/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, TABLET]],
          [
            /honor([-\w ]+)[;\)]/i
          ],
          [MODEL, [VENDOR, HONOR], [TYPE, MOBILE]],
          [
            // Huawei
            /\b((?:ag[rs][2356]?k?|bah[234]?|bg[2o]|bt[kv]|cmr|cpn|db[ry]2?|jdn2|got|kob2?k?|mon|pce|scm|sht?|[tw]gr|vrd)-[ad]?[lw][0125][09]b?|605hw|bg2-u03|(?:gem|fdr|m2|ple|t1)-[7a]0[1-4][lu]|t1-a2[13][lw]|mediapad[\w\. ]*(?= bui|\)))\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
          [
            /(?:huawei)([-\w ]+)[;\)]/i,
            /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
          ],
          [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
          [
            // Xiaomi
            /oid[^\)]+; (2[\dbc]{4}(182|283|rp\w{2})[cgl]|m2105k81a?c)(?: bui|\))/i,
            /\b((?:red)?mi[-_ ]?pad[\w- ]*)(?: bui|\))/i
            // Mi Pad tablets
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
          [
            /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
            // Xiaomi POCO
            /\b; (\w+) build\/hm\1/i,
            // Xiaomi Hongmi 'numeric' models
            /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
            // Xiaomi Hongmi
            /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
            // Xiaomi Redmi
            /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
            // Xiaomi Redmi 'numeric' models
            /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite|pro)?)(?: bui|\))/i,
            // Xiaomi Mi
            / ([\w ]+) miui\/v?\d/i
          ],
          [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
          [
            // OPPO
            /; (\w+) bui.+ oppo/i,
            /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, MOBILE]],
          [
            /\b(opd2(\d{3}a?))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, strMapper, { "OnePlus": ["304", "403", "203"], "*": OPPO }], [TYPE, TABLET]],
          [
            // Vivo
            /vivo (\w+)(?: bui|\))/i,
            /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
          ],
          [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
          [
            // Realme
            /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
          ],
          [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
          [
            // Motorola
            /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
            /\bmot(?:orola)?[- ](\w*)/i,
            /((?:moto(?! 360)[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
          [
            /\b(mz60\d|xoom[2 ]{0,2}) build\//i
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
          [
            // LG
            /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, TABLET]],
          [
            /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
            /\blg[-e;\/ ]+((?!browser|netcast|android tv|watch)\w+)/i,
            /\blg-?([\d\w]+) bui/i
          ],
          [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
          [
            // Lenovo
            /(ideatab[-\w ]+|602lv|d-42a|a101lv|a2109a|a3500-hv|s[56]000|pb-6505[my]|tb-?x?\d{3,4}(?:f[cu]|xu|[av])|yt\d?-[jx]?\d+[lfmx])( bui|;|\)|\/)/i,
            /lenovo ?(b[68]0[08]0-?[hf]?|tab(?:[\w- ]+?)|tb[\w-]{6,7})( bui|;|\)|\/)/i
          ],
          [MODEL, [VENDOR, LENOVO], [TYPE, TABLET]],
          [
            // Nokia
            /(nokia) (t[12][01])/i
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(?:maemo|nokia).*(n900|lumia \d+|rm-\d+)/i,
            /nokia[-_ ]?(([-\w\. ]*))/i
          ],
          [[MODEL, /_/g, " "], [TYPE, MOBILE], [VENDOR, "Nokia"]],
          [
            // Google
            /(pixel (c|tablet))\b/i
            // Google Pixel C/Tablet
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
          [
            /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
            // Google Pixel
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
          [
            // Sony
            /droid.+; (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
          ],
          [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
          [
            /sony tablet [ps]/i,
            /\b(?:sony)?sgp\w+(?: bui|\))/i
          ],
          [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
          [
            // OnePlus
            / (kb2005|in20[12]5|be20[12][59])\b/i,
            /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, MOBILE]],
          [
            // Amazon
            /(alexa)webm/i,
            /(kf[a-z]{2}wi|aeo(?!bc)\w\w)( bui|\))/i,
            // Kindle Fire without Silk / Echo Show
            /(kf[a-z]+)( bui|\)).+silk\//i
            // Kindle Fire HD
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
          [
            /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
            // Fire Phone
          ],
          [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
          [
            // BlackBerry
            /(playbook);[-\w\),; ]+(rim)/i
            // BlackBerry PlayBook
          ],
          [MODEL, VENDOR, [TYPE, TABLET]],
          [
            /\b((?:bb[a-f]|st[hv])100-\d)/i,
            /\(bb10; (\w+)/i
            // BlackBerry 10
          ],
          [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
          [
            // Asus
            /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
          [
            / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
          ],
          [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
          [
            // HTC
            /(nexus 9)/i
            // HTC Nexus 9
          ],
          [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
          [
            /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
            // HTC
            // ZTE
            /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
            /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
            // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
          ],
          [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
          [
            // TCL
            /droid [\w\.]+; ((?:8[14]9[16]|9(?:0(?:48|60|8[01])|1(?:3[27]|66)|2(?:6[69]|9[56])|466))[gqswx])\w*(\)| bui)/i
          ],
          [MODEL, [VENDOR, "TCL"], [TYPE, TABLET]],
          [
            // itel
            /(itel) ((\w+))/i
          ],
          [[VENDOR, lowerize], MODEL, [TYPE, strMapper, { "tablet": ["p10001l", "w7001"], "*": "mobile" }]],
          [
            // Acer
            /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
          ],
          [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
          [
            // Meizu
            /droid.+; (m[1-5] note) bui/i,
            /\bmz-([-\w]{2,})/i
          ],
          [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
          [
            // Ulefone
            /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
          [
            // Energizer
            /; (energy ?\w+)(?: bui|\))/i,
            /; energizer ([\w ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Energizer"], [TYPE, MOBILE]],
          [
            // Cat
            /; cat (b35);/i,
            /; (b15q?|s22 flip|s48c|s62 pro)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Cat"], [TYPE, MOBILE]],
          [
            // Smartfren
            /((?:new )?andromax[\w- ]+)(?: bui|\))/i
          ],
          [MODEL, [VENDOR, "Smartfren"], [TYPE, MOBILE]],
          [
            // Nothing
            /droid.+; (a(?:015|06[35]|142p?))/i
          ],
          [MODEL, [VENDOR, "Nothing"], [TYPE, MOBILE]],
          [
            // Archos
            /; (x67 5g|tikeasy \w+|ac[1789]\d\w+)( b|\))/i,
            /archos ?(5|gamepad2?|([\w ]*[t1789]|hello) ?\d+[\w ]*)( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, TABLET]],
          [
            /archos ([\w ]+)( b|\))/i,
            /; (ac[3-6]\d\w{2,8})( b|\))/i
          ],
          [MODEL, [VENDOR, "Archos"], [TYPE, MOBILE]],
          [
            // MIXED
            /(imo) (tab \w+)/i,
            // IMO
            /(infinix) (x1101b?)/i
            // Infinix XPad
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus(?! zenw)|dell|jolla|meizu|motorola|polytron|infinix|tecno|micromax|advan)[-_ ]?([-\w]*)/i,
            // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron/Infinix/Tecno/Micromax/Advan
            /; (hmd|imo) ([\w ]+?)(?: bui|\))/i,
            // HMD/IMO
            /(hp) ([\w ]+\w)/i,
            // HP iPAQ
            /(microsoft); (lumia[\w ]+)/i,
            // Microsoft Lumia
            /(lenovo)[-_ ]?([-\w ]+?)(?: bui|\)|\/)/i,
            // Lenovo
            /(oppo) ?([\w ]+) bui/i
            // OPPO
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kobo)\s(ereader|touch)/i,
            // Kobo
            /(hp).+(touchpad(?!.+tablet)|tablet)/i,
            // HP TouchPad
            /(kindle)\/([\w\.]+)/i,
            // Kindle
            /(nook)[\w ]+build\/(\w+)/i,
            // Nook
            /(dell) (strea[kpr\d ]*[\dko])/i,
            // Dell Streak
            /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
            // Le Pan Tablets
            /(trinity)[- ]*(t\d{3}) bui/i,
            // Trinity Tablets
            /(gigaset)[- ]+(q\w{1,9}) bui/i,
            // Gigaset Tablets
            /(vodafone) ([\w ]+)(?:\)| bui)/i
            // Vodafone
          ],
          [VENDOR, MODEL, [TYPE, TABLET]],
          [
            /(surface duo)/i
            // Surface Duo
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
          [
            /droid [\d\.]+; (fp\du?)(?: b|\))/i
            // Fairphone
          ],
          [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
          [
            /(u304aa)/i
            // AT&T
          ],
          [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
          [
            /\bsie-(\w*)/i
            // Siemens
          ],
          [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
          [
            /\b(rct\w+) b/i
            // RCA Tablets
          ],
          [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
          [
            /\b(venue[\d ]{2,7}) b/i
            // Dell Venue Tablets
          ],
          [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
          [
            /\b(q(?:mv|ta)\w+) b/i
            // Verizon Tablet
          ],
          [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
          [
            /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
            // Barnes & Noble Tablet
          ],
          [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
          [
            /\b(tm\d{3}\w+) b/i
          ],
          [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
          [
            /\b(k88) b/i
            // ZTE K Series Tablet
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
          [
            /\b(nx\d{3}j) b/i
            // ZTE Nubia
          ],
          [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
          [
            /\b(gen\d{3}) b.+49h/i
            // Swiss GEN Mobile
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
          [
            /\b(zur\d{3}) b/i
            // Swiss ZUR Tablet
          ],
          [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
          [
            /\b((zeki)?tb.*\b) b/i
            // Zeki Tablets
          ],
          [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
          [
            /\b([yr]\d{2}) b/i,
            /\b(dragon[- ]+touch |dt)(\w{5}) b/i
            // Dragon Touch Tablet
          ],
          [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
          [
            /\b(ns-?\w{0,9}) b/i
            // Insignia Tablets
          ],
          [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
          [
            /\b((nxa|next)-?\w{0,9}) b/i
            // NextBook Tablets
          ],
          [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
          [
            /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
            // Voice Xtreme Phones
          ],
          [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
          [
            /\b(lvtel\-)?(v1[12]) b/i
            // LvTel Phones
          ],
          [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
          [
            /\b(ph-1) /i
            // Essential PH-1
          ],
          [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
          [
            /\b(v(100md|700na|7011|917g).*\b) b/i
            // Envizen Tablets
          ],
          [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
          [
            /\b(trio[-\w\. ]+) b/i
            // MachSpeed Tablets
          ],
          [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
          [
            /\btu_(1491) b/i
            // Rotor Tablets
          ],
          [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
          [
            /((?:tegranote|shield t(?!.+d tv))[\w- ]*?)(?: b|\))/i
            // Nvidia Tablets
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, TABLET]],
          [
            /(sprint) (\w+)/i
            // Sprint Phones
          ],
          [VENDOR, MODEL, [TYPE, MOBILE]],
          [
            /(kin\.[onetw]{3})/i
            // Microsoft Kin
          ],
          [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
          [
            /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
            // Zebra
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
          [
            /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
          [
            ///////////////////
            // SMARTTVS
            ///////////////////
            /smart-tv.+(samsung)/i
            // Samsung
          ],
          [VENDOR, [TYPE, SMARTTV]],
          [
            /hbbtv.+maple;(\d+)/i
          ],
          [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
          [
            /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
            // LG SmartTV
          ],
          [[VENDOR, LG], [TYPE, SMARTTV]],
          [
            /(apple) ?tv/i
            // Apple TV
          ],
          [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
          [
            /crkey/i
            // Google Chromecast
          ],
          [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
          [
            /droid.+aft(\w+)( bui|\))/i
            // Fire TV
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
          [
            /(shield \w+ tv)/i
            // Nvidia Shield TV
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, SMARTTV]],
          [
            /\(dtv[\);].+(aquos)/i,
            /(aquos-tv[\w ]+)\)/i
            // Sharp
          ],
          [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
          [
            /(bravia[\w ]+)( bui|\))/i
            // Sony
          ],
          [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
          [
            /(mi(tv|box)-?\w+) bui/i
            // Xiaomi
          ],
          [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
          [
            /Hbbtv.*(technisat) (.*);/i
            // TechniSAT
          ],
          [VENDOR, MODEL, [TYPE, SMARTTV]],
          [
            /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
            // Roku
            /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
            // HbbTV devices
          ],
          [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
          [
            // SmartTV from Unidentified Vendors
            /droid.+; ([\w- ]+) (?:android tv|smart[- ]?tv)/i
          ],
          [MODEL, [TYPE, SMARTTV]],
          [
            /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
          ],
          [[TYPE, SMARTTV]],
          [
            ///////////////////
            // CONSOLES
            ///////////////////
            /(ouya)/i,
            // Ouya
            /(nintendo) ([wids3utch]+)/i
            // Nintendo
          ],
          [VENDOR, MODEL, [TYPE, CONSOLE]],
          [
            /droid.+; (shield)( bui|\))/i
            // Nvidia Portable
          ],
          [MODEL, [VENDOR, NVIDIA], [TYPE, CONSOLE]],
          [
            /(playstation \w+)/i
            // Playstation
          ],
          [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
          [
            /\b(xbox(?: one)?(?!; xbox))[\); ]/i
            // Microsoft Xbox
          ],
          [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
          [
            ///////////////////
            // WEARABLES
            ///////////////////
            /\b(sm-[lr]\d\d[0156][fnuw]?s?|gear live)\b/i
            // Samsung Galaxy Watch
          ],
          [MODEL, [VENDOR, SAMSUNG], [TYPE, WEARABLE]],
          [
            /((pebble))app/i,
            // Pebble
            /(asus|google|lg|oppo) ((pixel |zen)?watch[\w ]*)( bui|\))/i
            // Asus ZenWatch / LG Watch / Pixel Watch
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /(ow(?:19|20)?we?[1-3]{1,3})/i
            // Oppo Watch
          ],
          [MODEL, [VENDOR, OPPO], [TYPE, WEARABLE]],
          [
            /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
            // Apple Watch
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
          [
            /(opwwe\d{3})/i
            // OnePlus Watch
          ],
          [MODEL, [VENDOR, ONEPLUS], [TYPE, WEARABLE]],
          [
            /(moto 360)/i
            // Motorola 360
          ],
          [MODEL, [VENDOR, MOTOROLA], [TYPE, WEARABLE]],
          [
            /(smartwatch 3)/i
            // Sony SmartWatch
          ],
          [MODEL, [VENDOR, SONY], [TYPE, WEARABLE]],
          [
            /(g watch r)/i
            // LG G Watch R
          ],
          [MODEL, [VENDOR, LG], [TYPE, WEARABLE]],
          [
            /droid.+; (wt63?0{2,3})\)/i
          ],
          [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
          [
            ///////////////////
            // XR
            ///////////////////
            /droid.+; (glass) \d/i
            // Google Glass
          ],
          [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
          [
            /(pico) (4|neo3(?: link|pro)?)/i
            // Pico
          ],
          [VENDOR, MODEL, [TYPE, WEARABLE]],
          [
            /; (quest( \d| pro)?)/i
            // Oculus Quest
          ],
          [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
          [
            ///////////////////
            // EMBEDDED
            ///////////////////
            /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
            // Tesla
          ],
          [VENDOR, [TYPE, EMBEDDED]],
          [
            /(aeobc)\b/i
            // Echo Dot
          ],
          [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
          [
            /(homepod).+mac os/i
            // Apple HomePod
          ],
          [MODEL, [VENDOR, APPLE], [TYPE, EMBEDDED]],
          [
            /windows iot/i
          ],
          [[TYPE, EMBEDDED]],
          [
            ////////////////////
            // MIXED (GENERIC)
            ///////////////////
            /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
            // Android Phones from Unidentified Vendors
          ],
          [MODEL, [TYPE, MOBILE]],
          [
            /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
            // Android Tablets from Unidentified Vendors
          ],
          [MODEL, [TYPE, TABLET]],
          [
            /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
            // Unidentifiable Tablet
          ],
          [[TYPE, TABLET]],
          [
            /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
            // Unidentifiable Mobile
          ],
          [[TYPE, MOBILE]],
          [
            /droid .+?; ([\w\. -]+)( bui|\))/i
            // Generic Android Device
          ],
          [MODEL, [VENDOR, "Generic"]]
        ],
        engine: [
          [
            /windows.+ edge\/([\w\.]+)/i
            // EdgeHTML
          ],
          [VERSION, [NAME, EDGE + "HTML"]],
          [
            /(arkweb)\/([\w\.]+)/i
            // ArkWeb
          ],
          [NAME, VERSION],
          [
            /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
            // Blink
          ],
          [VERSION, [NAME, "Blink"]],
          [
            /(presto)\/([\w\.]+)/i,
            // Presto
            /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna|servo)\/([\w\.]+)/i,
            // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna/Servo
            /ekioh(flow)\/([\w\.]+)/i,
            // Flow
            /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
            // KHTML/Tasman/Links
            /(icab)[\/ ]([23]\.[\d\.]+)/i,
            // iCab
            /\b(libweb)/i
            // LibWeb
          ],
          [NAME, VERSION],
          [
            /ladybird\//i
          ],
          [[NAME, "LibWeb"]],
          [
            /rv\:([\w\.]{1,9})\b.+(gecko)/i
            // Gecko
          ],
          [VERSION, NAME]
        ],
        os: [
          [
            // Windows
            /microsoft (windows) (vista|xp)/i
            // Windows (iTunes)
          ],
          [NAME, VERSION],
          [
            /(windows (?:phone(?: os)?|mobile|iot))[\/ ]?([\d\.\w ]*)/i
            // Windows Phone
          ],
          [NAME, [VERSION, strMapper, windowsVersionMap]],
          [
            /windows nt 6\.2; (arm)/i,
            // Windows RT
            /windows[\/ ]([ntce\d\. ]+\w)(?!.+xbox)/i,
            /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
          ],
          [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
          [
            // iOS/macOS
            /[adehimnop]{4,7}\b(?:.*os ([\w]+) like mac|; opera)/i,
            // iOS
            /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
            /cfnetwork\/.+darwin/i
          ],
          [[VERSION, /_/g, "."], [NAME, "iOS"]],
          [
            /(mac os x) ?([\w\. ]*)/i,
            /(macintosh|mac_powerpc\b)(?!.+haiku)/i
            // Mac OS
          ],
          [[NAME, MAC_OS], [VERSION, /_/g, "."]],
          [
            // Mobile OSes
            /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
            // Android-x86/HarmonyOS
          ],
          [VERSION, NAME],
          [
            /(ubuntu) ([\w\.]+) like android/i
            // Ubuntu Touch
          ],
          [[NAME, /(.+)/, "$1 Touch"], VERSION],
          [
            // Android/Blackberry/WebOS/QNX/Bada/RIM/KaiOS/Maemo/MeeGo/S40/Sailfish OS/OpenHarmony/Tizen
            /(android|bada|blackberry|kaios|maemo|meego|openharmony|qnx|rim tablet os|sailfish|series40|symbian|tizen|webos)\w*[-\/; ]?([\d\.]*)/i
          ],
          [NAME, VERSION],
          [
            /\(bb(10);/i
            // BlackBerry 10
          ],
          [VERSION, [NAME, BLACKBERRY]],
          [
            /(?:symbian ?os|symbos|s60(?=;)|series ?60)[-\/ ]?([\w\.]*)/i
            // Symbian
          ],
          [VERSION, [NAME, "Symbian"]],
          [
            /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
            // Firefox OS
          ],
          [VERSION, [NAME, FIREFOX + " OS"]],
          [
            /web0s;.+rt(tv)/i,
            /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
            // WebOS
          ],
          [VERSION, [NAME, "webOS"]],
          [
            /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
            // watchOS
          ],
          [VERSION, [NAME, "watchOS"]],
          [
            // Google Chromecast
            /crkey\/([\d\.]+)/i
            // Google Chromecast
          ],
          [VERSION, [NAME, CHROME + "cast"]],
          [
            /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
            // Chromium OS
          ],
          [[NAME, CHROMIUM_OS], VERSION],
          [
            // Smart TVs
            /panasonic;(viera)/i,
            // Panasonic Viera
            /(netrange)mmh/i,
            // Netrange
            /(nettv)\/(\d+\.[\w\.]+)/i,
            // NetTV
            // Console
            /(nintendo|playstation) ([wids345portablevuch]+)/i,
            // Nintendo/Playstation
            /(xbox); +xbox ([^\);]+)/i,
            // Microsoft Xbox (360, One, X, S, Series X, Series S)
            // Other
            /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
            // Joli/Palm
            /(mint)[\/\(\) ]?(\w*)/i,
            // Mint
            /(mageia|vectorlinux)[; ]/i,
            // Mageia/VectorLinux
            /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
            // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
            /(hurd|linux)(?: arm\w*| x86\w*| ?)([\w\.]*)/i,
            // Hurd/Linux
            /(gnu) ?([\w\.]*)/i,
            // GNU
            /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
            // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
            /(haiku) (\w+)/i
            // Haiku
          ],
          [NAME, VERSION],
          [
            /(sunos) ?([\w\.\d]*)/i
            // Solaris
          ],
          [[NAME, "Solaris"], VERSION],
          [
            /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
            // Solaris
            /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
            // AIX
            /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
            // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
            /(unix) ?([\w\.]*)/i
            // UNIX
          ],
          [NAME, VERSION]
        ]
      };
      var UAParser2 = function(ua2, extensions) {
        if (typeof ua2 === OBJ_TYPE) {
          extensions = ua2;
          ua2 = undefined2;
        }
        if (!(this instanceof UAParser2)) {
          return new UAParser2(ua2, extensions).getResult();
        }
        var _navigator = typeof window3 !== UNDEF_TYPE && window3.navigator ? window3.navigator : undefined2;
        var _ua = ua2 || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY2);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined2;
          _browser[VERSION] = undefined2;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined2;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined2;
          _device[MODEL] = undefined2;
          _device[TYPE] = undefined2;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined2;
          _engine[VERSION] = undefined2;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined2;
          _os[VERSION] = undefined2;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return {
            ua: this.getUA(),
            browser: this.getBrowser(),
            engine: this.getEngine(),
            os: this.getOS(),
            device: this.getDevice(),
            cpu: this.getCPU()
          };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua3) {
          _ua = typeof ua3 === STR_TYPE && ua3.length > UA_MAX_LENGTH ? trim(ua3, UA_MAX_LENGTH) : ua3;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser2.VERSION = LIBVERSION;
      UAParser2.BROWSER = enumerize([NAME, VERSION, MAJOR]);
      UAParser2.CPU = enumerize([ARCHITECTURE]);
      UAParser2.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser2.ENGINE = UAParser2.OS = enumerize([NAME, VERSION]);
      if (typeof exports !== UNDEF_TYPE) {
        if (typeof module !== UNDEF_TYPE && module.exports) {
          exports = module.exports = UAParser2;
        }
        exports.UAParser = UAParser2;
      } else {
        if (typeof define === FUNC_TYPE && define.amd) {
          define(function() {
            return UAParser2;
          });
        } else if (typeof window3 !== UNDEF_TYPE) {
          window3.UAParser = UAParser2;
        }
      }
      var $2 = typeof window3 !== UNDEF_TYPE && (window3.jQuery || window3.Zepto);
      if ($2 && !$2.ua) {
        var parser = new UAParser2();
        $2.ua = parser.getResult();
        $2.ua.get = function() {
          return parser.getUA();
        };
        $2.ua.set = function(ua2) {
          parser.setUA(ua2);
          var result = parser.getResult();
          for (var prop in result) {
            $2.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports);
  }
});

// node_modules/webrtc-adapter/src/js/utils.js
var logDisabled_ = true;
var deprecationWarnings_ = true;
function extractVersion(uastring, expr, pos) {
  const match = uastring.match(expr);
  return match && match.length >= pos && parseFloat(match[pos], 10);
}
function wrapPeerConnectionEvent(window3, eventNameToWrap, wrapper) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  const proto = window3.RTCPeerConnection.prototype;
  const nativeAddEventListener = proto.addEventListener;
  proto.addEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap) {
      return nativeAddEventListener.apply(this, arguments);
    }
    const wrappedCallback = (e2) => {
      const modifiedEvent = wrapper(e2);
      if (modifiedEvent) {
        if (cb.handleEvent) {
          cb.handleEvent(modifiedEvent);
        } else {
          cb(modifiedEvent);
        }
      }
    };
    this._eventMap = this._eventMap || {};
    if (!this._eventMap[eventNameToWrap]) {
      this._eventMap[eventNameToWrap] = /* @__PURE__ */ new Map();
    }
    this._eventMap[eventNameToWrap].set(cb, wrappedCallback);
    return nativeAddEventListener.apply(this, [
      nativeEventName,
      wrappedCallback
    ]);
  };
  const nativeRemoveEventListener = proto.removeEventListener;
  proto.removeEventListener = function(nativeEventName, cb) {
    if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    if (!this._eventMap[eventNameToWrap].has(cb)) {
      return nativeRemoveEventListener.apply(this, arguments);
    }
    const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);
    this._eventMap[eventNameToWrap].delete(cb);
    if (this._eventMap[eventNameToWrap].size === 0) {
      delete this._eventMap[eventNameToWrap];
    }
    if (Object.keys(this._eventMap).length === 0) {
      delete this._eventMap;
    }
    return nativeRemoveEventListener.apply(this, [
      nativeEventName,
      unwrappedCb
    ]);
  };
  Object.defineProperty(proto, "on" + eventNameToWrap, {
    get() {
      return this["_on" + eventNameToWrap];
    },
    set(cb) {
      if (this["_on" + eventNameToWrap]) {
        this.removeEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap]
        );
        delete this["_on" + eventNameToWrap];
      }
      if (cb) {
        this.addEventListener(
          eventNameToWrap,
          this["_on" + eventNameToWrap] = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
}
function disableLog(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  logDisabled_ = bool;
  return bool ? "adapter.js logging disabled" : "adapter.js logging enabled";
}
function disableWarnings(bool) {
  if (typeof bool !== "boolean") {
    return new Error("Argument type: " + typeof bool + ". Please use a boolean.");
  }
  deprecationWarnings_ = !bool;
  return "adapter.js deprecation warnings " + (bool ? "disabled" : "enabled");
}
function log() {
  if (typeof window === "object") {
    if (logDisabled_) {
      return;
    }
    if (typeof console !== "undefined" && typeof console.log === "function") {
      console.log.apply(console, arguments);
    }
  }
}
function deprecated(oldMethod, newMethod) {
  if (!deprecationWarnings_) {
    return;
  }
  console.warn(oldMethod + " is deprecated, please use " + newMethod + " instead.");
}
function detectBrowser(window3) {
  const result = { browser: null, version: null };
  if (typeof window3 === "undefined" || !window3.navigator || !window3.navigator.userAgent) {
    result.browser = "Not a browser.";
    return result;
  }
  const { navigator: navigator2 } = window3;
  if (navigator2.mozGetUserMedia) {
    result.browser = "firefox";
    result.version = parseInt(extractVersion(
      navigator2.userAgent,
      /Firefox\/(\d+)\./,
      1
    ));
  } else if (navigator2.webkitGetUserMedia || window3.isSecureContext === false && window3.webkitRTCPeerConnection) {
    result.browser = "chrome";
    result.version = parseInt(extractVersion(
      navigator2.userAgent,
      /Chrom(e|ium)\/(\d+)\./,
      2
    ));
  } else if (window3.RTCPeerConnection && navigator2.userAgent.match(/AppleWebKit\/(\d+)\./)) {
    result.browser = "safari";
    result.version = parseInt(extractVersion(
      navigator2.userAgent,
      /AppleWebKit\/(\d+)\./,
      1
    ));
    result.supportsUnifiedPlan = window3.RTCRtpTransceiver && "currentDirection" in window3.RTCRtpTransceiver.prototype;
    result._safariVersion = extractVersion(
      navigator2.userAgent,
      /Version\/(\d+(\.?\d+))/,
      1
    );
  } else {
    result.browser = "Not a supported browser.";
    return result;
  }
  return result;
}
function isObject(val) {
  return Object.prototype.toString.call(val) === "[object Object]";
}
function compactObject(data) {
  if (!isObject(data)) {
    return data;
  }
  return Object.keys(data).reduce(function(accumulator, key) {
    const isObj = isObject(data[key]);
    const value = isObj ? compactObject(data[key]) : data[key];
    const isEmptyObject = isObj && !Object.keys(value).length;
    if (value === void 0 || isEmptyObject) {
      return accumulator;
    }
    return Object.assign(accumulator, { [key]: value });
  }, {});
}
function walkStats(stats, base, resultSet) {
  if (!base || resultSet.has(base.id)) {
    return;
  }
  resultSet.set(base.id, base);
  Object.keys(base).forEach((name2) => {
    if (name2.endsWith("Id")) {
      walkStats(stats, stats.get(base[name2]), resultSet);
    } else if (name2.endsWith("Ids")) {
      base[name2].forEach((id) => {
        walkStats(stats, stats.get(id), resultSet);
      });
    }
  });
}
function filterStats(result, track, outbound) {
  const streamStatsType = outbound ? "outbound-rtp" : "inbound-rtp";
  const filteredResult = /* @__PURE__ */ new Map();
  if (track === null) {
    return filteredResult;
  }
  const trackStats = [];
  result.forEach((value) => {
    if (value.type === "track" && value.trackIdentifier === track.id) {
      trackStats.push(value);
    }
  });
  trackStats.forEach((trackStat) => {
    result.forEach((stats) => {
      if (stats.type === streamStatsType && stats.trackId === trackStat.id) {
        walkStats(result, stats, filteredResult);
      }
    });
  });
  return filteredResult;
}

// node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
var chrome_shim_exports = {};
__export(chrome_shim_exports, {
  fixNegotiationNeeded: () => fixNegotiationNeeded,
  shimAddTrackRemoveTrack: () => shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative: () => shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: () => shimGetDisplayMedia,
  shimGetSendersWithDtmf: () => shimGetSendersWithDtmf,
  shimGetStats: () => shimGetStats,
  shimGetUserMedia: () => shimGetUserMedia,
  shimMediaStream: () => shimMediaStream,
  shimOnTrack: () => shimOnTrack,
  shimPeerConnection: () => shimPeerConnection,
  shimSenderReceiverGetStats: () => shimSenderReceiverGetStats
});

// node_modules/webrtc-adapter/src/js/chrome/getusermedia.js
var logging = log;
function shimGetUserMedia(window3, browserDetails) {
  const navigator2 = window3 && window3.navigator;
  if (!navigator2.mediaDevices) {
    return;
  }
  const constraintsToChrome_ = function(c2) {
    if (typeof c2 !== "object" || c2.mandatory || c2.optional) {
      return c2;
    }
    const cc2 = {};
    Object.keys(c2).forEach((key) => {
      if (key === "require" || key === "advanced" || key === "mediaSource") {
        return;
      }
      const r2 = typeof c2[key] === "object" ? c2[key] : { ideal: c2[key] };
      if (r2.exact !== void 0 && typeof r2.exact === "number") {
        r2.min = r2.max = r2.exact;
      }
      const oldname_ = function(prefix, name2) {
        if (prefix) {
          return prefix + name2.charAt(0).toUpperCase() + name2.slice(1);
        }
        return name2 === "deviceId" ? "sourceId" : name2;
      };
      if (r2.ideal !== void 0) {
        cc2.optional = cc2.optional || [];
        let oc2 = {};
        if (typeof r2.ideal === "number") {
          oc2[oldname_("min", key)] = r2.ideal;
          cc2.optional.push(oc2);
          oc2 = {};
          oc2[oldname_("max", key)] = r2.ideal;
          cc2.optional.push(oc2);
        } else {
          oc2[oldname_("", key)] = r2.ideal;
          cc2.optional.push(oc2);
        }
      }
      if (r2.exact !== void 0 && typeof r2.exact !== "number") {
        cc2.mandatory = cc2.mandatory || {};
        cc2.mandatory[oldname_("", key)] = r2.exact;
      } else {
        ["min", "max"].forEach((mix) => {
          if (r2[mix] !== void 0) {
            cc2.mandatory = cc2.mandatory || {};
            cc2.mandatory[oldname_(mix, key)] = r2[mix];
          }
        });
      }
    });
    if (c2.advanced) {
      cc2.optional = (cc2.optional || []).concat(c2.advanced);
    }
    return cc2;
  };
  const shimConstraints_ = function(constraints, func) {
    if (browserDetails.version >= 61) {
      return func(constraints);
    }
    constraints = JSON.parse(JSON.stringify(constraints));
    if (constraints && typeof constraints.audio === "object") {
      const remap = function(obj, a2, b2) {
        if (a2 in obj && !(b2 in obj)) {
          obj[b2] = obj[a2];
          delete obj[a2];
        }
      };
      constraints = JSON.parse(JSON.stringify(constraints));
      remap(constraints.audio, "autoGainControl", "googAutoGainControl");
      remap(constraints.audio, "noiseSuppression", "googNoiseSuppression");
      constraints.audio = constraintsToChrome_(constraints.audio);
    }
    if (constraints && typeof constraints.video === "object") {
      let face = constraints.video.facingMode;
      face = face && (typeof face === "object" ? face : { ideal: face });
      const getSupportedFacingModeLies = browserDetails.version < 66;
      if (face && (face.exact === "user" || face.exact === "environment" || face.ideal === "user" || face.ideal === "environment") && !(navigator2.mediaDevices.getSupportedConstraints && navigator2.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {
        delete constraints.video.facingMode;
        let matches;
        if (face.exact === "environment" || face.ideal === "environment") {
          matches = ["back", "rear"];
        } else if (face.exact === "user" || face.ideal === "user") {
          matches = ["front"];
        }
        if (matches) {
          return navigator2.mediaDevices.enumerateDevices().then((devices) => {
            devices = devices.filter((d) => d.kind === "videoinput");
            let dev = devices.find((d) => matches.some((match) => d.label.toLowerCase().includes(match)));
            if (!dev && devices.length && matches.includes("back")) {
              dev = devices[devices.length - 1];
            }
            if (dev) {
              constraints.video.deviceId = face.exact ? { exact: dev.deviceId } : { ideal: dev.deviceId };
            }
            constraints.video = constraintsToChrome_(constraints.video);
            logging("chrome: " + JSON.stringify(constraints));
            return func(constraints);
          });
        }
      }
      constraints.video = constraintsToChrome_(constraints.video);
    }
    logging("chrome: " + JSON.stringify(constraints));
    return func(constraints);
  };
  const shimError_ = function(e2) {
    if (browserDetails.version >= 64) {
      return e2;
    }
    return {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[e2.name] || e2.name,
      message: e2.message,
      constraint: e2.constraint || e2.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  };
  const getUserMedia_ = function(constraints, onSuccess, onError) {
    shimConstraints_(constraints, (c2) => {
      navigator2.webkitGetUserMedia(c2, onSuccess, (e2) => {
        if (onError) {
          onError(shimError_(e2));
        }
      });
    });
  };
  navigator2.getUserMedia = getUserMedia_.bind(navigator2);
  if (navigator2.mediaDevices.getUserMedia) {
    const origGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(cs2) {
      return shimConstraints_(cs2, (c2) => origGetUserMedia(c2).then((stream) => {
        if (c2.audio && !stream.getAudioTracks().length || c2.video && !stream.getVideoTracks().length) {
          stream.getTracks().forEach((track) => {
            track.stop();
          });
          throw new DOMException("", "NotFoundError");
        }
        return stream;
      }, (e2) => Promise.reject(shimError_(e2))));
    };
  }
}

// node_modules/webrtc-adapter/src/js/chrome/getdisplaymedia.js
function shimGetDisplayMedia(window3, getSourceId) {
  if (window3.navigator.mediaDevices && "getDisplayMedia" in window3.navigator.mediaDevices) {
    return;
  }
  if (!window3.navigator.mediaDevices) {
    return;
  }
  if (typeof getSourceId !== "function") {
    console.error("shimGetDisplayMedia: getSourceId argument is not a function");
    return;
  }
  window3.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    return getSourceId(constraints).then((sourceId) => {
      const widthSpecified = constraints.video && constraints.video.width;
      const heightSpecified = constraints.video && constraints.video.height;
      const frameRateSpecified = constraints.video && constraints.video.frameRate;
      constraints.video = {
        mandatory: {
          chromeMediaSource: "desktop",
          chromeMediaSourceId: sourceId,
          maxFrameRate: frameRateSpecified || 3
        }
      };
      if (widthSpecified) {
        constraints.video.mandatory.maxWidth = widthSpecified;
      }
      if (heightSpecified) {
        constraints.video.mandatory.maxHeight = heightSpecified;
      }
      return window3.navigator.mediaDevices.getUserMedia(constraints);
    });
  };
}

// node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js
function shimMediaStream(window3) {
  window3.MediaStream = window3.MediaStream || window3.webkitMediaStream;
}
function shimOnTrack(window3) {
  if (typeof window3 === "object" && window3.RTCPeerConnection && !("ontrack" in window3.RTCPeerConnection.prototype)) {
    Object.defineProperty(window3.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(f) {
        if (this._ontrack) {
          this.removeEventListener("track", this._ontrack);
        }
        this.addEventListener("track", this._ontrack = f);
      },
      enumerable: true,
      configurable: true
    });
    const origSetRemoteDescription = window3.RTCPeerConnection.prototype.setRemoteDescription;
    window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      if (!this._ontrackpoly) {
        this._ontrackpoly = (e2) => {
          e2.stream.addEventListener("addtrack", (te2) => {
            let receiver;
            if (window3.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === te2.track.id);
            } else {
              receiver = { track: te2.track };
            }
            const event = new Event("track");
            event.track = te2.track;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e2.stream];
            this.dispatchEvent(event);
          });
          e2.stream.getTracks().forEach((track) => {
            let receiver;
            if (window3.RTCPeerConnection.prototype.getReceivers) {
              receiver = this.getReceivers().find((r2) => r2.track && r2.track.id === track.id);
            } else {
              receiver = { track };
            }
            const event = new Event("track");
            event.track = track;
            event.receiver = receiver;
            event.transceiver = { receiver };
            event.streams = [e2.stream];
            this.dispatchEvent(event);
          });
        };
        this.addEventListener("addstream", this._ontrackpoly);
      }
      return origSetRemoteDescription.apply(this, arguments);
    };
  } else {
    wrapPeerConnectionEvent(window3, "track", (e2) => {
      if (!e2.transceiver) {
        Object.defineProperty(
          e2,
          "transceiver",
          { value: { receiver: e2.receiver } }
        );
      }
      return e2;
    });
  }
}
function shimGetSendersWithDtmf(window3) {
  if (typeof window3 === "object" && window3.RTCPeerConnection && !("getSenders" in window3.RTCPeerConnection.prototype) && "createDTMFSender" in window3.RTCPeerConnection.prototype) {
    const shimSenderWithDtmf = function(pc2, track) {
      return {
        track,
        get dtmf() {
          if (this._dtmf === void 0) {
            if (track.kind === "audio") {
              this._dtmf = pc2.createDTMFSender(track);
            } else {
              this._dtmf = null;
            }
          }
          return this._dtmf;
        },
        _pc: pc2
      };
    };
    if (!window3.RTCPeerConnection.prototype.getSenders) {
      window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
        this._senders = this._senders || [];
        return this._senders.slice();
      };
      const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
      window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
        let sender = origAddTrack.apply(this, arguments);
        if (!sender) {
          sender = shimSenderWithDtmf(this, track);
          this._senders.push(sender);
        }
        return sender;
      };
      const origRemoveTrack = window3.RTCPeerConnection.prototype.removeTrack;
      window3.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
        origRemoveTrack.apply(this, arguments);
        const idx = this._senders.indexOf(sender);
        if (idx !== -1) {
          this._senders.splice(idx, 1);
        }
      };
    }
    const origAddStream = window3.RTCPeerConnection.prototype.addStream;
    window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      this._senders = this._senders || [];
      origAddStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        this._senders.push(shimSenderWithDtmf(this, track));
      });
    };
    const origRemoveStream = window3.RTCPeerConnection.prototype.removeStream;
    window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      this._senders = this._senders || [];
      origRemoveStream.apply(this, [stream]);
      stream.getTracks().forEach((track) => {
        const sender = this._senders.find((s2) => s2.track === track);
        if (sender) {
          this._senders.splice(this._senders.indexOf(sender), 1);
        }
      });
    };
  } else if (typeof window3 === "object" && window3.RTCPeerConnection && "getSenders" in window3.RTCPeerConnection.prototype && "createDTMFSender" in window3.RTCPeerConnection.prototype && window3.RTCRtpSender && !("dtmf" in window3.RTCRtpSender.prototype)) {
    const origGetSenders = window3.RTCPeerConnection.prototype.getSenders;
    window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
    Object.defineProperty(window3.RTCRtpSender.prototype, "dtmf", {
      get() {
        if (this._dtmf === void 0) {
          if (this.track.kind === "audio") {
            this._dtmf = this._pc.createDTMFSender(this.track);
          } else {
            this._dtmf = null;
          }
        }
        return this._dtmf;
      }
    });
  }
}
function shimGetStats(window3) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  const origGetStats = window3.RTCPeerConnection.prototype.getStats;
  window3.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    if (arguments.length > 0 && typeof selector === "function") {
      return origGetStats.apply(this, arguments);
    }
    if (origGetStats.length === 0 && (arguments.length === 0 || typeof selector !== "function")) {
      return origGetStats.apply(this, []);
    }
    const fixChromeStats_ = function(response) {
      const standardReport = {};
      const reports = response.result();
      reports.forEach((report) => {
        const standardStats = {
          id: report.id,
          timestamp: report.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[report.type] || report.type
        };
        report.names().forEach((name2) => {
          standardStats[name2] = report.stat(name2);
        });
        standardReport[standardStats.id] = standardStats;
      });
      return standardReport;
    };
    const makeMapStats = function(stats) {
      return new Map(Object.keys(stats).map((key) => [key, stats[key]]));
    };
    if (arguments.length >= 2) {
      const successCallbackWrapper_ = function(response) {
        onSucc(makeMapStats(fixChromeStats_(response)));
      };
      return origGetStats.apply(this, [
        successCallbackWrapper_,
        selector
      ]);
    }
    return new Promise((resolve, reject) => {
      origGetStats.apply(this, [
        function(response) {
          resolve(makeMapStats(fixChromeStats_(response)));
        },
        reject
      ]);
    }).then(onSucc, onErr);
  };
}
function shimSenderReceiverGetStats(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection && window3.RTCRtpSender && window3.RTCRtpReceiver)) {
    return;
  }
  if (!("getStats" in window3.RTCRtpSender.prototype)) {
    const origGetSenders = window3.RTCPeerConnection.prototype.getSenders;
    if (origGetSenders) {
      window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
        const senders = origGetSenders.apply(this, []);
        senders.forEach((sender) => sender._pc = this);
        return senders;
      };
    }
    const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
    if (origAddTrack) {
      window3.RTCPeerConnection.prototype.addTrack = function addTrack() {
        const sender = origAddTrack.apply(this, arguments);
        sender._pc = this;
        return sender;
      };
    }
    window3.RTCRtpSender.prototype.getStats = function getStats() {
      const sender = this;
      return this._pc.getStats().then((result) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(result, sender.track, true)
      ));
    };
  }
  if (!("getStats" in window3.RTCRtpReceiver.prototype)) {
    const origGetReceivers = window3.RTCPeerConnection.prototype.getReceivers;
    if (origGetReceivers) {
      window3.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
        const receivers = origGetReceivers.apply(this, []);
        receivers.forEach((receiver) => receiver._pc = this);
        return receivers;
      };
    }
    wrapPeerConnectionEvent(window3, "track", (e2) => {
      e2.receiver._pc = e2.srcElement;
      return e2;
    });
    window3.RTCRtpReceiver.prototype.getStats = function getStats() {
      const receiver = this;
      return this._pc.getStats().then((result) => filterStats(result, receiver.track, false));
    };
  }
  if (!("getStats" in window3.RTCRtpSender.prototype && "getStats" in window3.RTCRtpReceiver.prototype)) {
    return;
  }
  const origGetStats = window3.RTCPeerConnection.prototype.getStats;
  window3.RTCPeerConnection.prototype.getStats = function getStats() {
    if (arguments.length > 0 && arguments[0] instanceof window3.MediaStreamTrack) {
      const track = arguments[0];
      let sender;
      let receiver;
      let err;
      this.getSenders().forEach((s2) => {
        if (s2.track === track) {
          if (sender) {
            err = true;
          } else {
            sender = s2;
          }
        }
      });
      this.getReceivers().forEach((r2) => {
        if (r2.track === track) {
          if (receiver) {
            err = true;
          } else {
            receiver = r2;
          }
        }
        return r2.track === track;
      });
      if (err || sender && receiver) {
        return Promise.reject(new DOMException(
          "There are more than one sender or receiver for the track.",
          "InvalidAccessError"
        ));
      } else if (sender) {
        return sender.getStats();
      } else if (receiver) {
        return receiver.getStats();
      }
      return Promise.reject(new DOMException(
        "There is no sender or receiver for the track.",
        "InvalidAccessError"
      ));
    }
    return origGetStats.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(window3) {
  window3.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    return Object.keys(this._shimmedLocalStreams).map((streamId) => this._shimmedLocalStreams[streamId][0]);
  };
  const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
  window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (!stream) {
      return origAddTrack.apply(this, arguments);
    }
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const sender = origAddTrack.apply(this, arguments);
    if (!this._shimmedLocalStreams[stream.id]) {
      this._shimmedLocalStreams[stream.id] = [stream, sender];
    } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {
      this._shimmedLocalStreams[stream.id].push(sender);
    }
    return sender;
  };
  const origAddStream = window3.RTCPeerConnection.prototype.addStream;
  window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s2) => s2.track === track);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    const existingSenders = this.getSenders();
    origAddStream.apply(this, arguments);
    const newSenders = this.getSenders().filter((newSender) => existingSenders.indexOf(newSender) === -1);
    this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);
  };
  const origRemoveStream = window3.RTCPeerConnection.prototype.removeStream;
  window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    delete this._shimmedLocalStreams[stream.id];
    return origRemoveStream.apply(this, arguments);
  };
  const origRemoveTrack = window3.RTCPeerConnection.prototype.removeTrack;
  window3.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    if (sender) {
      Object.keys(this._shimmedLocalStreams).forEach((streamId) => {
        const idx = this._shimmedLocalStreams[streamId].indexOf(sender);
        if (idx !== -1) {
          this._shimmedLocalStreams[streamId].splice(idx, 1);
        }
        if (this._shimmedLocalStreams[streamId].length === 1) {
          delete this._shimmedLocalStreams[streamId];
        }
      });
    }
    return origRemoveTrack.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(window3, browserDetails) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (window3.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {
    return shimAddTrackRemoveTrackWithNative(window3);
  }
  const origGetLocalStreams = window3.RTCPeerConnection.prototype.getLocalStreams;
  window3.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
    const nativeStreams = origGetLocalStreams.apply(this);
    this._reverseStreams = this._reverseStreams || {};
    return nativeStreams.map((stream) => this._reverseStreams[stream.id]);
  };
  const origAddStream = window3.RTCPeerConnection.prototype.addStream;
  window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    stream.getTracks().forEach((track) => {
      const alreadyExists = this.getSenders().find((s2) => s2.track === track);
      if (alreadyExists) {
        throw new DOMException(
          "Track already exists.",
          "InvalidAccessError"
        );
      }
    });
    if (!this._reverseStreams[stream.id]) {
      const newStream = new window3.MediaStream(stream.getTracks());
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      stream = newStream;
    }
    origAddStream.apply(this, [stream]);
  };
  const origRemoveStream = window3.RTCPeerConnection.prototype.removeStream;
  window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    origRemoveStream.apply(this, [this._streams[stream.id] || stream]);
    delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];
    delete this._streams[stream.id];
  };
  window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    const streams = [].slice.call(arguments, 1);
    if (streams.length !== 1 || !streams[0].getTracks().find((t2) => t2 === track)) {
      throw new DOMException(
        "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
        "NotSupportedError"
      );
    }
    const alreadyExists = this.getSenders().find((s2) => s2.track === track);
    if (alreadyExists) {
      throw new DOMException(
        "Track already exists.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    this._reverseStreams = this._reverseStreams || {};
    const oldStream = this._streams[stream.id];
    if (oldStream) {
      oldStream.addTrack(track);
      Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    } else {
      const newStream = new window3.MediaStream([track]);
      this._streams[stream.id] = newStream;
      this._reverseStreams[newStream.id] = stream;
      this.addStream(newStream);
    }
    return this.getSenders().find((s2) => s2.track === track);
  };
  function replaceInternalStreamId(pc2, description) {
    let sdp2 = description.sdp;
    Object.keys(pc2._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc2._reverseStreams[internalId];
      const internalStream = pc2._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(internalStream.id, "g"),
        externalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  function replaceExternalStreamId(pc2, description) {
    let sdp2 = description.sdp;
    Object.keys(pc2._reverseStreams || []).forEach((internalId) => {
      const externalStream = pc2._reverseStreams[internalId];
      const internalStream = pc2._streams[externalStream.id];
      sdp2 = sdp2.replace(
        new RegExp(externalStream.id, "g"),
        internalStream.id
      );
    });
    return new RTCSessionDescription({
      type: description.type,
      sdp: sdp2
    });
  }
  ["createOffer", "createAnswer"].forEach(function(method) {
    const nativeMethod = window3.RTCPeerConnection.prototype[method];
    const methodObj = { [method]() {
      const args = arguments;
      const isLegacyCall = arguments.length && typeof arguments[0] === "function";
      if (isLegacyCall) {
        return nativeMethod.apply(this, [
          (description) => {
            const desc = replaceInternalStreamId(this, description);
            args[0].apply(null, [desc]);
          },
          (err) => {
            if (args[1]) {
              args[1].apply(null, err);
            }
          },
          arguments[2]
        ]);
      }
      return nativeMethod.apply(this, arguments).then((description) => replaceInternalStreamId(this, description));
    } };
    window3.RTCPeerConnection.prototype[method] = methodObj[method];
  });
  const origSetLocalDescription = window3.RTCPeerConnection.prototype.setLocalDescription;
  window3.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    if (!arguments.length || !arguments[0].type) {
      return origSetLocalDescription.apply(this, arguments);
    }
    arguments[0] = replaceExternalStreamId(this, arguments[0]);
    return origSetLocalDescription.apply(this, arguments);
  };
  const origLocalDescription = Object.getOwnPropertyDescriptor(
    window3.RTCPeerConnection.prototype,
    "localDescription"
  );
  Object.defineProperty(
    window3.RTCPeerConnection.prototype,
    "localDescription",
    {
      get() {
        const description = origLocalDescription.get.apply(this);
        if (description.type === "") {
          return description;
        }
        return replaceInternalStreamId(this, description);
      }
    }
  );
  window3.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {
    if (this.signalingState === "closed") {
      throw new DOMException(
        "The RTCPeerConnection's signalingState is 'closed'.",
        "InvalidStateError"
      );
    }
    if (!sender._pc) {
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    }
    const isLocal = sender._pc === this;
    if (!isLocal) {
      throw new DOMException(
        "Sender was not created by this connection.",
        "InvalidAccessError"
      );
    }
    this._streams = this._streams || {};
    let stream;
    Object.keys(this._streams).forEach((streamid) => {
      const hasTrack = this._streams[streamid].getTracks().find((track) => sender.track === track);
      if (hasTrack) {
        stream = this._streams[streamid];
      }
    });
    if (stream) {
      if (stream.getTracks().length === 1) {
        this.removeStream(this._reverseStreams[stream.id]);
      } else {
        stream.removeTrack(sender.track);
      }
      this.dispatchEvent(new Event("negotiationneeded"));
    }
  };
}
function shimPeerConnection(window3, browserDetails) {
  if (!window3.RTCPeerConnection && window3.webkitRTCPeerConnection) {
    window3.RTCPeerConnection = window3.webkitRTCPeerConnection;
  }
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window3.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window3.RTCIceCandidate : window3.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window3.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
}
function fixNegotiationNeeded(window3, browserDetails) {
  wrapPeerConnectionEvent(window3, "negotiationneeded", (e2) => {
    const pc2 = e2.target;
    if (browserDetails.version < 72 || pc2.getConfiguration && pc2.getConfiguration().sdpSemantics === "plan-b") {
      if (pc2.signalingState !== "stable") {
        return;
      }
    }
    return e2;
  });
}

// node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
var firefox_shim_exports = {};
__export(firefox_shim_exports, {
  shimAddTransceiver: () => shimAddTransceiver,
  shimCreateAnswer: () => shimCreateAnswer,
  shimCreateOffer: () => shimCreateOffer,
  shimGetDisplayMedia: () => shimGetDisplayMedia2,
  shimGetParameters: () => shimGetParameters,
  shimGetUserMedia: () => shimGetUserMedia2,
  shimOnTrack: () => shimOnTrack2,
  shimPeerConnection: () => shimPeerConnection2,
  shimRTCDataChannel: () => shimRTCDataChannel,
  shimReceiverGetStats: () => shimReceiverGetStats,
  shimRemoveStream: () => shimRemoveStream,
  shimSenderGetStats: () => shimSenderGetStats
});

// node_modules/webrtc-adapter/src/js/firefox/getusermedia.js
function shimGetUserMedia2(window3, browserDetails) {
  const navigator2 = window3 && window3.navigator;
  const MediaStreamTrack = window3 && window3.MediaStreamTrack;
  navigator2.getUserMedia = function(constraints, onSuccess, onError) {
    deprecated(
      "navigator.getUserMedia",
      "navigator.mediaDevices.getUserMedia"
    );
    navigator2.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);
  };
  if (!(browserDetails.version > 55 && "autoGainControl" in navigator2.mediaDevices.getSupportedConstraints())) {
    const remap = function(obj, a2, b2) {
      if (a2 in obj && !(b2 in obj)) {
        obj[b2] = obj[a2];
        delete obj[a2];
      }
    };
    const nativeGetUserMedia = navigator2.mediaDevices.getUserMedia.bind(navigator2.mediaDevices);
    navigator2.mediaDevices.getUserMedia = function(c2) {
      if (typeof c2 === "object" && typeof c2.audio === "object") {
        c2 = JSON.parse(JSON.stringify(c2));
        remap(c2.audio, "autoGainControl", "mozAutoGainControl");
        remap(c2.audio, "noiseSuppression", "mozNoiseSuppression");
      }
      return nativeGetUserMedia(c2);
    };
    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {
      const nativeGetSettings = MediaStreamTrack.prototype.getSettings;
      MediaStreamTrack.prototype.getSettings = function() {
        const obj = nativeGetSettings.apply(this, arguments);
        remap(obj, "mozAutoGainControl", "autoGainControl");
        remap(obj, "mozNoiseSuppression", "noiseSuppression");
        return obj;
      };
    }
    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {
      const nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;
      MediaStreamTrack.prototype.applyConstraints = function(c2) {
        if (this.kind === "audio" && typeof c2 === "object") {
          c2 = JSON.parse(JSON.stringify(c2));
          remap(c2, "autoGainControl", "mozAutoGainControl");
          remap(c2, "noiseSuppression", "mozNoiseSuppression");
        }
        return nativeApplyConstraints.apply(this, [c2]);
      };
    }
  }
}

// node_modules/webrtc-adapter/src/js/firefox/getdisplaymedia.js
function shimGetDisplayMedia2(window3, preferredMediaSource) {
  if (window3.navigator.mediaDevices && "getDisplayMedia" in window3.navigator.mediaDevices) {
    return;
  }
  if (!window3.navigator.mediaDevices) {
    return;
  }
  window3.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {
    if (!(constraints && constraints.video)) {
      const err = new DOMException("getDisplayMedia without video constraints is undefined");
      err.name = "NotFoundError";
      err.code = 8;
      return Promise.reject(err);
    }
    if (constraints.video === true) {
      constraints.video = { mediaSource: preferredMediaSource };
    } else {
      constraints.video.mediaSource = preferredMediaSource;
    }
    return window3.navigator.mediaDevices.getUserMedia(constraints);
  };
}

// node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js
function shimOnTrack2(window3) {
  if (typeof window3 === "object" && window3.RTCTrackEvent && "receiver" in window3.RTCTrackEvent.prototype && !("transceiver" in window3.RTCTrackEvent.prototype)) {
    Object.defineProperty(window3.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
function shimPeerConnection2(window3, browserDetails) {
  if (typeof window3 !== "object" || !(window3.RTCPeerConnection || window3.mozRTCPeerConnection)) {
    return;
  }
  if (!window3.RTCPeerConnection && window3.mozRTCPeerConnection) {
    window3.RTCPeerConnection = window3.mozRTCPeerConnection;
  }
  if (browserDetails.version < 53) {
    ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(method) {
      const nativeMethod = window3.RTCPeerConnection.prototype[method];
      const methodObj = { [method]() {
        arguments[0] = new (method === "addIceCandidate" ? window3.RTCIceCandidate : window3.RTCSessionDescription)(arguments[0]);
        return nativeMethod.apply(this, arguments);
      } };
      window3.RTCPeerConnection.prototype[method] = methodObj[method];
    });
  }
  const modernStatsTypes = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  };
  const nativeGetStats = window3.RTCPeerConnection.prototype.getStats;
  window3.RTCPeerConnection.prototype.getStats = function getStats() {
    const [selector, onSucc, onErr] = arguments;
    return nativeGetStats.apply(this, [selector || null]).then((stats) => {
      if (browserDetails.version < 53 && !onSucc) {
        try {
          stats.forEach((stat) => {
            stat.type = modernStatsTypes[stat.type] || stat.type;
          });
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          stats.forEach((stat, i2) => {
            stats.set(i2, Object.assign({}, stat, {
              type: modernStatsTypes[stat.type] || stat.type
            }));
          });
        }
      }
      return stats;
    }).then(onSucc, onErr);
  };
}
function shimSenderGetStats(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection && window3.RTCRtpSender)) {
    return;
  }
  if (window3.RTCRtpSender && "getStats" in window3.RTCRtpSender.prototype) {
    return;
  }
  const origGetSenders = window3.RTCPeerConnection.prototype.getSenders;
  if (origGetSenders) {
    window3.RTCPeerConnection.prototype.getSenders = function getSenders() {
      const senders = origGetSenders.apply(this, []);
      senders.forEach((sender) => sender._pc = this);
      return senders;
    };
  }
  const origAddTrack = window3.RTCPeerConnection.prototype.addTrack;
  if (origAddTrack) {
    window3.RTCPeerConnection.prototype.addTrack = function addTrack() {
      const sender = origAddTrack.apply(this, arguments);
      sender._pc = this;
      return sender;
    };
  }
  window3.RTCRtpSender.prototype.getStats = function getStats() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection && window3.RTCRtpSender)) {
    return;
  }
  if (window3.RTCRtpSender && "getStats" in window3.RTCRtpReceiver.prototype) {
    return;
  }
  const origGetReceivers = window3.RTCPeerConnection.prototype.getReceivers;
  if (origGetReceivers) {
    window3.RTCPeerConnection.prototype.getReceivers = function getReceivers() {
      const receivers = origGetReceivers.apply(this, []);
      receivers.forEach((receiver) => receiver._pc = this);
      return receivers;
    };
  }
  wrapPeerConnectionEvent(window3, "track", (e2) => {
    e2.receiver._pc = e2.srcElement;
    return e2;
  });
  window3.RTCRtpReceiver.prototype.getStats = function getStats() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(window3) {
  if (!window3.RTCPeerConnection || "removeStream" in window3.RTCPeerConnection.prototype) {
    return;
  }
  window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
    deprecated("removeStream", "removeTrack");
    this.getSenders().forEach((sender) => {
      if (sender.track && stream.getTracks().includes(sender.track)) {
        this.removeTrack(sender);
      }
    });
  };
}
function shimRTCDataChannel(window3) {
  if (window3.DataChannel && !window3.RTCDataChannel) {
    window3.RTCDataChannel = window3.DataChannel;
  }
}
function shimAddTransceiver(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection)) {
    return;
  }
  const origAddTransceiver = window3.RTCPeerConnection.prototype.addTransceiver;
  if (origAddTransceiver) {
    window3.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {
      this.setParametersPromises = [];
      let sendEncodings = arguments[1] && arguments[1].sendEncodings;
      if (sendEncodings === void 0) {
        sendEncodings = [];
      }
      sendEncodings = [...sendEncodings];
      const shouldPerformCheck = sendEncodings.length > 0;
      if (shouldPerformCheck) {
        sendEncodings.forEach((encodingParam) => {
          if ("rid" in encodingParam) {
            const ridRegex = /^[a-z0-9]{0,16}$/i;
            if (!ridRegex.test(encodingParam.rid)) {
              throw new TypeError("Invalid RID value provided.");
            }
          }
          if ("scaleResolutionDownBy" in encodingParam) {
            if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1)) {
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            }
          }
          if ("maxFramerate" in encodingParam) {
            if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {
              throw new RangeError("max_framerate must be >= 0.0");
            }
          }
        });
      }
      const transceiver = origAddTransceiver.apply(this, arguments);
      if (shouldPerformCheck) {
        const { sender } = transceiver;
        const params = sender.getParameters();
        if (!("encodings" in params) || // Avoid being fooled by patched getParameters() below.
        params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {
          params.encodings = sendEncodings;
          sender.sendEncodings = sendEncodings;
          this.setParametersPromises.push(
            sender.setParameters(params).then(() => {
              delete sender.sendEncodings;
            }).catch(() => {
              delete sender.sendEncodings;
            })
          );
        }
      }
      return transceiver;
    };
  }
}
function shimGetParameters(window3) {
  if (!(typeof window3 === "object" && window3.RTCRtpSender)) {
    return;
  }
  const origGetParameters = window3.RTCRtpSender.prototype.getParameters;
  if (origGetParameters) {
    window3.RTCRtpSender.prototype.getParameters = function getParameters() {
      const params = origGetParameters.apply(this, arguments);
      if (!("encodings" in params)) {
        params.encodings = [].concat(this.sendEncodings || [{}]);
      }
      return params;
    };
  }
}
function shimCreateOffer(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection)) {
    return;
  }
  const origCreateOffer = window3.RTCPeerConnection.prototype.createOffer;
  window3.RTCPeerConnection.prototype.createOffer = function createOffer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateOffer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimCreateAnswer(window3) {
  if (!(typeof window3 === "object" && window3.RTCPeerConnection)) {
    return;
  }
  const origCreateAnswer = window3.RTCPeerConnection.prototype.createAnswer;
  window3.RTCPeerConnection.prototype.createAnswer = function createAnswer() {
    if (this.setParametersPromises && this.setParametersPromises.length) {
      return Promise.all(this.setParametersPromises).then(() => {
        return origCreateAnswer.apply(this, arguments);
      }).finally(() => {
        this.setParametersPromises = [];
      });
    }
    return origCreateAnswer.apply(this, arguments);
  };
}

// node_modules/webrtc-adapter/src/js/safari/safari_shim.js
var safari_shim_exports = {};
__export(safari_shim_exports, {
  shimAudioContext: () => shimAudioContext,
  shimCallbacksAPI: () => shimCallbacksAPI,
  shimConstraints: () => shimConstraints,
  shimCreateOfferLegacy: () => shimCreateOfferLegacy,
  shimGetUserMedia: () => shimGetUserMedia3,
  shimLocalStreamsAPI: () => shimLocalStreamsAPI,
  shimRTCIceServerUrls: () => shimRTCIceServerUrls,
  shimRemoteStreamsAPI: () => shimRemoteStreamsAPI,
  shimTrackEventTransceiver: () => shimTrackEventTransceiver
});
function shimLocalStreamsAPI(window3) {
  if (typeof window3 !== "object" || !window3.RTCPeerConnection) {
    return;
  }
  if (!("getLocalStreams" in window3.RTCPeerConnection.prototype)) {
    window3.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      return this._localStreams;
    };
  }
  if (!("addStream" in window3.RTCPeerConnection.prototype)) {
    const _addTrack = window3.RTCPeerConnection.prototype.addTrack;
    window3.RTCPeerConnection.prototype.addStream = function addStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      if (!this._localStreams.includes(stream)) {
        this._localStreams.push(stream);
      }
      stream.getAudioTracks().forEach((track) => _addTrack.call(
        this,
        track,
        stream
      ));
      stream.getVideoTracks().forEach((track) => _addTrack.call(
        this,
        track,
        stream
      ));
    };
    window3.RTCPeerConnection.prototype.addTrack = function addTrack(track, ...streams) {
      if (streams) {
        streams.forEach((stream) => {
          if (!this._localStreams) {
            this._localStreams = [stream];
          } else if (!this._localStreams.includes(stream)) {
            this._localStreams.push(stream);
          }
        });
      }
      return _addTrack.apply(this, arguments);
    };
  }
  if (!("removeStream" in window3.RTCPeerConnection.prototype)) {
    window3.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {
      if (!this._localStreams) {
        this._localStreams = [];
      }
      const index = this._localStreams.indexOf(stream);
      if (index === -1) {
        return;
      }
      this._localStreams.splice(index, 1);
      const tracks = stream.getTracks();
      this.getSenders().forEach((sender) => {
        if (tracks.includes(sender.track)) {
          this.removeTrack(sender);
        }
      });
    };
  }
}
function shimRemoteStreamsAPI(window3) {
  if (typeof window3 !== "object" || !window3.RTCPeerConnection) {
    return;
  }
  if (!("getRemoteStreams" in window3.RTCPeerConnection.prototype)) {
    window3.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {
      return this._remoteStreams ? this._remoteStreams : [];
    };
  }
  if (!("onaddstream" in window3.RTCPeerConnection.prototype)) {
    Object.defineProperty(window3.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(f) {
        if (this._onaddstream) {
          this.removeEventListener("addstream", this._onaddstream);
          this.removeEventListener("track", this._onaddstreampoly);
        }
        this.addEventListener("addstream", this._onaddstream = f);
        this.addEventListener("track", this._onaddstreampoly = (e2) => {
          e2.streams.forEach((stream) => {
            if (!this._remoteStreams) {
              this._remoteStreams = [];
            }
            if (this._remoteStreams.includes(stream)) {
              return;
            }
            this._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            this.dispatchEvent(event);
          });
        });
      }
    });
    const origSetRemoteDescription = window3.RTCPeerConnection.prototype.setRemoteDescription;
    window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
      const pc2 = this;
      if (!this._onaddstreampoly) {
        this.addEventListener("track", this._onaddstreampoly = function(e2) {
          e2.streams.forEach((stream) => {
            if (!pc2._remoteStreams) {
              pc2._remoteStreams = [];
            }
            if (pc2._remoteStreams.indexOf(stream) >= 0) {
              return;
            }
            pc2._remoteStreams.push(stream);
            const event = new Event("addstream");
            event.stream = stream;
            pc2.dispatchEvent(event);
          });
        });
      }
      return origSetRemoteDescription.apply(pc2, arguments);
    };
  }
}
function shimCallbacksAPI(window3) {
  if (typeof window3 !== "object" || !window3.RTCPeerConnection) {
    return;
  }
  const prototype = window3.RTCPeerConnection.prototype;
  const origCreateOffer = prototype.createOffer;
  const origCreateAnswer = prototype.createAnswer;
  const setLocalDescription = prototype.setLocalDescription;
  const setRemoteDescription = prototype.setRemoteDescription;
  const addIceCandidate = prototype.addIceCandidate;
  prototype.createOffer = function createOffer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateOffer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.createAnswer = function createAnswer(successCallback, failureCallback) {
    const options = arguments.length >= 2 ? arguments[2] : arguments[0];
    const promise = origCreateAnswer.apply(this, [options]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  let withCallback = function(description, successCallback, failureCallback) {
    const promise = setLocalDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setLocalDescription = withCallback;
  withCallback = function(description, successCallback, failureCallback) {
    const promise = setRemoteDescription.apply(this, [description]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.setRemoteDescription = withCallback;
  withCallback = function(candidate, successCallback, failureCallback) {
    const promise = addIceCandidate.apply(this, [candidate]);
    if (!failureCallback) {
      return promise;
    }
    promise.then(successCallback, failureCallback);
    return Promise.resolve();
  };
  prototype.addIceCandidate = withCallback;
}
function shimGetUserMedia3(window3) {
  const navigator2 = window3 && window3.navigator;
  if (navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    const mediaDevices = navigator2.mediaDevices;
    const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);
    navigator2.mediaDevices.getUserMedia = (constraints) => {
      return _getUserMedia(shimConstraints(constraints));
    };
  }
  if (!navigator2.getUserMedia && navigator2.mediaDevices && navigator2.mediaDevices.getUserMedia) {
    navigator2.getUserMedia = (function getUserMedia(constraints, cb, errcb) {
      navigator2.mediaDevices.getUserMedia(constraints).then(cb, errcb);
    }).bind(navigator2);
  }
}
function shimConstraints(constraints) {
  if (constraints && constraints.video !== void 0) {
    return Object.assign(
      {},
      constraints,
      { video: compactObject(constraints.video) }
    );
  }
  return constraints;
}
function shimRTCIceServerUrls(window3) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  const OrigPeerConnection = window3.RTCPeerConnection;
  window3.RTCPeerConnection = function RTCPeerConnection2(pcConfig, pcConstraints) {
    if (pcConfig && pcConfig.iceServers) {
      const newIceServers = [];
      for (let i2 = 0; i2 < pcConfig.iceServers.length; i2++) {
        let server = pcConfig.iceServers[i2];
        if (server.urls === void 0 && server.url) {
          deprecated("RTCIceServer.url", "RTCIceServer.urls");
          server = JSON.parse(JSON.stringify(server));
          server.urls = server.url;
          delete server.url;
          newIceServers.push(server);
        } else {
          newIceServers.push(pcConfig.iceServers[i2]);
        }
      }
      pcConfig.iceServers = newIceServers;
    }
    return new OrigPeerConnection(pcConfig, pcConstraints);
  };
  window3.RTCPeerConnection.prototype = OrigPeerConnection.prototype;
  if ("generateCertificate" in OrigPeerConnection) {
    Object.defineProperty(window3.RTCPeerConnection, "generateCertificate", {
      get() {
        return OrigPeerConnection.generateCertificate;
      }
    });
  }
}
function shimTrackEventTransceiver(window3) {
  if (typeof window3 === "object" && window3.RTCTrackEvent && "receiver" in window3.RTCTrackEvent.prototype && !("transceiver" in window3.RTCTrackEvent.prototype)) {
    Object.defineProperty(window3.RTCTrackEvent.prototype, "transceiver", {
      get() {
        return { receiver: this.receiver };
      }
    });
  }
}
function shimCreateOfferLegacy(window3) {
  const origCreateOffer = window3.RTCPeerConnection.prototype.createOffer;
  window3.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {
    if (offerOptions) {
      if (typeof offerOptions.offerToReceiveAudio !== "undefined") {
        offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;
      }
      const audioTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "audio");
      if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {
        if (audioTransceiver.direction === "sendrecv") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("sendonly");
          } else {
            audioTransceiver.direction = "sendonly";
          }
        } else if (audioTransceiver.direction === "recvonly") {
          if (audioTransceiver.setDirection) {
            audioTransceiver.setDirection("inactive");
          } else {
            audioTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {
        this.addTransceiver("audio", { direction: "recvonly" });
      }
      if (typeof offerOptions.offerToReceiveVideo !== "undefined") {
        offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;
      }
      const videoTransceiver = this.getTransceivers().find((transceiver) => transceiver.receiver.track.kind === "video");
      if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {
        if (videoTransceiver.direction === "sendrecv") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("sendonly");
          } else {
            videoTransceiver.direction = "sendonly";
          }
        } else if (videoTransceiver.direction === "recvonly") {
          if (videoTransceiver.setDirection) {
            videoTransceiver.setDirection("inactive");
          } else {
            videoTransceiver.direction = "inactive";
          }
        }
      } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {
        this.addTransceiver("video", { direction: "recvonly" });
      }
    }
    return origCreateOffer.apply(this, arguments);
  };
}
function shimAudioContext(window3) {
  if (typeof window3 !== "object" || window3.AudioContext) {
    return;
  }
  window3.AudioContext = window3.webkitAudioContext;
}

// node_modules/webrtc-adapter/src/js/common_shim.js
var common_shim_exports = {};
__export(common_shim_exports, {
  removeExtmapAllowMixed: () => removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty: () => shimAddIceCandidateNullOrEmpty,
  shimConnectionState: () => shimConnectionState,
  shimMaxMessageSize: () => shimMaxMessageSize,
  shimParameterlessSetLocalDescription: () => shimParameterlessSetLocalDescription,
  shimRTCIceCandidate: () => shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol: () => shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError: () => shimSendThrowTypeError
});
var import_sdp = __toESM(require_sdp());
function shimRTCIceCandidate(window3) {
  if (!window3.RTCIceCandidate || window3.RTCIceCandidate && "foundation" in window3.RTCIceCandidate.prototype) {
    return;
  }
  const NativeRTCIceCandidate = window3.RTCIceCandidate;
  window3.RTCIceCandidate = function RTCIceCandidate(args) {
    if (typeof args === "object" && args.candidate && args.candidate.indexOf("a=") === 0) {
      args = JSON.parse(JSON.stringify(args));
      args.candidate = args.candidate.substring(2);
    }
    if (args.candidate && args.candidate.length) {
      const nativeCandidate = new NativeRTCIceCandidate(args);
      const parsedCandidate = import_sdp.default.parseCandidate(args.candidate);
      for (const key in parsedCandidate) {
        if (!(key in nativeCandidate)) {
          Object.defineProperty(
            nativeCandidate,
            key,
            { value: parsedCandidate[key] }
          );
        }
      }
      nativeCandidate.toJSON = function toJSON() {
        return {
          candidate: nativeCandidate.candidate,
          sdpMid: nativeCandidate.sdpMid,
          sdpMLineIndex: nativeCandidate.sdpMLineIndex,
          usernameFragment: nativeCandidate.usernameFragment
        };
      };
      return nativeCandidate;
    }
    return new NativeRTCIceCandidate(args);
  };
  window3.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;
  wrapPeerConnectionEvent(window3, "icecandidate", (e2) => {
    if (e2.candidate) {
      Object.defineProperty(e2, "candidate", {
        value: new window3.RTCIceCandidate(e2.candidate),
        writable: "false"
      });
    }
    return e2;
  });
}
function shimRTCIceCandidateRelayProtocol(window3) {
  if (!window3.RTCIceCandidate || window3.RTCIceCandidate && "relayProtocol" in window3.RTCIceCandidate.prototype) {
    return;
  }
  wrapPeerConnectionEvent(window3, "icecandidate", (e2) => {
    if (e2.candidate) {
      const parsedCandidate = import_sdp.default.parseCandidate(e2.candidate.candidate);
      if (parsedCandidate.type === "relay") {
        e2.candidate.relayProtocol = {
          0: "tls",
          1: "tcp",
          2: "udp"
        }[parsedCandidate.priority >> 24];
      }
    }
    return e2;
  });
}
function shimMaxMessageSize(window3, browserDetails) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (!("sctp" in window3.RTCPeerConnection.prototype)) {
    Object.defineProperty(window3.RTCPeerConnection.prototype, "sctp", {
      get() {
        return typeof this._sctp === "undefined" ? null : this._sctp;
      }
    });
  }
  const sctpInDescription = function(description) {
    if (!description || !description.sdp) {
      return false;
    }
    const sections = import_sdp.default.splitSections(description.sdp);
    sections.shift();
    return sections.some((mediaSection) => {
      const mLine = import_sdp.default.parseMLine(mediaSection);
      return mLine && mLine.kind === "application" && mLine.protocol.indexOf("SCTP") !== -1;
    });
  };
  const getRemoteFirefoxVersion = function(description) {
    const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (match === null || match.length < 2) {
      return -1;
    }
    const version3 = parseInt(match[1], 10);
    return version3 !== version3 ? -1 : version3;
  };
  const getCanSendMaxMessageSize = function(remoteIsFirefox) {
    let canSendMaxMessageSize = 65536;
    if (browserDetails.browser === "firefox") {
      if (browserDetails.version < 57) {
        if (remoteIsFirefox === -1) {
          canSendMaxMessageSize = 16384;
        } else {
          canSendMaxMessageSize = 2147483637;
        }
      } else if (browserDetails.version < 60) {
        canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;
      } else {
        canSendMaxMessageSize = 2147483637;
      }
    }
    return canSendMaxMessageSize;
  };
  const getMaxMessageSize = function(description, remoteIsFirefox) {
    let maxMessageSize = 65536;
    if (browserDetails.browser === "firefox" && browserDetails.version === 57) {
      maxMessageSize = 65535;
    }
    const match = import_sdp.default.matchPrefix(
      description.sdp,
      "a=max-message-size:"
    );
    if (match.length > 0) {
      maxMessageSize = parseInt(match[0].substring(19), 10);
    } else if (browserDetails.browser === "firefox" && remoteIsFirefox !== -1) {
      maxMessageSize = 2147483637;
    }
    return maxMessageSize;
  };
  const origSetRemoteDescription = window3.RTCPeerConnection.prototype.setRemoteDescription;
  window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {
    this._sctp = null;
    if (browserDetails.browser === "chrome" && browserDetails.version >= 76) {
      const { sdpSemantics } = this.getConfiguration();
      if (sdpSemantics === "plan-b") {
        Object.defineProperty(this, "sctp", {
          get() {
            return typeof this._sctp === "undefined" ? null : this._sctp;
          },
          enumerable: true,
          configurable: true
        });
      }
    }
    if (sctpInDescription(arguments[0])) {
      const isFirefox2 = getRemoteFirefoxVersion(arguments[0]);
      const canSendMMS = getCanSendMaxMessageSize(isFirefox2);
      const remoteMMS = getMaxMessageSize(arguments[0], isFirefox2);
      let maxMessageSize;
      if (canSendMMS === 0 && remoteMMS === 0) {
        maxMessageSize = Number.POSITIVE_INFINITY;
      } else if (canSendMMS === 0 || remoteMMS === 0) {
        maxMessageSize = Math.max(canSendMMS, remoteMMS);
      } else {
        maxMessageSize = Math.min(canSendMMS, remoteMMS);
      }
      const sctp = {};
      Object.defineProperty(sctp, "maxMessageSize", {
        get() {
          return maxMessageSize;
        }
      });
      this._sctp = sctp;
    }
    return origSetRemoteDescription.apply(this, arguments);
  };
}
function shimSendThrowTypeError(window3) {
  if (!(window3.RTCPeerConnection && "createDataChannel" in window3.RTCPeerConnection.prototype)) {
    return;
  }
  function wrapDcSend(dc2, pc2) {
    const origDataChannelSend = dc2.send;
    dc2.send = function send() {
      const data = arguments[0];
      const length = data.length || data.size || data.byteLength;
      if (dc2.readyState === "open" && pc2.sctp && length > pc2.sctp.maxMessageSize) {
        throw new TypeError("Message too large (can send a maximum of " + pc2.sctp.maxMessageSize + " bytes)");
      }
      return origDataChannelSend.apply(dc2, arguments);
    };
  }
  const origCreateDataChannel = window3.RTCPeerConnection.prototype.createDataChannel;
  window3.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {
    const dataChannel = origCreateDataChannel.apply(this, arguments);
    wrapDcSend(dataChannel, this);
    return dataChannel;
  };
  wrapPeerConnectionEvent(window3, "datachannel", (e2) => {
    wrapDcSend(e2.channel, e2.target);
    return e2;
  });
}
function shimConnectionState(window3) {
  if (!window3.RTCPeerConnection || "connectionState" in window3.RTCPeerConnection.prototype) {
    return;
  }
  const proto = window3.RTCPeerConnection.prototype;
  Object.defineProperty(proto, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(proto, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(cb) {
      if (this._onconnectionstatechange) {
        this.removeEventListener(
          "connectionstatechange",
          this._onconnectionstatechange
        );
        delete this._onconnectionstatechange;
      }
      if (cb) {
        this.addEventListener(
          "connectionstatechange",
          this._onconnectionstatechange = cb
        );
      }
    },
    enumerable: true,
    configurable: true
  });
  ["setLocalDescription", "setRemoteDescription"].forEach((method) => {
    const origMethod = proto[method];
    proto[method] = function() {
      if (!this._connectionstatechangepoly) {
        this._connectionstatechangepoly = (e2) => {
          const pc2 = e2.target;
          if (pc2._lastConnectionState !== pc2.connectionState) {
            pc2._lastConnectionState = pc2.connectionState;
            const newEvent = new Event("connectionstatechange", e2);
            pc2.dispatchEvent(newEvent);
          }
          return e2;
        };
        this.addEventListener(
          "iceconnectionstatechange",
          this._connectionstatechangepoly
        );
      }
      return origMethod.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(window3, browserDetails) {
  if (!window3.RTCPeerConnection) {
    return;
  }
  if (browserDetails.browser === "chrome" && browserDetails.version >= 71) {
    return;
  }
  if (browserDetails.browser === "safari" && browserDetails._safariVersion >= 13.1) {
    return;
  }
  const nativeSRD = window3.RTCPeerConnection.prototype.setRemoteDescription;
  window3.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {
    if (desc && desc.sdp && desc.sdp.indexOf("\na=extmap-allow-mixed") !== -1) {
      const sdp2 = desc.sdp.split("\n").filter((line) => {
        return line.trim() !== "a=extmap-allow-mixed";
      }).join("\n");
      if (window3.RTCSessionDescription && desc instanceof window3.RTCSessionDescription) {
        arguments[0] = new window3.RTCSessionDescription({
          type: desc.type,
          sdp: sdp2
        });
      } else {
        desc.sdp = sdp2;
      }
    }
    return nativeSRD.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(window3, browserDetails) {
  if (!(window3.RTCPeerConnection && window3.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeAddIceCandidate = window3.RTCPeerConnection.prototype.addIceCandidate;
  if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {
    return;
  }
  window3.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {
    if (!arguments[0]) {
      if (arguments[1]) {
        arguments[1].apply(null);
      }
      return Promise.resolve();
    }
    if ((browserDetails.browser === "chrome" && browserDetails.version < 78 || browserDetails.browser === "firefox" && browserDetails.version < 68 || browserDetails.browser === "safari") && arguments[0] && arguments[0].candidate === "") {
      return Promise.resolve();
    }
    return nativeAddIceCandidate.apply(this, arguments);
  };
}
function shimParameterlessSetLocalDescription(window3, browserDetails) {
  if (!(window3.RTCPeerConnection && window3.RTCPeerConnection.prototype)) {
    return;
  }
  const nativeSetLocalDescription = window3.RTCPeerConnection.prototype.setLocalDescription;
  if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {
    return;
  }
  window3.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {
    let desc = arguments[0] || {};
    if (typeof desc !== "object" || desc.type && desc.sdp) {
      return nativeSetLocalDescription.apply(this, arguments);
    }
    desc = { type: desc.type, sdp: desc.sdp };
    if (!desc.type) {
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          desc.type = "offer";
          break;
        default:
          desc.type = "answer";
          break;
      }
    }
    if (desc.sdp || desc.type !== "offer" && desc.type !== "answer") {
      return nativeSetLocalDescription.apply(this, [desc]);
    }
    const func = desc.type === "offer" ? this.createOffer : this.createAnswer;
    return func.apply(this).then((d) => nativeSetLocalDescription.apply(this, [d]));
  };
}

// node_modules/webrtc-adapter/src/js/adapter_factory.js
var sdp = __toESM(require_sdp());
function adapterFactory({ window: window3 } = {}, options = {
  shimChrome: true,
  shimFirefox: true,
  shimSafari: true
}) {
  const logging2 = log;
  const browserDetails = detectBrowser(window3);
  const adapter2 = {
    browserDetails,
    commonShim: common_shim_exports,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (browserDetails.browser) {
    case "chrome":
      if (!chrome_shim_exports || !shimPeerConnection || !options.shimChrome) {
        logging2("Chrome shim is not included in this adapter release.");
        return adapter2;
      }
      if (browserDetails.version === null) {
        logging2("Chrome shim can not determine version, not shimming.");
        return adapter2;
      }
      logging2("adapter.js shimming chrome.");
      adapter2.browserShim = chrome_shim_exports;
      shimAddIceCandidateNullOrEmpty(window3, browserDetails);
      shimParameterlessSetLocalDescription(window3, browserDetails);
      shimGetUserMedia(window3, browserDetails);
      shimMediaStream(window3, browserDetails);
      shimPeerConnection(window3, browserDetails);
      shimOnTrack(window3, browserDetails);
      shimAddTrackRemoveTrack(window3, browserDetails);
      shimGetSendersWithDtmf(window3, browserDetails);
      shimGetStats(window3, browserDetails);
      shimSenderReceiverGetStats(window3, browserDetails);
      fixNegotiationNeeded(window3, browserDetails);
      shimRTCIceCandidate(window3, browserDetails);
      shimRTCIceCandidateRelayProtocol(window3, browserDetails);
      shimConnectionState(window3, browserDetails);
      shimMaxMessageSize(window3, browserDetails);
      shimSendThrowTypeError(window3, browserDetails);
      removeExtmapAllowMixed(window3, browserDetails);
      break;
    case "firefox":
      if (!firefox_shim_exports || !shimPeerConnection2 || !options.shimFirefox) {
        logging2("Firefox shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming firefox.");
      adapter2.browserShim = firefox_shim_exports;
      shimAddIceCandidateNullOrEmpty(window3, browserDetails);
      shimParameterlessSetLocalDescription(window3, browserDetails);
      shimGetUserMedia2(window3, browserDetails);
      shimPeerConnection2(window3, browserDetails);
      shimOnTrack2(window3, browserDetails);
      shimRemoveStream(window3, browserDetails);
      shimSenderGetStats(window3, browserDetails);
      shimReceiverGetStats(window3, browserDetails);
      shimRTCDataChannel(window3, browserDetails);
      shimAddTransceiver(window3, browserDetails);
      shimGetParameters(window3, browserDetails);
      shimCreateOffer(window3, browserDetails);
      shimCreateAnswer(window3, browserDetails);
      shimRTCIceCandidate(window3, browserDetails);
      shimConnectionState(window3, browserDetails);
      shimMaxMessageSize(window3, browserDetails);
      shimSendThrowTypeError(window3, browserDetails);
      break;
    case "safari":
      if (!safari_shim_exports || !options.shimSafari) {
        logging2("Safari shim is not included in this adapter release.");
        return adapter2;
      }
      logging2("adapter.js shimming safari.");
      adapter2.browserShim = safari_shim_exports;
      shimAddIceCandidateNullOrEmpty(window3, browserDetails);
      shimParameterlessSetLocalDescription(window3, browserDetails);
      shimRTCIceServerUrls(window3, browserDetails);
      shimCreateOfferLegacy(window3, browserDetails);
      shimCallbacksAPI(window3, browserDetails);
      shimLocalStreamsAPI(window3, browserDetails);
      shimRemoteStreamsAPI(window3, browserDetails);
      shimTrackEventTransceiver(window3, browserDetails);
      shimGetUserMedia3(window3, browserDetails);
      shimAudioContext(window3, browserDetails);
      shimRTCIceCandidate(window3, browserDetails);
      shimRTCIceCandidateRelayProtocol(window3, browserDetails);
      shimMaxMessageSize(window3, browserDetails);
      shimSendThrowTypeError(window3, browserDetails);
      removeExtmapAllowMixed(window3, browserDetails);
      break;
    default:
      logging2("Unsupported browser!");
      break;
  }
  return adapter2;
}

// node_modules/webrtc-adapter/src/js/adapter_core.js
var adapter = adapterFactory({ window: typeof window === "undefined" ? void 0 : window });

// node_modules/@protobuf-ts/runtime/build/es2015/json-typings.js
function typeofJsonValue(value) {
  let t2 = typeof value;
  if (t2 == "object") {
    if (Array.isArray(value))
      return "array";
    if (value === null)
      return "null";
  }
  return t2;
}
function isJsonObject(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}

// node_modules/@protobuf-ts/runtime/build/es2015/base64.js
var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
var decTable = [];
for (let i2 = 0; i2 < encTable.length; i2++)
  decTable[encTable[i2].charCodeAt(0)] = i2;
decTable["-".charCodeAt(0)] = encTable.indexOf("+");
decTable["_".charCodeAt(0)] = encTable.indexOf("/");
function base64decode(base64Str) {
  let es2 = base64Str.length * 3 / 4;
  if (base64Str[base64Str.length - 2] == "=")
    es2 -= 2;
  else if (base64Str[base64Str.length - 1] == "=")
    es2 -= 1;
  let bytes = new Uint8Array(es2), bytePos = 0, groupPos = 0, b2, p2 = 0;
  for (let i2 = 0; i2 < base64Str.length; i2++) {
    b2 = decTable[base64Str.charCodeAt(i2)];
    if (b2 === void 0) {
      switch (base64Str[i2]) {
        case "=":
          groupPos = 0;
        // reset state when padding found
        case "\n":
        case "\r":
        case "	":
        case " ":
          continue;
        // skip white-space, and padding
        default:
          throw Error(`invalid base64 string.`);
      }
    }
    switch (groupPos) {
      case 0:
        p2 = b2;
        groupPos = 1;
        break;
      case 1:
        bytes[bytePos++] = p2 << 2 | (b2 & 48) >> 4;
        p2 = b2;
        groupPos = 2;
        break;
      case 2:
        bytes[bytePos++] = (p2 & 15) << 4 | (b2 & 60) >> 2;
        p2 = b2;
        groupPos = 3;
        break;
      case 3:
        bytes[bytePos++] = (p2 & 3) << 6 | b2;
        groupPos = 0;
        break;
    }
  }
  if (groupPos == 1)
    throw Error(`invalid base64 string.`);
  return bytes.subarray(0, bytePos);
}
function base64encode(bytes) {
  let base64 = "", groupPos = 0, b2, p2 = 0;
  for (let i2 = 0; i2 < bytes.length; i2++) {
    b2 = bytes[i2];
    switch (groupPos) {
      case 0:
        base64 += encTable[b2 >> 2];
        p2 = (b2 & 3) << 4;
        groupPos = 1;
        break;
      case 1:
        base64 += encTable[p2 | b2 >> 4];
        p2 = (b2 & 15) << 2;
        groupPos = 2;
        break;
      case 2:
        base64 += encTable[p2 | b2 >> 6];
        base64 += encTable[b2 & 63];
        groupPos = 0;
        break;
    }
  }
  if (groupPos) {
    base64 += encTable[p2];
    base64 += "=";
    if (groupPos == 1)
      base64 += "=";
  }
  return base64;
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-format-contract.js
var UnknownFieldHandler;
(function(UnknownFieldHandler2) {
  UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown");
  UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
    let container = is2(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = [];
    container.push({ no: fieldNo, wireType, data });
  };
  UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
    for (let { no: no2, wireType, data } of UnknownFieldHandler2.list(message))
      writer.tag(no2, wireType).raw(data);
  };
  UnknownFieldHandler2.list = (message, fieldNo) => {
    if (is2(message)) {
      let all = message[UnknownFieldHandler2.symbol];
      return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
    }
    return [];
  };
  UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
  const is2 = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
})(UnknownFieldHandler || (UnknownFieldHandler = {}));
function mergeBinaryOptions(a2, b2) {
  return Object.assign(Object.assign({}, a2), b2);
}
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));

// node_modules/@protobuf-ts/runtime/build/es2015/goog-varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift2 = 0; shift2 < 28; shift2 += 7) {
    let b2 = this.buf[this.pos++];
    lowBits |= (b2 & 127) << shift2;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift2 = 3; shift2 <= 31; shift2 += 7) {
    let b2 = this.buf[this.pos++];
    highBits |= (b2 & 127) << shift2;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo2, hi2, bytes) {
  for (let i2 = 0; i2 < 28; i2 = i2 + 7) {
    const shift2 = lo2 >>> i2;
    const hasNext = !(shift2 >>> 7 == 0 && hi2 == 0);
    const byte = (hasNext ? shift2 | 128 : shift2) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo2 >>> 28 & 15 | (hi2 & 7) << 4;
  const hasMoreBits = !(hi2 >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i2 = 3; i2 < 31; i2 = i2 + 7) {
    const shift2 = hi2 >>> i2;
    const hasNext = !(shift2 >>> 7 == 0);
    const byte = (hasNext ? shift2 | 128 : shift2) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi2 >>> 31 & 1);
}
var TWO_PWR_32_DBL = (1 << 16) * (1 << 16);
function int64fromString(dec) {
  let minus = dec[0] == "-";
  if (minus)
    dec = dec.slice(1);
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return [minus, lowBits, highBits];
}
function int64toString(bitsLow, bitsHigh) {
  if (bitsHigh >>> 0 <= 2097151) {
    return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
  }
  let low = bitsLow & 16777215;
  let mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215;
  let high = bitsHigh >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  let base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  function decimalFrom1e7(digit1e7, needLeadingZeros) {
    let partial = digit1e7 ? String(digit1e7) : "";
    if (needLeadingZeros) {
      return "0000000".slice(partial.length) + partial;
    }
    return partial;
  }
  return decimalFrom1e7(
    digitC,
    /*needLeadingZeros=*/
    0
  ) + decimalFrom1e7(
    digitB,
    /*needLeadingZeros=*/
    digitC
  ) + // If the final 1e7 digit didn't need leading zeros, we would have
  // returned via the trivial code path at the top.
  decimalFrom1e7(
    digitA,
    /*needLeadingZeros=*/
    1
  );
}
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i2 = 0; i2 < 9; i2++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b2 = this.buf[this.pos++];
  let result = b2 & 127;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 7;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 14;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 21;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 15) << 28;
  for (let readBytes = 5; (b2 & 128) !== 0 && readBytes < 10; readBytes++)
    b2 = this.buf[this.pos++];
  if ((b2 & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@protobuf-ts/runtime/build/es2015/pb-long.js
var BI;
function detectBi() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function";
  BI = ok ? {
    MIN: BigInt("-9223372036854775808"),
    MAX: BigInt("9223372036854775807"),
    UMIN: BigInt("0"),
    UMAX: BigInt("18446744073709551615"),
    C: BigInt,
    V: dv
  } : void 0;
}
detectBi();
function assertBi(bi2) {
  if (!bi2)
    throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
}
var RE_DECIMAL_STR = /^-?[0-9]+$/;
var TWO_PWR_32_DBL2 = 4294967296;
var HALF_2_PWR_32 = 2147483648;
var SharedPbLong = class {
  /**
   * Create a new instance with the given bits.
   */
  constructor(lo2, hi2) {
    this.lo = lo2 | 0;
    this.hi = hi2 | 0;
  }
  /**
   * Is this instance equal to 0?
   */
  isZero() {
    return this.lo == 0 && this.hi == 0;
  }
  /**
   * Convert to a native number.
   */
  toNumber() {
    let result = this.hi * TWO_PWR_32_DBL2 + (this.lo >>> 0);
    if (!Number.isSafeInteger(result))
      throw new Error("cannot convert to safe number");
    return result;
  }
};
var PbULong = class _PbULong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.UMIN)
            throw new Error("signed value for ulong");
          if (value > BI.UMAX)
            throw new Error("ulong too large");
          BI.V.setBigUint64(0, value, true);
          return new _PbULong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo2, hi2] = int64fromString(value);
          if (minus)
            throw new Error("signed value for ulong");
          return new _PbULong(lo2, hi2);
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          if (value < 0)
            throw new Error("signed value for ulong");
          return new _PbULong(value, value / TWO_PWR_32_DBL2);
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    return BI ? this.toBigInt().toString() : int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigUint64(0, true);
  }
};
PbULong.ZERO = new PbULong(0, 0);
var PbLong = class _PbLong extends SharedPbLong {
  /**
   * Create instance from a `string`, `number` or `bigint`.
   */
  static from(value) {
    if (BI)
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          if (value == "")
            throw new Error("string is no integer");
          value = BI.C(value);
        case "number":
          if (value === 0)
            return this.ZERO;
          value = BI.C(value);
        case "bigint":
          if (!value)
            return this.ZERO;
          if (value < BI.MIN)
            throw new Error("signed long too small");
          if (value > BI.MAX)
            throw new Error("signed long too large");
          BI.V.setBigInt64(0, value, true);
          return new _PbLong(BI.V.getInt32(0, true), BI.V.getInt32(4, true));
      }
    else
      switch (typeof value) {
        case "string":
          if (value == "0")
            return this.ZERO;
          value = value.trim();
          if (!RE_DECIMAL_STR.test(value))
            throw new Error("string is no integer");
          let [minus, lo2, hi2] = int64fromString(value);
          if (minus) {
            if (hi2 > HALF_2_PWR_32 || hi2 == HALF_2_PWR_32 && lo2 != 0)
              throw new Error("signed long too small");
          } else if (hi2 >= HALF_2_PWR_32)
            throw new Error("signed long too large");
          let pbl = new _PbLong(lo2, hi2);
          return minus ? pbl.negate() : pbl;
        case "number":
          if (value == 0)
            return this.ZERO;
          if (!Number.isSafeInteger(value))
            throw new Error("number is no integer");
          return value > 0 ? new _PbLong(value, value / TWO_PWR_32_DBL2) : new _PbLong(-value, -value / TWO_PWR_32_DBL2).negate();
      }
    throw new Error("unknown value " + typeof value);
  }
  /**
   * Do we have a minus sign?
   */
  isNegative() {
    return (this.hi & HALF_2_PWR_32) !== 0;
  }
  /**
   * Negate two's complement.
   * Invert all the bits and add one to the result.
   */
  negate() {
    let hi2 = ~this.hi, lo2 = this.lo;
    if (lo2)
      lo2 = ~lo2 + 1;
    else
      hi2 += 1;
    return new _PbLong(lo2, hi2);
  }
  /**
   * Convert to decimal string.
   */
  toString() {
    if (BI)
      return this.toBigInt().toString();
    if (this.isNegative()) {
      let n2 = this.negate();
      return "-" + int64toString(n2.lo, n2.hi);
    }
    return int64toString(this.lo, this.hi);
  }
  /**
   * Convert to native bigint.
   */
  toBigInt() {
    assertBi(BI);
    BI.V.setInt32(0, this.lo, true);
    BI.V.setInt32(4, this.hi, true);
    return BI.V.getBigInt64(0, true);
  }
};
PbLong.ZERO = new PbLong(0, 0);

// node_modules/@protobuf-ts/runtime/build/es2015/binary-reader.js
var defaultsRead = {
  readUnknownField: true,
  readerFactory: (bytes) => new BinaryReader(bytes)
};
function binaryReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
}
var BinaryReader = class {
  constructor(buf, textDecoder) {
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
    this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
      fatal: true,
      ignoreBOM: true
    });
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(wireType) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        let t2;
        while ((t2 = this.tag()[1]) !== WireType.EndGroup) {
          this.skip(t2);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return new PbLong(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return new PbULong(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo2, hi2] = this.varint64();
    let s2 = -(lo2 & 1);
    lo2 = (lo2 >>> 1 | (hi2 & 1) << 31) ^ s2;
    hi2 = hi2 >>> 1 ^ s2;
    return new PbLong(lo2, hi2);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo2, hi2] = this.varint64();
    return lo2 !== 0 || hi2 !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return new PbULong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return new PbLong(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32();
    let start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/assert.js
function assert(condition, msg) {
  if (!condition) {
    throw new Error(msg);
  }
}
function assertNever(value, msg) {
  throw new Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value);
}
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
function assertInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid int 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int 32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid uint 32: " + typeof arg);
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint 32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg !== "number")
    throw new Error("invalid float 32: " + typeof arg);
  if (!Number.isFinite(arg))
    return;
  if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
    throw new Error("invalid float 32: " + arg);
}

// node_modules/@protobuf-ts/runtime/build/es2015/binary-writer.js
var defaultsWrite = {
  writeUnknownFields: true,
  writerFactory: () => new BinaryWriter()
};
function binaryWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
}
var BinaryWriter = class {
  constructor(textEncoder) {
    this.stack = [];
    this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let len = 0;
    for (let i2 = 0; i2 < this.chunks.length; i2++)
      len += this.chunks[i2].length;
    let bytes = new Uint8Array(len);
    let offset2 = 0;
    for (let i2 = 0; i2 < this.chunks.length; i2++) {
      bytes.set(this.chunks[i2], offset2);
      offset2 += this.chunks[i2].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk2 = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk2.byteLength);
    return this.raw(chunk2);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk2) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk2);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk2 = this.textEncoder.encode(value);
    this.uint32(chunk2.byteLength);
    return this.raw(chunk2);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk2 = new Uint8Array(4);
    new DataView(chunk2.buffer).setFloat32(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk2 = new Uint8Array(8);
    new DataView(chunk2.buffer).setFloat64(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk2 = new Uint8Array(4);
    new DataView(chunk2.buffer).setUint32(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk2 = new Uint8Array(4);
    new DataView(chunk2.buffer).setInt32(0, value, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk2 = new Uint8Array(8);
    let view = new DataView(chunk2.buffer);
    let long = PbLong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk2 = new Uint8Array(8);
    let view = new DataView(chunk2.buffer);
    let long = PbULong.from(value);
    view.setInt32(0, long.lo, true);
    view.setInt32(4, long.hi, true);
    return this.raw(chunk2);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let long = PbLong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let long = PbLong.from(value), sign = long.hi >> 31, lo2 = long.lo << 1 ^ sign, hi2 = (long.hi << 1 | long.lo >>> 31) ^ sign;
    varint64write(lo2, hi2, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let long = PbULong.from(value);
    varint64write(long.lo, long.hi, this.buf);
    return this;
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/json-format-contract.js
var defaultsWrite2 = {
  emitDefaultValues: false,
  enumAsInteger: false,
  useProtoFieldName: false,
  prettySpaces: 0
};
var defaultsRead2 = {
  ignoreUnknownFields: false
};
function jsonReadOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsRead2), options) : defaultsRead2;
}
function jsonWriteOptions(options) {
  return options ? Object.assign(Object.assign({}, defaultsWrite2), options) : defaultsWrite2;
}
function mergeJsonOptions(a2, b2) {
  var _a2, _b;
  let c2 = Object.assign(Object.assign({}, a2), b2);
  c2.typeRegistry = [...(_a2 = a2 === null || a2 === void 0 ? void 0 : a2.typeRegistry) !== null && _a2 !== void 0 ? _a2 : [], ...(_b = b2 === null || b2 === void 0 ? void 0 : b2.typeRegistry) !== null && _b !== void 0 ? _b : []];
  return c2;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type-contract.js
var MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");

// node_modules/@protobuf-ts/runtime/build/es2015/lower-camel-case.js
function lowerCamelCase(snakeCase) {
  let capNext = false;
  const sb = [];
  for (let i2 = 0; i2 < snakeCase.length; i2++) {
    let next = snakeCase.charAt(i2);
    if (next == "_") {
      capNext = true;
    } else if (/\d/.test(next)) {
      sb.push(next);
      capNext = true;
    } else if (capNext) {
      sb.push(next.toUpperCase());
      capNext = false;
    } else if (i2 == 0) {
      sb.push(next.toLowerCase());
    } else {
      sb.push(next);
    }
  }
  return sb.join("");
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-info.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(LongType2) {
  LongType2[LongType2["BIGINT"] = 0] = "BIGINT";
  LongType2[LongType2["STRING"] = 1] = "STRING";
  LongType2[LongType2["NUMBER"] = 2] = "NUMBER";
})(LongType || (LongType = {}));
var RepeatType;
(function(RepeatType2) {
  RepeatType2[RepeatType2["NO"] = 0] = "NO";
  RepeatType2[RepeatType2["PACKED"] = 1] = "PACKED";
  RepeatType2[RepeatType2["UNPACKED"] = 2] = "UNPACKED";
})(RepeatType || (RepeatType = {}));
function normalizeFieldInfo(field) {
  var _a2, _b, _c2, _d;
  field.localName = (_a2 = field.localName) !== null && _a2 !== void 0 ? _a2 : lowerCamelCase(field.name);
  field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lowerCamelCase(field.name);
  field.repeat = (_c2 = field.repeat) !== null && _c2 !== void 0 ? _c2 : RepeatType.NO;
  field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? false : field.oneof ? false : field.kind == "message";
  return field;
}

// node_modules/@protobuf-ts/runtime/build/es2015/oneof.js
function isOneofGroup(any) {
  if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind")) {
    return false;
  }
  switch (typeof any.oneofKind) {
    case "string":
      if (any[any.oneofKind] === void 0)
        return false;
      return Object.keys(any).length == 2;
    case "undefined":
      return Object.keys(any).length == 1;
    default:
      return false;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-type-check.js
var ReflectionTypeCheck = class {
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  prepare() {
    if (this.data)
      return;
    const req = [], known = [], oneofs = [];
    for (let field of this.fields) {
      if (field.oneof) {
        if (!oneofs.includes(field.oneof)) {
          oneofs.push(field.oneof);
          req.push(field.oneof);
          known.push(field.oneof);
        }
      } else {
        known.push(field.localName);
        switch (field.kind) {
          case "scalar":
          case "enum":
            if (!field.opt || field.repeat)
              req.push(field.localName);
            break;
          case "message":
            if (field.repeat)
              req.push(field.localName);
            break;
          case "map":
            req.push(field.localName);
            break;
        }
      }
    }
    this.data = { req, known, oneofs: Object.values(oneofs) };
  }
  /**
   * Is the argument a valid message as specified by the
   * reflection information?
   *
   * Checks all field types recursively. The `depth`
   * specifies how deep into the structure the check will be.
   *
   * With a depth of 0, only the presence of fields
   * is checked.
   *
   * With a depth of 1 or more, the field types are checked.
   *
   * With a depth of 2 or more, the members of map, repeated
   * and message fields are checked.
   *
   * Message fields will be checked recursively with depth - 1.
   *
   * The number of map entries / repeated values being checked
   * is < depth.
   */
  is(message, depth, allowExcessProperties = false) {
    if (depth < 0)
      return true;
    if (message === null || message === void 0 || typeof message != "object")
      return false;
    this.prepare();
    let keys = Object.keys(message), data = this.data;
    if (keys.length < data.req.length || data.req.some((n2) => !keys.includes(n2)))
      return false;
    if (!allowExcessProperties) {
      if (keys.some((k2) => !data.known.includes(k2)))
        return false;
    }
    if (depth < 1) {
      return true;
    }
    for (const name2 of data.oneofs) {
      const group = message[name2];
      if (!isOneofGroup(group))
        return false;
      if (group.oneofKind === void 0)
        continue;
      const field = this.fields.find((f) => f.localName === group.oneofKind);
      if (!field)
        return false;
      if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
        return false;
    }
    for (const field of this.fields) {
      if (field.oneof !== void 0)
        continue;
      if (!this.field(message[field.localName], field, allowExcessProperties, depth))
        return false;
    }
    return true;
  }
  field(arg, field, allowExcessProperties, depth) {
    let repeated = field.repeat;
    switch (field.kind) {
      case "scalar":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, field.T, depth, field.L);
        return this.scalar(arg, field.T, field.L);
      case "enum":
        if (arg === void 0)
          return field.opt;
        if (repeated)
          return this.scalars(arg, ScalarType.INT32, depth);
        return this.scalar(arg, ScalarType.INT32);
      case "message":
        if (arg === void 0)
          return true;
        if (repeated)
          return this.messages(arg, field.T(), allowExcessProperties, depth);
        return this.message(arg, field.T(), allowExcessProperties, depth);
      case "map":
        if (typeof arg != "object" || arg === null)
          return false;
        if (depth < 2)
          return true;
        if (!this.mapKeys(arg, field.K, depth))
          return false;
        switch (field.V.kind) {
          case "scalar":
            return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
          case "enum":
            return this.scalars(Object.values(arg), ScalarType.INT32, depth);
          case "message":
            return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
        }
        break;
    }
    return true;
  }
  message(arg, type, allowExcessProperties, depth) {
    if (allowExcessProperties) {
      return type.isAssignable(arg, depth);
    }
    return type.is(arg, depth);
  }
  messages(arg, type, allowExcessProperties, depth) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (allowExcessProperties) {
      for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
        if (!type.isAssignable(arg[i2], depth - 1))
          return false;
    } else {
      for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
        if (!type.is(arg[i2], depth - 1))
          return false;
    }
    return true;
  }
  scalar(arg, type, longType) {
    let argType = typeof arg;
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        switch (longType) {
          case LongType.BIGINT:
            return argType == "bigint";
          case LongType.NUMBER:
            return argType == "number" && !isNaN(arg);
          default:
            return argType == "string";
        }
      case ScalarType.BOOL:
        return argType == "boolean";
      case ScalarType.STRING:
        return argType == "string";
      case ScalarType.BYTES:
        return arg instanceof Uint8Array;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return argType == "number" && !isNaN(arg);
      default:
        return argType == "number" && Number.isInteger(arg);
    }
  }
  scalars(arg, type, depth, longType) {
    if (!Array.isArray(arg))
      return false;
    if (depth < 2)
      return true;
    if (Array.isArray(arg)) {
      for (let i2 = 0; i2 < arg.length && i2 < depth; i2++)
        if (!this.scalar(arg[i2], type, longType))
          return false;
    }
    return true;
  }
  mapKeys(map2, type, depth) {
    let keys = Object.keys(map2);
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        return this.scalars(keys.slice(0, depth).map((k2) => parseInt(k2)), type, depth);
      case ScalarType.BOOL:
        return this.scalars(keys.slice(0, depth).map((k2) => k2 == "true" ? true : k2 == "false" ? false : k2), type, depth);
      default:
        return this.scalars(keys, type, depth, LongType.STRING);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-long-convert.js
function reflectionLongConvert(long, type) {
  switch (type) {
    case LongType.BIGINT:
      return long.toBigInt();
    case LongType.NUMBER:
      return long.toNumber();
    default:
      return long.toString();
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-reader.js
var ReflectionJsonReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (this.fMap === void 0) {
      this.fMap = {};
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      for (const field of fieldsInput) {
        this.fMap[field.name] = field;
        this.fMap[field.jsonName] = field;
        this.fMap[field.localName] = field;
      }
    }
  }
  // Cannot parse JSON <type of jsonValue> for <type name>#<fieldName>.
  assert(condition, fieldName, jsonValue) {
    if (!condition) {
      let what = typeofJsonValue(jsonValue);
      if (what == "number" || what == "boolean")
        what = jsonValue.toString();
      throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
    }
  }
  /**
   * Reads a message from canonical JSON format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(input, message, options) {
    this.prepare();
    const oneofsHandled = [];
    for (const [jsonKey, jsonValue] of Object.entries(input)) {
      const field = this.fMap[jsonKey];
      if (!field) {
        if (!options.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
        continue;
      }
      const localName = field.localName;
      let target;
      if (field.oneof) {
        if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue")) {
          continue;
        }
        if (oneofsHandled.includes(field.oneof))
          throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
        oneofsHandled.push(field.oneof);
        target = message[field.oneof] = {
          oneofKind: localName
        };
      } else {
        target = message;
      }
      if (field.kind == "map") {
        if (jsonValue === null) {
          continue;
        }
        this.assert(isJsonObject(jsonValue), field.name, jsonValue);
        const fieldObj = target[localName];
        for (const [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
          this.assert(jsonObjValue !== null, field.name + " map value", null);
          let val;
          switch (field.V.kind) {
            case "message":
              val = field.V.T().internalJsonRead(jsonObjValue, options);
              break;
            case "enum":
              val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name + " map value", jsonObjValue);
          let key = jsonObjKey;
          if (field.K == ScalarType.BOOL)
            key = key == "true" ? true : key == "false" ? false : key;
          key = this.scalar(key, field.K, LongType.STRING, field.name).toString();
          fieldObj[key] = val;
        }
      } else if (field.repeat) {
        if (jsonValue === null)
          continue;
        this.assert(Array.isArray(jsonValue), field.name, jsonValue);
        const fieldArr = target[localName];
        for (const jsonItem of jsonValue) {
          this.assert(jsonItem !== null, field.name, null);
          let val;
          switch (field.kind) {
            case "message":
              val = field.T().internalJsonRead(jsonItem, options);
              break;
            case "enum":
              val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields);
              if (val === false)
                continue;
              break;
            case "scalar":
              val = this.scalar(jsonItem, field.T, field.L, field.name);
              break;
          }
          this.assert(val !== void 0, field.name, jsonValue);
          fieldArr.push(val);
        }
      } else {
        switch (field.kind) {
          case "message":
            if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
              this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
              continue;
            }
            target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
            break;
          case "enum":
            if (jsonValue === null)
              continue;
            let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
            if (val === false)
              continue;
            target[localName] = val;
            break;
          case "scalar":
            if (jsonValue === null)
              continue;
            target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
            break;
        }
      }
    }
  }
  /**
   * Returns `false` for unrecognized string representations.
   *
   * google.protobuf.NullValue accepts only JSON `null` (or the old `"NULL_VALUE"`).
   */
  enum(type, json, fieldName, ignoreUnknownFields) {
    if (type[0] == "google.protobuf.NullValue")
      assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
    if (json === null)
      return 0;
    switch (typeof json) {
      case "number":
        assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);
        return json;
      case "string":
        let localEnumName = json;
        if (type[2] && json.substring(0, type[2].length) === type[2])
          localEnumName = json.substring(type[2].length);
        let enumNumber = type[1][localEnumName];
        if (typeof enumNumber === "undefined" && ignoreUnknownFields) {
          return false;
        }
        assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);
        return enumNumber;
    }
    assert(false, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
  }
  scalar(json, type, longType, fieldName) {
    let e2;
    try {
      switch (type) {
        // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
        // Either numbers or strings are accepted. Exponent notation is also accepted.
        case ScalarType.DOUBLE:
        case ScalarType.FLOAT:
          if (json === null)
            return 0;
          if (json === "NaN")
            return Number.NaN;
          if (json === "Infinity")
            return Number.POSITIVE_INFINITY;
          if (json === "-Infinity")
            return Number.NEGATIVE_INFINITY;
          if (json === "") {
            e2 = "empty string";
            break;
          }
          if (typeof json == "string" && json.trim().length !== json.length) {
            e2 = "extra whitespace";
            break;
          }
          if (typeof json != "string" && typeof json != "number") {
            break;
          }
          let float = Number(json);
          if (Number.isNaN(float)) {
            e2 = "not a number";
            break;
          }
          if (!Number.isFinite(float)) {
            e2 = "too large or small";
            break;
          }
          if (type == ScalarType.FLOAT)
            assertFloat32(float);
          return float;
        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
        case ScalarType.UINT32:
          if (json === null)
            return 0;
          let int32;
          if (typeof json == "number")
            int32 = json;
          else if (json === "")
            e2 = "empty string";
          else if (typeof json == "string") {
            if (json.trim().length !== json.length)
              e2 = "extra whitespace";
            else
              int32 = Number(json);
          }
          if (int32 === void 0)
            break;
          if (type == ScalarType.UINT32)
            assertUInt32(int32);
          else
            assertInt32(int32);
          return int32;
        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.
        case ScalarType.INT64:
        case ScalarType.SFIXED64:
        case ScalarType.SINT64:
          if (json === null)
            return reflectionLongConvert(PbLong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbLong.from(json), longType);
        case ScalarType.FIXED64:
        case ScalarType.UINT64:
          if (json === null)
            return reflectionLongConvert(PbULong.ZERO, longType);
          if (typeof json != "number" && typeof json != "string")
            break;
          return reflectionLongConvert(PbULong.from(json), longType);
        // bool:
        case ScalarType.BOOL:
          if (json === null)
            return false;
          if (typeof json !== "boolean")
            break;
          return json;
        // string:
        case ScalarType.STRING:
          if (json === null)
            return "";
          if (typeof json !== "string") {
            e2 = "extra whitespace";
            break;
          }
          try {
            encodeURIComponent(json);
          } catch (e3) {
            e3 = "invalid UTF8";
            break;
          }
          return json;
        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
        // Either standard or URL-safe base64 encoding with/without paddings are accepted.
        case ScalarType.BYTES:
          if (json === null || json === "")
            return new Uint8Array(0);
          if (typeof json !== "string")
            break;
          return base64decode(json);
      }
    } catch (error) {
      e2 = error.message;
    }
    this.assert(false, fieldName + (e2 ? " - " + e2 : ""), json);
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-json-writer.js
var ReflectionJsonWriter = class {
  constructor(info) {
    var _a2;
    this.fields = (_a2 = info.fields) !== null && _a2 !== void 0 ? _a2 : [];
  }
  /**
   * Converts the message to a JSON object, based on the field descriptors.
   */
  write(message, options) {
    const json = {}, source = message;
    for (const field of this.fields) {
      if (!field.oneof) {
        let jsonValue2 = this.field(field, source[field.localName], options);
        if (jsonValue2 !== void 0)
          json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
        continue;
      }
      const group = source[field.oneof];
      if (group.oneofKind !== field.localName)
        continue;
      const opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: true }) : options;
      let jsonValue = this.field(field, group[field.localName], opt);
      assert(jsonValue !== void 0);
      json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
    }
    return json;
  }
  field(field, value, options) {
    let jsonValue = void 0;
    if (field.kind == "map") {
      assert(typeof value == "object" && value !== null);
      const jsonObj = {};
      switch (field.V.kind) {
        case "scalar":
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.scalar(field.V.T, entryValue, field.name, false, true);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "message":
          const messageType = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            const val = this.message(messageType, entryValue, field.name, options);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
        case "enum":
          const enumInfo = field.V.T();
          for (const [entryKey, entryValue] of Object.entries(value)) {
            assert(entryValue === void 0 || typeof entryValue == "number");
            const val = this.enum(enumInfo, entryValue, field.name, false, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonObj[entryKey.toString()] = val;
          }
          break;
      }
      if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
        jsonValue = jsonObj;
    } else if (field.repeat) {
      assert(Array.isArray(value));
      const jsonArr = [];
      switch (field.kind) {
        case "scalar":
          for (let i2 = 0; i2 < value.length; i2++) {
            const val = this.scalar(field.T, value[i2], field.name, field.opt, true);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "enum":
          const enumInfo = field.T();
          for (let i2 = 0; i2 < value.length; i2++) {
            assert(value[i2] === void 0 || typeof value[i2] == "number");
            const val = this.enum(enumInfo, value[i2], field.name, field.opt, true, options.enumAsInteger);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
        case "message":
          const messageType = field.T();
          for (let i2 = 0; i2 < value.length; i2++) {
            const val = this.message(messageType, value[i2], field.name, options);
            assert(val !== void 0);
            jsonArr.push(val);
          }
          break;
      }
      if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
        jsonValue = jsonArr;
    } else {
      switch (field.kind) {
        case "scalar":
          jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
          break;
        case "enum":
          jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
          break;
        case "message":
          jsonValue = this.message(field.T(), value, field.name, options);
          break;
      }
    }
    return jsonValue;
  }
  /**
   * Returns `null` as the default for google.protobuf.NullValue.
   */
  enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
    if (type[0] == "google.protobuf.NullValue")
      return !emitDefaultValues && !optional ? void 0 : null;
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    if (value === 0 && !emitDefaultValues && !optional)
      return void 0;
    assert(typeof value == "number");
    assert(Number.isInteger(value));
    if (enumAsInteger || !type[1].hasOwnProperty(value))
      return value;
    if (type[2])
      return type[2] + type[1][value];
    return type[1][value];
  }
  message(type, value, fieldName, options) {
    if (value === void 0)
      return options.emitDefaultValues ? null : void 0;
    return type.internalJsonWrite(value, options);
  }
  scalar(type, value, fieldName, optional, emitDefaultValues) {
    if (value === void 0) {
      assert(optional);
      return void 0;
    }
    const ed = emitDefaultValues || optional;
    switch (type) {
      // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertInt32(value);
        return value;
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        if (value === 0)
          return ed ? 0 : void 0;
        assertUInt32(value);
        return value;
      // float, double: JSON value will be a number or one of the special string values "NaN", "Infinity", and "-Infinity".
      // Either numbers or strings are accepted. Exponent notation is also accepted.
      case ScalarType.FLOAT:
        assertFloat32(value);
      case ScalarType.DOUBLE:
        if (value === 0)
          return ed ? 0 : void 0;
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value;
      // string:
      case ScalarType.STRING:
        if (value === "")
          return ed ? "" : void 0;
        assert(typeof value == "string");
        return value;
      // bool:
      case ScalarType.BOOL:
        if (value === false)
          return ed ? false : void 0;
        assert(typeof value == "boolean");
        return value;
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let ulong = PbULong.from(value);
        if (ulong.isZero() && !ed)
          return void 0;
        return ulong.toString();
      // JSON value will be a decimal string. Either numbers or strings are accepted.
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
        let long = PbLong.from(value);
        if (long.isZero() && !ed)
          return void 0;
        return long.toString();
      // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.
      // Either standard or URL-safe base64 encoding with/without paddings are accepted.
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        if (!value.byteLength)
          return ed ? "" : void 0;
        return base64encode(value);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-scalar-default.js
function reflectionScalarDefault(type, longType = LongType.STRING) {
  switch (type) {
    case ScalarType.BOOL:
      return false;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
      return reflectionLongConvert(PbULong.ZERO, longType);
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return reflectionLongConvert(PbLong.ZERO, longType);
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-reader.js
var ReflectionBinaryReader = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    var _a2;
    if (!this.fieldNoToField) {
      const fieldsInput = (_a2 = this.info.fields) !== null && _a2 !== void 0 ? _a2 : [];
      this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
    }
  }
  /**
   * Reads a message from binary format into the target message.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  read(reader, message, options, length) {
    this.prepare();
    const end = length === void 0 ? reader.len : reader.pos + length;
    while (reader.pos < end) {
      const [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
      if (!field) {
        let u2 = options.readUnknownField;
        if (u2 == "throw")
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
        let d = reader.skip(wireType);
        if (u2 !== false)
          (u2 === true ? UnknownFieldHandler.onRead : u2)(this.info.typeName, message, fieldNo, wireType, d);
        continue;
      }
      let target = message, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        target = target[field.oneof];
        if (target.oneofKind !== localName)
          target = message[field.oneof] = {
            oneofKind: localName
          };
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
          let L2 = field.kind == "scalar" ? field.L : void 0;
          if (repeated) {
            let arr = target[localName];
            if (wireType == WireType.LengthDelimited && T2 != ScalarType.STRING && T2 != ScalarType.BYTES) {
              let e2 = reader.uint32() + reader.pos;
              while (reader.pos < e2)
                arr.push(this.scalar(reader, T2, L2));
            } else
              arr.push(this.scalar(reader, T2, L2));
          } else
            target[localName] = this.scalar(reader, T2, L2);
          break;
        case "message":
          if (repeated) {
            let arr = target[localName];
            let msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
            arr.push(msg);
          } else
            target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
          break;
        case "map":
          let [mapKey, mapVal] = this.mapEntry(field, reader, options);
          target[localName][mapKey] = mapVal;
          break;
      }
    }
  }
  /**
   * Read a map field, expecting key field = 1, value field = 2
   */
  mapEntry(field, reader, options) {
    let length = reader.uint32();
    let end = reader.pos + length;
    let key = void 0;
    let val = void 0;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          if (field.K == ScalarType.BOOL)
            key = reader.bool().toString();
          else
            key = this.scalar(reader, field.K, LongType.STRING);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = this.scalar(reader, field.V.T, field.V.L);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
              break;
          }
          break;
        default:
          throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
      }
    }
    if (key === void 0) {
      let keyRaw = reflectionScalarDefault(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (val === void 0)
      switch (field.V.kind) {
        case "scalar":
          val = reflectionScalarDefault(field.V.T, field.V.L);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = field.V.T().create();
          break;
      }
    return [key, val];
  }
  scalar(reader, type, longType) {
    switch (type) {
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT64:
        return reflectionLongConvert(reader.int64(), longType);
      case ScalarType.UINT64:
        return reflectionLongConvert(reader.uint64(), longType);
      case ScalarType.FIXED64:
        return reflectionLongConvert(reader.fixed64(), longType);
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reflectionLongConvert(reader.sfixed64(), longType);
      case ScalarType.SINT32:
        return reader.sint32();
      case ScalarType.SINT64:
        return reflectionLongConvert(reader.sint64(), longType);
    }
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-binary-writer.js
var ReflectionBinaryWriter = class {
  constructor(info) {
    this.info = info;
  }
  prepare() {
    if (!this.fields) {
      const fieldsInput = this.info.fields ? this.info.fields.concat() : [];
      this.fields = fieldsInput.sort((a2, b2) => a2.no - b2.no);
    }
  }
  /**
   * Writes the message to binary format.
   */
  write(message, writer, options) {
    this.prepare();
    for (const field of this.fields) {
      let value, emitDefault, repeated = field.repeat, localName = field.localName;
      if (field.oneof) {
        const group = message[field.oneof];
        if (group.oneofKind !== localName)
          continue;
        value = group[localName];
        emitDefault = true;
      } else {
        value = message[localName];
        emitDefault = false;
      }
      switch (field.kind) {
        case "scalar":
        case "enum":
          let T2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
          if (repeated) {
            assert(Array.isArray(value));
            if (repeated == RepeatType.PACKED)
              this.packed(writer, T2, field.no, value);
            else
              for (const item of value)
                this.scalar(writer, T2, field.no, item, true);
          } else if (value === void 0)
            assert(field.opt);
          else
            this.scalar(writer, T2, field.no, value, emitDefault || field.opt);
          break;
        case "message":
          if (repeated) {
            assert(Array.isArray(value));
            for (const item of value)
              this.message(writer, options, field.T(), field.no, item);
          } else {
            this.message(writer, options, field.T(), field.no, value);
          }
          break;
        case "map":
          assert(typeof value == "object" && value !== null);
          for (const [key, val] of Object.entries(value))
            this.mapEntry(writer, options, field, key, val);
          break;
      }
    }
    let u2 = options.writeUnknownFields;
    if (u2 !== false)
      (u2 === true ? UnknownFieldHandler.onWrite : u2)(this.info.typeName, message, writer);
  }
  mapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    this.scalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        this.scalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        this.scalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        this.message(writer, options, field.V.T(), 2, value);
        break;
    }
    writer.join();
  }
  message(writer, options, handler, fieldNo, value) {
    if (value === void 0)
      return;
    handler.internalBinaryWrite(value, writer.tag(fieldNo, WireType.LengthDelimited).fork(), options);
    writer.join();
  }
  /**
   * Write a single scalar value.
   */
  scalar(writer, type, fieldNo, value, emitDefault) {
    let [wireType, method, isDefault] = this.scalarInfo(type, value);
    if (!isDefault || emitDefault) {
      writer.tag(fieldNo, wireType);
      writer[method](value);
    }
  }
  /**
   * Write an array of scalar values in packed format.
   */
  packed(writer, type, fieldNo, value) {
    if (!value.length)
      return;
    assert(type !== ScalarType.BYTES && type !== ScalarType.STRING);
    writer.tag(fieldNo, WireType.LengthDelimited);
    writer.fork();
    let [, method] = this.scalarInfo(type);
    for (let i2 = 0; i2 < value.length; i2++)
      writer[method](value[i2]);
    writer.join();
  }
  /**
   * Get information for writing a scalar value.
   *
   * Returns tuple:
   * [0]: appropriate WireType
   * [1]: name of the appropriate method of IBinaryWriter
   * [2]: whether the given value is a default value
   *
   * If argument `value` is omitted, [2] is always false.
   */
  scalarInfo(type, value) {
    let t2 = WireType.Varint;
    let m2;
    let i2 = value === void 0;
    let d = value === 0;
    switch (type) {
      case ScalarType.INT32:
        m2 = "int32";
        break;
      case ScalarType.STRING:
        d = i2 || !value.length;
        t2 = WireType.LengthDelimited;
        m2 = "string";
        break;
      case ScalarType.BOOL:
        d = value === false;
        m2 = "bool";
        break;
      case ScalarType.UINT32:
        m2 = "uint32";
        break;
      case ScalarType.DOUBLE:
        t2 = WireType.Bit64;
        m2 = "double";
        break;
      case ScalarType.FLOAT:
        t2 = WireType.Bit32;
        m2 = "float";
        break;
      case ScalarType.INT64:
        d = i2 || PbLong.from(value).isZero();
        m2 = "int64";
        break;
      case ScalarType.UINT64:
        d = i2 || PbULong.from(value).isZero();
        m2 = "uint64";
        break;
      case ScalarType.FIXED64:
        d = i2 || PbULong.from(value).isZero();
        t2 = WireType.Bit64;
        m2 = "fixed64";
        break;
      case ScalarType.BYTES:
        d = i2 || !value.byteLength;
        t2 = WireType.LengthDelimited;
        m2 = "bytes";
        break;
      case ScalarType.FIXED32:
        t2 = WireType.Bit32;
        m2 = "fixed32";
        break;
      case ScalarType.SFIXED32:
        t2 = WireType.Bit32;
        m2 = "sfixed32";
        break;
      case ScalarType.SFIXED64:
        d = i2 || PbLong.from(value).isZero();
        t2 = WireType.Bit64;
        m2 = "sfixed64";
        break;
      case ScalarType.SINT32:
        m2 = "sint32";
        break;
      case ScalarType.SINT64:
        d = i2 || PbLong.from(value).isZero();
        m2 = "sint64";
        break;
    }
    return [t2, m2, i2 || d];
  }
};

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-create.js
function reflectionCreate(type) {
  const msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, MESSAGE_TYPE, { value: type });
  for (let field of type.fields) {
    let name2 = field.localName;
    if (field.opt)
      continue;
    if (field.oneof)
      msg[field.oneof] = { oneofKind: void 0 };
    else if (field.repeat)
      msg[name2] = [];
    else
      switch (field.kind) {
        case "scalar":
          msg[name2] = reflectionScalarDefault(field.T, field.L);
          break;
        case "enum":
          msg[name2] = 0;
          break;
        case "map":
          msg[name2] = {};
          break;
      }
  }
  return msg;
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-merge-partial.js
function reflectionMergePartial(info, target, source) {
  let fieldValue, input = source, output;
  for (let field of info.fields) {
    let name2 = field.localName;
    if (field.oneof) {
      const group = input[field.oneof];
      if ((group === null || group === void 0 ? void 0 : group.oneofKind) == void 0) {
        continue;
      }
      fieldValue = group[name2];
      output = target[field.oneof];
      output.oneofKind = group.oneofKind;
      if (fieldValue == void 0) {
        delete output[name2];
        continue;
      }
    } else {
      fieldValue = input[name2];
      output = target;
      if (fieldValue == void 0) {
        continue;
      }
    }
    if (field.repeat)
      output[name2].length = fieldValue.length;
    switch (field.kind) {
      case "scalar":
      case "enum":
        if (field.repeat)
          for (let i2 = 0; i2 < fieldValue.length; i2++)
            output[name2][i2] = fieldValue[i2];
        else
          output[name2] = fieldValue;
        break;
      case "message":
        let T2 = field.T();
        if (field.repeat)
          for (let i2 = 0; i2 < fieldValue.length; i2++)
            output[name2][i2] = T2.create(fieldValue[i2]);
        else if (output[name2] === void 0)
          output[name2] = T2.create(fieldValue);
        else
          T2.mergePartial(output[name2], fieldValue);
        break;
      case "map":
        switch (field.V.kind) {
          case "scalar":
          case "enum":
            Object.assign(output[name2], fieldValue);
            break;
          case "message":
            let T3 = field.V.T();
            for (let k2 of Object.keys(fieldValue))
              output[name2][k2] = T3.create(fieldValue[k2]);
            break;
        }
        break;
    }
  }
}

// node_modules/@protobuf-ts/runtime/build/es2015/reflection-equals.js
function reflectionEquals(info, a2, b2) {
  if (a2 === b2)
    return true;
  if (!a2 || !b2)
    return false;
  for (let field of info.fields) {
    let localName = field.localName;
    let val_a = field.oneof ? a2[field.oneof][localName] : a2[localName];
    let val_b = field.oneof ? b2[field.oneof][localName] : b2[localName];
    switch (field.kind) {
      case "enum":
      case "scalar":
        let t2 = field.kind == "enum" ? ScalarType.INT32 : field.T;
        if (!(field.repeat ? repeatedPrimitiveEq(t2, val_a, val_b) : primitiveEq(t2, val_a, val_b)))
          return false;
        break;
      case "map":
        if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
          return false;
        break;
      case "message":
        let T2 = field.T();
        if (!(field.repeat ? repeatedMsgEq(T2, val_a, val_b) : T2.equals(val_a, val_b)))
          return false;
        break;
    }
  }
  return true;
}
var objectValues = Object.values;
function primitiveEq(type, a2, b2) {
  if (a2 === b2)
    return true;
  if (type !== ScalarType.BYTES)
    return false;
  let ba2 = a2;
  let bb = b2;
  if (ba2.length !== bb.length)
    return false;
  for (let i2 = 0; i2 < ba2.length; i2++)
    if (ba2[i2] != bb[i2])
      return false;
  return true;
}
function repeatedPrimitiveEq(type, a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!primitiveEq(type, a2[i2], b2[i2]))
      return false;
  return true;
}
function repeatedMsgEq(type, a2, b2) {
  if (a2.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++)
    if (!type.equals(a2[i2], b2[i2]))
      return false;
  return true;
}

// node_modules/@protobuf-ts/runtime/build/es2015/message-type.js
var baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
var messageTypeDescriptor = baseDescriptors[MESSAGE_TYPE] = {};
var MessageType = class {
  constructor(name2, fields, options) {
    this.defaultCheckDepth = 16;
    this.typeName = name2;
    this.fields = fields.map(normalizeFieldInfo);
    this.options = options !== null && options !== void 0 ? options : {};
    messageTypeDescriptor.value = this;
    this.messagePrototype = Object.create(null, baseDescriptors);
    this.refTypeCheck = new ReflectionTypeCheck(this);
    this.refJsonReader = new ReflectionJsonReader(this);
    this.refJsonWriter = new ReflectionJsonWriter(this);
    this.refBinReader = new ReflectionBinaryReader(this);
    this.refBinWriter = new ReflectionBinaryWriter(this);
  }
  create(value) {
    let message = reflectionCreate(this);
    if (value !== void 0) {
      reflectionMergePartial(this, message, value);
    }
    return message;
  }
  /**
   * Clone the message.
   *
   * Unknown fields are discarded.
   */
  clone(message) {
    let copy2 = this.create();
    reflectionMergePartial(this, copy2, message);
    return copy2;
  }
  /**
   * Determines whether two message of the same type have the same field values.
   * Checks for deep equality, traversing repeated fields, oneof groups, maps
   * and messages recursively.
   * Will also return true if both messages are `undefined`.
   */
  equals(a2, b2) {
    return reflectionEquals(this, a2, b2);
  }
  /**
   * Is the given value assignable to our message type
   * and contains no [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  is(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, false);
  }
  /**
   * Is the given value assignable to our message type,
   * regardless of [excess properties](https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks)?
   */
  isAssignable(arg, depth = this.defaultCheckDepth) {
    return this.refTypeCheck.is(arg, depth, true);
  }
  /**
   * Copy partial data into the target message.
   */
  mergePartial(target, source) {
    reflectionMergePartial(this, target, source);
  }
  /**
   * Create a new message from binary format.
   */
  fromBinary(data, options) {
    let opt = binaryReadOptions(options);
    return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
  }
  /**
   * Read a new message from a JSON value.
   */
  fromJson(json, options) {
    return this.internalJsonRead(json, jsonReadOptions(options));
  }
  /**
   * Read a new message from a JSON string.
   * This is equivalent to `T.fromJson(JSON.parse(json))`.
   */
  fromJsonString(json, options) {
    let value = JSON.parse(json);
    return this.fromJson(value, options);
  }
  /**
   * Write the message to canonical JSON value.
   */
  toJson(message, options) {
    return this.internalJsonWrite(message, jsonWriteOptions(options));
  }
  /**
   * Convert the message to canonical JSON string.
   * This is equivalent to `JSON.stringify(T.toJson(t))`
   */
  toJsonString(message, options) {
    var _a2;
    let value = this.toJson(message, options);
    return JSON.stringify(value, null, (_a2 = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a2 !== void 0 ? _a2 : 0);
  }
  /**
   * Write the message to binary format.
   */
  toBinary(message, options) {
    let opt = binaryWriteOptions(options);
    return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
  }
  /**
   * This is an internal method. If you just want to read a message from
   * JSON, use `fromJson()` or `fromJsonString()`.
   *
   * Reads JSON value and merges the fields into the target
   * according to protobuf rules. If the target is omitted,
   * a new instance is created first.
   */
  internalJsonRead(json, options, target) {
    if (json !== null && typeof json == "object" && !Array.isArray(json)) {
      let message = target !== null && target !== void 0 ? target : this.create();
      this.refJsonReader.read(json, message, options);
      return message;
    }
    throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`);
  }
  /**
   * This is an internal method. If you just want to write a message
   * to JSON, use `toJson()` or `toJsonString().
   *
   * Writes JSON value and returns it.
   */
  internalJsonWrite(message, options) {
    return this.refJsonWriter.write(message, options);
  }
  /**
   * This is an internal method. If you just want to write a message
   * in binary format, use `toBinary()`.
   *
   * Serializes the message in binary format and appends it to the given
   * writer. Returns passed writer.
   */
  internalBinaryWrite(message, writer, options) {
    this.refBinWriter.write(message, writer, options);
    return writer;
  }
  /**
   * This is an internal method. If you just want to read a message from
   * binary data, use `fromBinary()`.
   *
   * Reads data from binary format and merges the fields into
   * the target according to protobuf rules. If the target is
   * omitted, a new instance is created first.
   */
  internalBinaryRead(reader, length, options, target) {
    let message = target !== null && target !== void 0 ? target : this.create();
    this.refBinReader.read(reader, message, options, length);
    return message;
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/reflection-info.js
function normalizeMethodInfo(method, service) {
  var _a2, _b, _c2;
  let m2 = method;
  m2.service = service;
  m2.localName = (_a2 = m2.localName) !== null && _a2 !== void 0 ? _a2 : lowerCamelCase(m2.name);
  m2.serverStreaming = !!m2.serverStreaming;
  m2.clientStreaming = !!m2.clientStreaming;
  m2.options = (_b = m2.options) !== null && _b !== void 0 ? _b : {};
  m2.idempotency = (_c2 = m2.idempotency) !== null && _c2 !== void 0 ? _c2 : void 0;
  return m2;
}

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/service-type.js
var ServiceType = class {
  constructor(typeName, methods, options) {
    this.typeName = typeName;
    this.methods = methods.map((i2) => normalizeMethodInfo(i2, this));
    this.options = options !== null && options !== void 0 ? options : {};
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-error.js
var RpcError = class extends Error {
  constructor(message, code = "UNKNOWN", meta) {
    super(message);
    this.name = "RpcError";
    Object.setPrototypeOf(this, new.target.prototype);
    this.code = code;
    this.meta = meta !== null && meta !== void 0 ? meta : {};
  }
  toString() {
    const l = [this.name + ": " + this.message];
    if (this.code) {
      l.push("");
      l.push("Code: " + this.code);
    }
    if (this.serviceName && this.methodName) {
      l.push("Method: " + this.serviceName + "/" + this.methodName);
    }
    let m2 = Object.entries(this.meta);
    if (m2.length) {
      l.push("");
      l.push("Meta:");
      for (let [k2, v2] of m2) {
        l.push(`  ${k2}: ${v2}`);
      }
    }
    return l.join("\n");
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-options.js
function mergeRpcOptions(defaults, options) {
  if (!options)
    return defaults;
  let o2 = {};
  copy(defaults, o2);
  copy(options, o2);
  for (let key of Object.keys(options)) {
    let val = options[key];
    switch (key) {
      case "jsonOptions":
        o2.jsonOptions = mergeJsonOptions(defaults.jsonOptions, o2.jsonOptions);
        break;
      case "binaryOptions":
        o2.binaryOptions = mergeBinaryOptions(defaults.binaryOptions, o2.binaryOptions);
        break;
      case "meta":
        o2.meta = {};
        copy(defaults.meta, o2.meta);
        copy(options.meta, o2.meta);
        break;
      case "interceptors":
        o2.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
        break;
    }
  }
  return o2;
}
function copy(a2, into) {
  if (!a2)
    return;
  let c2 = into;
  for (let [k2, v2] of Object.entries(a2)) {
    if (v2 instanceof Date)
      c2[k2] = new Date(v2.getTime());
    else if (Array.isArray(v2))
      c2[k2] = v2.concat();
    else
      c2[k2] = v2;
  }
}

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/deferred.js
var DeferredState;
(function(DeferredState2) {
  DeferredState2[DeferredState2["PENDING"] = 0] = "PENDING";
  DeferredState2[DeferredState2["REJECTED"] = 1] = "REJECTED";
  DeferredState2[DeferredState2["RESOLVED"] = 2] = "RESOLVED";
})(DeferredState || (DeferredState = {}));
var Deferred = class {
  /**
   * @param preventUnhandledRejectionWarning - prevents the warning
   * "Unhandled Promise rejection" by adding a noop rejection handler.
   * Working with calls returned from the runtime-rpc package in an
   * async function usually means awaiting one call property after
   * the other. This means that the "status" is not being awaited when
   * an earlier await for the "headers" is rejected. This causes the
   * "unhandled promise reject" warning. A more correct behaviour for
   * calls might be to become aware whether at least one of the
   * promises is handled and swallow the rejection warning for the
   * others.
   */
  constructor(preventUnhandledRejectionWarning = true) {
    this._state = DeferredState.PENDING;
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    if (preventUnhandledRejectionWarning) {
      this._promise.catch((_2) => {
      });
    }
  }
  /**
   * Get the current state of the promise.
   */
  get state() {
    return this._state;
  }
  /**
   * Get the deferred promise.
   */
  get promise() {
    return this._promise;
  }
  /**
   * Resolve the promise. Throws if the promise is already resolved or rejected.
   */
  resolve(value) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
    this._resolve(value);
    this._state = DeferredState.RESOLVED;
  }
  /**
   * Reject the promise. Throws if the promise is already resolved or rejected.
   */
  reject(reason) {
    if (this.state !== DeferredState.PENDING)
      throw new Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
    this._reject(reason);
    this._state = DeferredState.REJECTED;
  }
  /**
   * Resolve the promise. Ignore if not pending.
   */
  resolvePending(val) {
    if (this._state === DeferredState.PENDING)
      this.resolve(val);
  }
  /**
   * Reject the promise. Ignore if not pending.
   */
  rejectPending(reason) {
    if (this._state === DeferredState.PENDING)
      this.reject(reason);
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-output-stream.js
var RpcOutputStreamController = class {
  constructor() {
    this._lis = {
      nxt: [],
      msg: [],
      err: [],
      cmp: []
    };
    this._closed = false;
    this._itState = { q: [] };
  }
  // --- RpcOutputStream callback API
  onNext(callback) {
    return this.addLis(callback, this._lis.nxt);
  }
  onMessage(callback) {
    return this.addLis(callback, this._lis.msg);
  }
  onError(callback) {
    return this.addLis(callback, this._lis.err);
  }
  onComplete(callback) {
    return this.addLis(callback, this._lis.cmp);
  }
  addLis(callback, list) {
    list.push(callback);
    return () => {
      let i2 = list.indexOf(callback);
      if (i2 >= 0)
        list.splice(i2, 1);
    };
  }
  // remove all listeners
  clearLis() {
    for (let l of Object.values(this._lis))
      l.splice(0, l.length);
  }
  // --- Controller API
  /**
   * Is this stream already closed by a completion or error?
   */
  get closed() {
    return this._closed !== false;
  }
  /**
   * Emit message, close with error, or close successfully, but only one
   * at a time.
   * Can be used to wrap a stream by using the other stream's `onNext`.
   */
  notifyNext(message, error, complete) {
    assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time");
    if (message)
      this.notifyMessage(message);
    if (error)
      this.notifyError(error);
    if (complete)
      this.notifyComplete();
  }
  /**
   * Emits a new message. Throws if stream is closed.
   *
   * Triggers onNext and onMessage callbacks.
   */
  notifyMessage(message) {
    assert(!this.closed, "stream is closed");
    this.pushIt({ value: message, done: false });
    this._lis.msg.forEach((l) => l(message));
    this._lis.nxt.forEach((l) => l(message, void 0, false));
  }
  /**
   * Closes the stream with an error. Throws if stream is closed.
   *
   * Triggers onNext and onError callbacks.
   */
  notifyError(error) {
    assert(!this.closed, "stream is closed");
    this._closed = error;
    this.pushIt(error);
    this._lis.err.forEach((l) => l(error));
    this._lis.nxt.forEach((l) => l(void 0, error, false));
    this.clearLis();
  }
  /**
   * Closes the stream successfully. Throws if stream is closed.
   *
   * Triggers onNext and onComplete callbacks.
   */
  notifyComplete() {
    assert(!this.closed, "stream is closed");
    this._closed = true;
    this.pushIt({ value: null, done: true });
    this._lis.cmp.forEach((l) => l());
    this._lis.nxt.forEach((l) => l(void 0, void 0, true));
    this.clearLis();
  }
  /**
   * Creates an async iterator (that can be used with `for await {...}`)
   * to consume the stream.
   *
   * Some things to note:
   * - If an error occurs, the `for await` will throw it.
   * - If an error occurred before the `for await` was started, `for await`
   *   will re-throw it.
   * - If the stream is already complete, the `for await` will be empty.
   * - If your `for await` consumes slower than the stream produces,
   *   for example because you are relaying messages in a slow operation,
   *   messages are queued.
   */
  [Symbol.asyncIterator]() {
    if (this._closed === true)
      this.pushIt({ value: null, done: true });
    else if (this._closed !== false)
      this.pushIt(this._closed);
    return {
      next: () => {
        let state = this._itState;
        assert(state, "bad state");
        assert(!state.p, "iterator contract broken");
        let first2 = state.q.shift();
        if (first2)
          return "value" in first2 ? Promise.resolve(first2) : Promise.reject(first2);
        state.p = new Deferred();
        return state.p.promise;
      }
    };
  }
  // "push" a new iterator result.
  // this either resolves a pending promise, or enqueues the result.
  pushIt(result) {
    let state = this._itState;
    if (state.p) {
      const p2 = state.p;
      assert(p2.state == DeferredState.PENDING, "iterator contract broken");
      "value" in result ? p2.resolve(result) : p2.reject(result);
      delete state.p;
    } else {
      state.q.push(result);
    }
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/unary-call.js
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var UnaryCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request;
    this.headers = headers;
    this.response = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * If you are only interested in the final outcome of this call,
   * you can await it to receive a `FinishedUnaryCall`.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter2(this, void 0, void 0, function* () {
      let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers,
        response,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/server-streaming-call.js
var __awaiter3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ServerStreamingCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.request = request;
    this.headers = headers;
    this.responses = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * You should first setup some listeners to the `request` to
   * see the actual messages the server replied with.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter3(this, void 0, void 0, function* () {
      let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        request: this.request,
        headers,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/client-streaming-call.js
var __awaiter4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ClientStreamingCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request;
    this.headers = headers;
    this.response = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter4(this, void 0, void 0, function* () {
      let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers,
        response,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/duplex-streaming-call.js
var __awaiter5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DuplexStreamingCall = class {
  constructor(method, requestHeaders, request, headers, response, status, trailers) {
    this.method = method;
    this.requestHeaders = requestHeaders;
    this.requests = request;
    this.headers = headers;
    this.responses = response;
    this.status = status;
    this.trailers = trailers;
  }
  /**
   * Instead of awaiting the response status and trailers, you can
   * just as well await this call itself to receive the server outcome.
   * Note that it may still be valid to send more request messages.
   */
  then(onfulfilled, onrejected) {
    return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
  }
  promiseFinished() {
    return __awaiter5(this, void 0, void 0, function* () {
      let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
      return {
        method: this.method,
        requestHeaders: this.requestHeaders,
        headers,
        status,
        trailers
      };
    });
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/test-transport.js
var __awaiter6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TestTransport = class _TestTransport {
  /**
   * Initialize with mock data. Omitted fields have default value.
   */
  constructor(data) {
    this.suppressUncaughtRejections = true;
    this.headerDelay = 10;
    this.responseDelay = 50;
    this.betweenResponseDelay = 10;
    this.afterResponseDelay = 10;
    this.data = data !== null && data !== void 0 ? data : {};
  }
  /**
   * Sent message(s) during the last operation.
   */
  get sentMessages() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.sent;
    } else if (typeof this.lastInput == "object") {
      return [this.lastInput.single];
    }
    return [];
  }
  /**
   * Sending message(s) completed?
   */
  get sendComplete() {
    if (this.lastInput instanceof TestInputStream) {
      return this.lastInput.completed;
    } else if (typeof this.lastInput == "object") {
      return true;
    }
    return false;
  }
  // Creates a promise for response headers from the mock data.
  promiseHeaders() {
    var _a2;
    const headers = (_a2 = this.data.headers) !== null && _a2 !== void 0 ? _a2 : _TestTransport.defaultHeaders;
    return headers instanceof RpcError ? Promise.reject(headers) : Promise.resolve(headers);
  }
  // Creates a promise for a single, valid, message from the mock data.
  promiseSingleResponse(method) {
    if (this.data.response instanceof RpcError) {
      return Promise.reject(this.data.response);
    }
    let r2;
    if (Array.isArray(this.data.response)) {
      assert(this.data.response.length > 0);
      r2 = this.data.response[0];
    } else if (this.data.response !== void 0) {
      r2 = this.data.response;
    } else {
      r2 = method.O.create();
    }
    assert(method.O.is(r2));
    return Promise.resolve(r2);
  }
  /**
   * Pushes response messages from the mock data to the output stream.
   * If an error response, status or trailers are mocked, the stream is
   * closed with the respective error.
   * Otherwise, stream is completed successfully.
   *
   * The returned promise resolves when the stream is closed. It should
   * not reject. If it does, code is broken.
   */
  streamResponses(method, stream, abort) {
    return __awaiter6(this, void 0, void 0, function* () {
      const messages = [];
      if (this.data.response === void 0) {
        messages.push(method.O.create());
      } else if (Array.isArray(this.data.response)) {
        for (let msg of this.data.response) {
          assert(method.O.is(msg));
          messages.push(msg);
        }
      } else if (!(this.data.response instanceof RpcError)) {
        assert(method.O.is(this.data.response));
        messages.push(this.data.response);
      }
      try {
        yield delay(this.responseDelay, abort)(void 0);
      } catch (error) {
        stream.notifyError(error);
        return;
      }
      if (this.data.response instanceof RpcError) {
        stream.notifyError(this.data.response);
        return;
      }
      for (let msg of messages) {
        stream.notifyMessage(msg);
        try {
          yield delay(this.betweenResponseDelay, abort)(void 0);
        } catch (error) {
          stream.notifyError(error);
          return;
        }
      }
      if (this.data.status instanceof RpcError) {
        stream.notifyError(this.data.status);
        return;
      }
      if (this.data.trailers instanceof RpcError) {
        stream.notifyError(this.data.trailers);
        return;
      }
      stream.notifyComplete();
    });
  }
  // Creates a promise for response status from the mock data.
  promiseStatus() {
    var _a2;
    const status = (_a2 = this.data.status) !== null && _a2 !== void 0 ? _a2 : _TestTransport.defaultStatus;
    return status instanceof RpcError ? Promise.reject(status) : Promise.resolve(status);
  }
  // Creates a promise for response trailers from the mock data.
  promiseTrailers() {
    var _a2;
    const trailers = (_a2 = this.data.trailers) !== null && _a2 !== void 0 ? _a2 : _TestTransport.defaultTrailers;
    return trailers instanceof RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
  }
  maybeSuppressUncaught(...promise) {
    if (this.suppressUncaughtRejections) {
      for (let p2 of promise) {
        p2.catch(() => {
        });
      }
    }
  }
  mergeOptions(options) {
    return mergeRpcOptions({}, options);
  }
  unary(method, input, options) {
    var _a2;
    const requestHeaders = (_a2 = options.meta) !== null && _a2 !== void 0 ? _a2 : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {
    }).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  serverStreaming(method, input, options) {
    var _a2;
    const requestHeaders = (_a2 = options.meta) !== null && _a2 !== void 0 ? _a2 : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = { single: input };
    return new ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
  }
  clientStreaming(method, options) {
    var _a2;
    const requestHeaders = (_a2 = options.meta) !== null && _a2 !== void 0 ? _a2 : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {
    }).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {
    }).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options.abort);
    return new ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
  }
  duplex(method, options) {
    var _a2;
    const requestHeaders = (_a2 = options.meta) !== null && _a2 !== void 0 ? _a2 : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new RpcOutputStreamController(), responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {
    }).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
    this.maybeSuppressUncaught(statusPromise, trailersPromise);
    this.lastInput = new TestInputStream(this.data, options.abort);
    return new DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
  }
};
TestTransport.defaultHeaders = {
  responseHeader: "test"
};
TestTransport.defaultStatus = {
  code: "OK",
  detail: "all good"
};
TestTransport.defaultTrailers = {
  responseTrailer: "test"
};
function delay(ms2, abort) {
  return (v2) => new Promise((resolve, reject) => {
    if (abort === null || abort === void 0 ? void 0 : abort.aborted) {
      reject(new RpcError("user cancel", "CANCELLED"));
    } else {
      const id = setTimeout(() => resolve(v2), ms2);
      if (abort) {
        abort.addEventListener("abort", (ev) => {
          clearTimeout(id);
          reject(new RpcError("user cancel", "CANCELLED"));
        });
      }
    }
  });
}
var TestInputStream = class {
  constructor(data, abort) {
    this._completed = false;
    this._sent = [];
    this.data = data;
    this.abort = abort;
  }
  get sent() {
    return this._sent;
  }
  get completed() {
    return this._completed;
  }
  send(message) {
    if (this.data.inputMessage instanceof RpcError) {
      return Promise.reject(this.data.inputMessage);
    }
    const delayMs = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
    return Promise.resolve(void 0).then(() => {
      this._sent.push(message);
    }).then(delay(delayMs, this.abort));
  }
  complete() {
    if (this.data.inputComplete instanceof RpcError) {
      return Promise.reject(this.data.inputComplete);
    }
    const delayMs = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
    return Promise.resolve(void 0).then(() => {
      this._completed = true;
    }).then(delay(delayMs, this.abort));
  }
};

// node_modules/@protobuf-ts/runtime-rpc/build/es2015/rpc-interceptor.js
function stackIntercept(kind, transport, method, options, input) {
  var _a2, _b, _c2, _d;
  if (kind == "unary") {
    let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
    for (const curr of ((_a2 = options.interceptors) !== null && _a2 !== void 0 ? _a2 : []).filter((i2) => i2.interceptUnary).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "serverStreaming") {
    let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
    for (const curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter((i2) => i2.interceptServerStreaming).reverse()) {
      const next = tail;
      tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
    }
    return tail(method, input, options);
  }
  if (kind == "clientStreaming") {
    let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
    for (const curr of ((_c2 = options.interceptors) !== null && _c2 !== void 0 ? _c2 : []).filter((i2) => i2.interceptClientStreaming).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
    }
    return tail(method, options);
  }
  if (kind == "duplex") {
    let tail = (mtd, opt) => transport.duplex(mtd, opt);
    for (const curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter((i2) => i2.interceptDuplex).reverse()) {
      const next = tail;
      tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
    }
    return tail(method, options);
  }
  assertNever(kind);
}

// node_modules/@protobuf-ts/twirp-transport/build/es2015/twitch-twirp-error-code.js
var TwirpErrorCode;
(function(TwirpErrorCode2) {
  TwirpErrorCode2[TwirpErrorCode2["cancelled"] = 0] = "cancelled";
  TwirpErrorCode2[TwirpErrorCode2["unknown"] = 1] = "unknown";
  TwirpErrorCode2[TwirpErrorCode2["invalid_argument"] = 2] = "invalid_argument";
  TwirpErrorCode2[TwirpErrorCode2["malformed"] = 3] = "malformed";
  TwirpErrorCode2[TwirpErrorCode2["deadline_exceeded"] = 4] = "deadline_exceeded";
  TwirpErrorCode2[TwirpErrorCode2["not_found"] = 5] = "not_found";
  TwirpErrorCode2[TwirpErrorCode2["bad_route"] = 6] = "bad_route";
  TwirpErrorCode2[TwirpErrorCode2["already_exists"] = 7] = "already_exists";
  TwirpErrorCode2[TwirpErrorCode2["permission_denied"] = 8] = "permission_denied";
  TwirpErrorCode2[TwirpErrorCode2["unauthenticated"] = 9] = "unauthenticated";
  TwirpErrorCode2[TwirpErrorCode2["resource_exhausted"] = 10] = "resource_exhausted";
  TwirpErrorCode2[TwirpErrorCode2["failed_precondition"] = 11] = "failed_precondition";
  TwirpErrorCode2[TwirpErrorCode2["aborted"] = 12] = "aborted";
  TwirpErrorCode2[TwirpErrorCode2["out_of_range"] = 13] = "out_of_range";
  TwirpErrorCode2[TwirpErrorCode2["unimplemented"] = 14] = "unimplemented";
  TwirpErrorCode2[TwirpErrorCode2["internal"] = 15] = "internal";
  TwirpErrorCode2[TwirpErrorCode2["unavailable"] = 16] = "unavailable";
  TwirpErrorCode2[TwirpErrorCode2["dataloss"] = 17] = "dataloss";
})(TwirpErrorCode || (TwirpErrorCode = {}));

// node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-format.js
function createTwirpRequestHeader(headers, sendJson, meta) {
  if (meta) {
    for (let [k2, v2] of Object.entries(meta)) {
      if (typeof v2 == "string")
        headers.append(k2, v2);
      else
        for (let i2 of v2)
          headers.append(k2, i2);
    }
  }
  headers.set("Content-Type", sendJson ? "application/json" : "application/protobuf");
  headers.set("Accept", sendJson ? "application/json" : "application/protobuf, application/json");
  return headers;
}
function parseTwirpErrorResponse(json) {
  if (!isJsonObject(json) || typeof json.code !== "string" || typeof json.msg !== "string")
    return new RpcError("cannot read twirp error response", TwirpErrorCode[TwirpErrorCode.internal]);
  let meta = {};
  if (isJsonObject(json.meta)) {
    for (let [k2, v2] of Object.entries(json.meta)) {
      if (typeof v2 == "string")
        meta[k2] = v2;
    }
  }
  return new RpcError(json.msg, json.code, meta);
}
function parseMetadataFromResponseHeaders(headers) {
  let meta = {};
  headers.forEach((value, key) => {
    if (key.toLowerCase() === "content-type")
      return;
    if (key.toLowerCase() === "content-length")
      return;
    if (meta.hasOwnProperty(key))
      meta[key].push(value);
    else
      meta[key] = value;
  });
  return meta;
}

// node_modules/@protobuf-ts/twirp-transport/build/es2015/twirp-transport.js
var TwirpFetchTransport = class {
  constructor(options) {
    this.defaultOptions = options;
  }
  mergeOptions(options) {
    return mergeRpcOptions(this.defaultOptions, options);
  }
  unary(method, input, options) {
    var _a2, _b, _c2;
    let opt = options, url = this.makeUrl(method, opt), fetchInit = (_a2 = opt.fetchInit) !== null && _a2 !== void 0 ? _a2 : {}, requestBody = opt.sendJson ? method.I.toJsonString(input, opt.jsonOptions) : method.I.toBinary(input, opt.binaryOptions), defHeader = new Deferred(), defMessage = new Deferred(), defStatus = new Deferred(), defTrailer = new Deferred();
    globalThis.fetch(url, Object.assign(Object.assign({}, fetchInit), {
      method: "POST",
      headers: createTwirpRequestHeader(new globalThis.Headers(), !!opt.sendJson, opt.meta),
      body: requestBody,
      signal: (_b = options.abort) !== null && _b !== void 0 ? _b : null
      // node-fetch@3.0.0-beta.9 rejects `undefined`
    })).then((fetchResponse) => {
      defHeader.resolve(parseMetadataFromResponseHeaders(fetchResponse.headers));
      let responseType;
      try {
        responseType = fetchResponse.type;
      } catch (_a3) {
      }
      switch (responseType) {
        case "error":
        case "opaque":
        case "opaqueredirect":
          throw new RpcError(`fetch response type ${fetchResponse.type}`, TwirpErrorCode[TwirpErrorCode.unknown]);
      }
      if (!fetchResponse.ok) {
        return fetchResponse.json().then((value) => {
          throw parseTwirpErrorResponse(value);
        }, () => {
          throw new RpcError("received HTTP " + fetchResponse.status + ", unable to read response body as json", TwirpErrorCode[TwirpErrorCode.internal]);
        });
      }
      if (opt.sendJson) {
        return fetchResponse.json().then((value) => method.O.fromJson(value, opt.jsonOptions), () => {
          throw new RpcError("unable to read response body as json", TwirpErrorCode[TwirpErrorCode.dataloss]);
        });
      }
      return fetchResponse.arrayBuffer().then((value) => method.O.fromBinary(new Uint8Array(value), opt.binaryOptions), () => {
        throw new RpcError("unable to read response body", TwirpErrorCode[TwirpErrorCode.dataloss]);
      });
    }, (reason) => {
      if (reason instanceof Error && reason.name === "AbortError")
        throw new RpcError(reason.message, TwirpErrorCode[TwirpErrorCode.cancelled]);
      throw new RpcError(reason instanceof Error ? reason.message : reason);
    }).then((message) => {
      defMessage.resolve(message);
      defStatus.resolve({ code: "OK", detail: "" });
      defTrailer.resolve({});
    }).catch((reason) => {
      let error = reason instanceof RpcError ? reason : new RpcError(reason instanceof Error ? reason.message : reason, TwirpErrorCode[TwirpErrorCode.internal]);
      error.methodName = method.name;
      error.serviceName = method.service.typeName;
      defHeader.rejectPending(error);
      defMessage.rejectPending(error);
      defStatus.rejectPending(error);
      defTrailer.rejectPending(error);
    });
    return new UnaryCall(method, (_c2 = opt.meta) !== null && _c2 !== void 0 ? _c2 : {}, input, defHeader.promise, defMessage.promise, defStatus.promise, defTrailer.promise);
  }
  /**
   * Create an URI for a RPC call.
   *
   * Takes the `baseUrl` option and appends:
   * - slash "/"
   * - package name
   * - dot "."
   * - service name
   * - slash "/"
   * - method name
   *
   * If the service was declared without a package, the package name and dot
   * are omitted.
   *
   * The method name is CamelCased just as it would be in Go, unless the
   * option `useProtoMethodName` is `true`.
   */
  makeUrl(method, options) {
    let base = options.baseUrl;
    if (base.endsWith("/"))
      base = base.substring(0, base.length - 1);
    let methodName = method.name;
    if (options.useProtoMethodName !== true) {
      methodName = lowerCamelCase(methodName);
      methodName = methodName.substring(0, 1).toUpperCase() + methodName.substring(1);
    }
    return `${base}/${method.service.typeName}/${methodName}`;
  }
  clientStreaming(method) {
    const e2 = new RpcError("Client streaming is not supported by Twirp", TwirpErrorCode[TwirpErrorCode.unimplemented]);
    e2.methodName = method.name;
    e2.serviceName = method.service.typeName;
    throw e2;
  }
  duplex(method) {
    const e2 = new RpcError("Duplex streaming is not supported by Twirp", TwirpErrorCode[TwirpErrorCode.unimplemented]);
    e2.methodName = method.name;
    e2.serviceName = method.service.typeName;
    throw e2;
  }
  serverStreaming(method) {
    const e2 = new RpcError("Server streaming is not supported by Twirp", TwirpErrorCode[TwirpErrorCode.unimplemented]);
    e2.methodName = method.name;
    e2.serviceName = method.service.typeName;
    throw e2;
  }
};

// node_modules/@stream-io/logger/dist/esm/utils/is-react-native.js
var isReactNative = () => {
  if (typeof navigator === "undefined")
    return false;
  return navigator.product?.toLowerCase() === "reactnative";
};

// node_modules/@stream-io/logger/dist/esm/index.js
var LogLevelEnum;
(function(LogLevelEnum2) {
  LogLevelEnum2[LogLevelEnum2["trace"] = 0] = "trace";
  LogLevelEnum2[LogLevelEnum2["debug"] = 1] = "debug";
  LogLevelEnum2[LogLevelEnum2["info"] = 2] = "info";
  LogLevelEnum2[LogLevelEnum2["warn"] = 3] = "warn";
  LogLevelEnum2[LogLevelEnum2["error"] = 4] = "error";
})(LogLevelEnum || (LogLevelEnum = {}));
var logToConsole = (logLevel, message, ...rest) => {
  let logMethod;
  switch (logLevel) {
    case "error":
      if (isReactNative()) {
        message = `ERROR: ${message}`;
        logMethod = console.info;
        break;
      }
      logMethod = console.error;
      break;
    case "warn":
      if (isReactNative()) {
        message = `WARN: ${message}`;
        logMethod = console.info;
        break;
      }
      logMethod = console.warn;
      break;
    case "info":
      logMethod = console.info;
      break;
    case "trace":
      logMethod = console.trace;
      break;
    default:
      logMethod = console.log;
      break;
  }
  logMethod(message, ...rest);
};
var DEFAULT_LOG_LEVEL = "info";
var DEFAULT_SINK = logToConsole;
var createLoggerSystem = () => {
  const sinkByScope = /* @__PURE__ */ new Map([["default", DEFAULT_SINK]]);
  const logLevelByScope = /* @__PURE__ */ new Map([["default", DEFAULT_LOG_LEVEL]]);
  const getLogger = (scope, options = {}) => {
    const tagString = (options.tags ?? []).filter(Boolean).join(",");
    const constructLogFunction = (logLevel) => (message, ...data) => {
      const scopedLogLevel = logLevelByScope.get(scope) ?? logLevelByScope.get("default");
      if (LogLevelEnum[logLevel] >= LogLevelEnum[scopedLogLevel]) {
        const scopedSink = sinkByScope.get(scope) ?? sinkByScope.get("default");
        scopedSink(logLevel, `[${scope}]${tagString.length ? `(${tagString})` : ""}: ${message}`, ...data);
      }
    };
    return {
      withExtraTags: (...extraTags) => {
        return getLogger(scope, {
          ...options,
          tags: options.tags ? options.tags.concat(extraTags) : extraTags
        });
      },
      getLogLevel: () => {
        return logLevelByScope.get(scope) ?? logLevelByScope.get("default");
      },
      ...{
        error: constructLogFunction("error"),
        trace: constructLogFunction("trace"),
        debug: constructLogFunction("debug"),
        info: constructLogFunction("info"),
        warn: constructLogFunction("warn")
      }
    };
  };
  const configureLoggers = (optionsByScope) => {
    for (const scope in optionsByScope) {
      const options = optionsByScope[scope];
      if (options.sink) {
        sinkByScope.set(scope, options.sink);
      } else if (options.sink === null && scope !== "default") {
        sinkByScope.delete(scope);
      }
      if (options.level) {
        logLevelByScope.set(scope, options.level);
      } else if (options.level === null && scope !== "default") {
        logLevelByScope.delete(scope);
      }
    }
  };
  const restoreDefaults = () => {
    sinkByScope.clear();
    logLevelByScope.clear();
    sinkByScope.set("default", DEFAULT_SINK);
    logLevelByScope.set("default", DEFAULT_LOG_LEVEL);
  };
  return {
    getLogger,
    configureLoggers,
    restoreDefaults
  };
};

// node_modules/@stream-io/video-client/dist/index.browser.es.js
var import_sdp_transform = __toESM(require_lib());

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance2) {
    Error.call(instance2);
    instance2.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = (function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a2, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return)) _a2.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a2;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = (function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  })();
  return Subscription2;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (function() {
  return createNotification("C", void 0, void 0);
})();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a2 = context, errorThrown = _a2.errorThrown, error = _a2.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = (function(_super) {
  __extends(Subscriber3, _super);
  function Subscriber3(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber3.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber3.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber3.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber3.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber3.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber3.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber3.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber3.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber3;
})(Subscription);
var _bind = Function.prototype.bind;
function bind(fn2, thisArg) {
  return _bind.call(fn2, thisArg);
}
var ConsumerObserver = (function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
})();
var SafeSubscriber = (function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
})(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = (function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
})();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x2) {
  return x2;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn2) {
      return fn2(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = (function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a2 = _this, operator = _a2.operator, source = _a2.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a2;
    return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      operations[_i2] = arguments[_i2];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
})();
function getPromiseCtor(promiseCtor) {
  var _a2;
  return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a2;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
    }
  };
  return OperatorSubscriber2;
})(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = (function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
})(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = (function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a2;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
            var observer = _c2.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a2 = _b.return)) _a2.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a2;
      return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
})(Observable);
var AnonymousSubject = (function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b === void 0 ? void 0 : _b.call(_a2, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b === void 0 ? void 0 : _b.call(_a2, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a2, _b;
    (_b = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b === void 0 ? void 0 : _b.call(_a2);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a2, _b;
    return (_b = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = (function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = (function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
    var copy2 = _buffer.slice();
    for (var i2 = 0; i2 < copy2.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
        last3 = i2;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = (function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a2 = this, hasError = _a2.hasError, _hasValue = _a2._hasValue, _value = _a2._value, thrownError = _a2.thrownError, isStopped = _a2.isStopped, _isComplete = _a2._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _value = _a2._value, _isComplete = _a2._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = (function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return this;
  };
  return Action2;
})(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      args[_i2 - 2] = arguments[_i2];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = (function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay3) {
    var _a2;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay3);
    }
    this.pending = true;
    this.delay = delay3;
    this.id = (_a2 = this.id) !== null && _a2 !== void 0 ? _a2 : this.requestAsyncId(scheduler, this.id, delay3);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay3);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && this.delay === delay3 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay3) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay3);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a2 = this, id = _a2.id, scheduler = _a2.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
})(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = (function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a2;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = (function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay3, state) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay3);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
})();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = (function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
})(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = (function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = (function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 > 0) {
      return _super.prototype.schedule.call(this, state, delay3);
    }
    this.delay = delay3;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay3) {
    return delay3 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay3) : this._execute(state, delay3);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && delay3 > 0 || delay3 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = (function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = (function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a2;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && id === scheduler._scheduled && ((_a2 = actions[actions.length - 1]) === null || _a2 === void 0 ? void 0 : _a2.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = (function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = (function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
})(AsyncScheduler);
var VirtualAction = (function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (Number.isFinite(delay3)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay3);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay3);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    this.delay = scheduler.frame + delay3;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay3) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay3);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = (function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
});

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a2, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a2 = _b.sent(), value = _a2.value, done = _a2.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a2;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return)) _a2.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a2;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return))) return [3, 8];
          return [4, _a2.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay3, repeat2) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay3));
    } else {
      this.unsubscribe();
    }
  }, delay3);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay3);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay3);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay3);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay3));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a2;
        var value;
        var done;
        try {
          _a2 = iterator2.next(), value = _a2.value, done = _a2.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = (function() {
  function Notification3(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification3.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification3.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification3.prototype.accept = function(nextOrObserver, error, complete) {
    var _a2;
    return isFunction((_a2 = nextOrObserver) === null || _a2 === void 0 ? void 0 : _a2.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification3.prototype.toObservable = function() {
    var _a2 = this, kind = _a2.kind, value = _a2.value, error = _a2.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification3.createNext = function(value) {
    return new Notification3("N", value);
  };
  Notification3.createError = function(err) {
    return new Notification3("E", void 0, err);
  };
  Notification3.createComplete = function() {
    return Notification3.completeNotification;
  };
  Notification3.completeNotification = new Notification3("C");
  return Notification3;
})();
function observeNotification(notification, observer) {
  var _a2, _b, _c2;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a2 = observer.next) === null || _a2 === void 0 ? void 0 : _a2.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c2 = observer.complete) === null || _c2 === void 0 ? void 0 : _c2.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn2, args) {
  return isArray(args) ? fn2.apply(void 0, __spreadArray([], __read(args))) : fn2(args);
}
function mapOneOrManyArgs(fn2) {
  return map(function(args) {
    return callOrApply(fn2, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i2) {
    return result[key] = values[i2], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a2 = argsArgArrayOrObject(args), observables = _a2.args, keys = _a2.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i3) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i3], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i3] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i2 = 0; i2 < length; i2++) {
        _loop_1(i2);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a2, i2) {
      return map(function(b2, ii2) {
        return resultSelector(a2, b2, i2, ii2);
      })(innerFrom(project(a2, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a2 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a2[0], remove = _a2[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEventPattern.js
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs(resultSelector));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e2 = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        e2[_i2] = arguments[_i2];
      }
      return subscriber.next(e2.length === 1 ? e2[0] : e2);
    };
    var retValue = addHandler(handler);
    return isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/operators/concatMap.js
function concatMap(project, resultSelector) {
  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);
}

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a2, b2) {
  return a2 === b2;
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilKeyChanged.js
function distinctUntilKeyChanged(key, compare) {
  return distinctUntilChanged(function(x2, y2) {
    return compare ? compare(x2[key], y2[key]) : x2[key] === y2[key];
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/pairwise.js
function pairwise() {
  return operate(function(source, subscriber) {
    var prev;
    var hasPrev = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var p2 = prev;
      prev = value;
      hasPrev && subscriber.next([p2, value]);
      hasPrev = true;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = options.connector, connector = _a2 === void 0 ? function() {
    return new Subject();
  } : _a2, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c2 = options.resetOnComplete, resetOnComplete = _c2 === void 0 ? true : _c2, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on2) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  if (on2 === true) {
    reset();
    return;
  }
  if (on2 === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on2.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a2, _b, _c2;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === void 0 ? Infinity : _a2, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c2 = configOrBufferSize.refCount, refCount2 = _c2 === void 0 ? false : _c2, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    values[_i2] = arguments[_i2];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeWhile.js
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a2;
    (_a2 = tapObserver.subscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a3;
      (_a3 = tapObserver.next) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.complete) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a3;
      isUnsub = false;
      (_a3 = tapObserver.error) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a3, _b;
      if (isUnsub) {
        (_a3 = tapObserver.unsubscribe) === null || _a3 === void 0 ? void 0 : _a3.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/@stream-io/video-client/dist/index.browser.es.js
var import_ua_parser_js = __toESM(require_ua_parser());

// node_modules/@stream-io/worker-timer/dist/esm/worker.build.js
var timerWorker = {
  src: `const e=new Map;self.addEventListener("message",t=>{const s=t.data;switch(s.type){case"setTimeout":case"setInterval":e.set(s.id,("setTimeout"===s.type?setTimeout:setInterval)(()=>{!function(e){const t={type:"tick",id:e};self.postMessage(t)}(s.id),"setTimeout"===s.type&&e.delete(s.id)},s.timeout));break;case"clearTimeout":case"clearInterval":("clearTimeout"===s.type?clearTimeout:clearInterval)(e.get(s.id)),e.delete(s.id)}});`
};

// node_modules/@stream-io/worker-timer/dist/esm/index.js
var WorkerTimer = class {
  /**
   * Constructs a new instance of WorkerTimer.
   *
   * @param init the init parameters.
   */
  constructor(init = {}) {
    this.currentTimerId = 1;
    this.callbacks = /* @__PURE__ */ new Map();
    this.fallback = false;
    this.setup = ({ useWorker = true, name: name2 = "@stream-io/worker-timer" } = {}) => {
      if (!useWorker) {
        this.fallback = true;
        return;
      }
      try {
        const source = timerWorker.src;
        const blob = new Blob([source], {
          type: "application/javascript; charset=utf-8"
        });
        const script = URL.createObjectURL(blob);
        this.worker = new Worker(script, { name: name2 });
        this.worker.addEventListener("message", (e2) => {
          const { type, id } = e2.data;
          if (type === "tick") {
            this.callbacks.get(id)?.();
          }
        });
      } catch (err) {
        console.error("Failed to create timer worker: ", err);
        this.fallback = true;
      }
    };
    this.destroy = () => {
      this.callbacks.clear();
      this.worker?.terminate();
      this.worker = void 0;
      this.fallback = false;
    };
    this.setInterval = (callback, timeout2) => this.setTimer("setInterval", callback, timeout2);
    this.clearInterval = (id) => {
      this.clearTimer("clearInterval", id);
    };
    this.setTimeout = (callback, timeout2) => this.setTimer("setTimeout", callback, timeout2);
    this.clearTimeout = (id) => {
      this.clearTimer("clearTimeout", id);
    };
    this.setTimer = (type, callback, timeout2) => {
      if (!this.ready) {
        this.setup();
      }
      if (this.fallback) {
        return (type === "setTimeout" ? setTimeout : setInterval)(callback, timeout2);
      }
      const id = this.getTimerId();
      this.callbacks.set(id, () => {
        callback();
        if (type === "setTimeout") {
          this.callbacks.delete(id);
        }
      });
      this.sendMessage({ type, id, timeout: timeout2 });
      return id;
    };
    this.clearTimer = (type, id) => {
      if (!id) {
        return;
      }
      if (!this.ready) {
        this.setup();
      }
      if (this.fallback) {
        (type === "clearTimeout" ? clearTimeout : clearInterval)(id);
        return;
      }
      this.callbacks.delete(id);
      this.sendMessage({ type, id });
    };
    this.getTimerId = () => this.currentTimerId++;
    this.sendMessage = (message) => {
      if (!this.worker) {
        throw new Error("Cannot use timer worker before it's set up");
      }
      this.worker.postMessage(message);
    };
    this.setup(init);
  }
  get ready() {
    return this.fallback || Boolean(this.worker);
  }
};

// node_modules/@stream-io/video-client/dist/index.browser.es.js
var AudioSettingsRequestDefaultDeviceEnum = {
  SPEAKER: "speaker",
  EARPIECE: "earpiece"
};
var AudioSettingsResponseDefaultDeviceEnum = {
  SPEAKER: "speaker",
  EARPIECE: "earpiece"
};
var CreateDeviceRequestPushProviderEnum = {
  FIREBASE: "firebase",
  APN: "apn",
  HUAWEI: "huawei",
  XIAOMI: "xiaomi"
};
var FrameRecordingSettingsRequestModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var FrameRecordingSettingsRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p"
};
var FrameRecordingSettingsResponseModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var IngressAudioEncodingOptionsRequestChannelsEnum = {
  NUMBER_1: 1,
  NUMBER_2: 2
};
var IngressSourceRequestFpsEnum = {
  NUMBER_30: 30,
  NUMBER_60: 60
};
var IngressVideoLayerRequestCodecEnum = {
  H264: "h264",
  VP8: "vp8"
};
var LayoutSettingsRequestNameEnum = {
  SPOTLIGHT: "spotlight",
  GRID: "grid",
  SINGLE_PARTICIPANT: "single-participant",
  MOBILE: "mobile",
  CUSTOM: "custom"
};
var NoiseCancellationSettingsModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var OwnCapability = {
  BLOCK_USERS: "block-users",
  CHANGE_MAX_DURATION: "change-max-duration",
  CREATE_CALL: "create-call",
  CREATE_REACTION: "create-reaction",
  ENABLE_NOISE_CANCELLATION: "enable-noise-cancellation",
  END_CALL: "end-call",
  JOIN_BACKSTAGE: "join-backstage",
  JOIN_CALL: "join-call",
  JOIN_ENDED_CALL: "join-ended-call",
  KICK_USER: "kick-user",
  MUTE_USERS: "mute-users",
  PIN_FOR_EVERYONE: "pin-for-everyone",
  READ_CALL: "read-call",
  REMOVE_CALL_MEMBER: "remove-call-member",
  SCREENSHARE: "screenshare",
  SEND_AUDIO: "send-audio",
  SEND_CLOSED_CAPTIONS_CALL: "send-closed-captions-call",
  SEND_VIDEO: "send-video",
  START_BROADCAST_CALL: "start-broadcast-call",
  START_CLOSED_CAPTIONS_CALL: "start-closed-captions-call",
  START_FRAME_RECORD_CALL: "start-frame-record-call",
  START_RECORD_CALL: "start-record-call",
  START_TRANSCRIPTION_CALL: "start-transcription-call",
  STOP_BROADCAST_CALL: "stop-broadcast-call",
  STOP_CLOSED_CAPTIONS_CALL: "stop-closed-captions-call",
  STOP_FRAME_RECORD_CALL: "stop-frame-record-call",
  STOP_RECORD_CALL: "stop-record-call",
  STOP_TRANSCRIPTION_CALL: "stop-transcription-call",
  UPDATE_CALL: "update-call",
  UPDATE_CALL_MEMBER: "update-call-member",
  UPDATE_CALL_PERMISSIONS: "update-call-permissions",
  UPDATE_CALL_SETTINGS: "update-call-settings"
};
var RTMPBroadcastRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p",
  PORTRAIT_360X640: "portrait-360x640",
  PORTRAIT_480X854: "portrait-480x854",
  PORTRAIT_720X1280: "portrait-720x1280",
  PORTRAIT_1080X1920: "portrait-1080x1920",
  PORTRAIT_1440X2560: "portrait-1440x2560"
};
var RTMPSettingsRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p",
  PORTRAIT_360X640: "portrait-360x640",
  PORTRAIT_480X854: "portrait-480x854",
  PORTRAIT_720X1280: "portrait-720x1280",
  PORTRAIT_1080X1920: "portrait-1080x1920",
  PORTRAIT_1440X2560: "portrait-1440x2560"
};
var RecordSettingsRequestModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var RecordSettingsRequestQualityEnum = {
  _360P: "360p",
  _480P: "480p",
  _720P: "720p",
  _1080P: "1080p",
  _1440P: "1440p",
  PORTRAIT_360X640: "portrait-360x640",
  PORTRAIT_480X854: "portrait-480x854",
  PORTRAIT_720X1280: "portrait-720x1280",
  PORTRAIT_1080X1920: "portrait-1080x1920",
  PORTRAIT_1440X2560: "portrait-1440x2560"
};
var StartClosedCaptionsRequestLanguageEnum = {
  AUTO: "auto",
  EN: "en",
  FR: "fr",
  ES: "es",
  DE: "de",
  IT: "it",
  NL: "nl",
  PT: "pt",
  PL: "pl",
  CA: "ca",
  CS: "cs",
  DA: "da",
  EL: "el",
  FI: "fi",
  ID: "id",
  JA: "ja",
  RU: "ru",
  SV: "sv",
  TA: "ta",
  TH: "th",
  TR: "tr",
  HU: "hu",
  RO: "ro",
  ZH: "zh",
  AR: "ar",
  TL: "tl",
  HE: "he",
  HI: "hi",
  HR: "hr",
  KO: "ko",
  MS: "ms",
  NO: "no",
  UK: "uk",
  BG: "bg",
  ET: "et",
  SL: "sl",
  SK: "sk"
};
var StartTranscriptionRequestLanguageEnum = {
  AUTO: "auto",
  EN: "en",
  FR: "fr",
  ES: "es",
  DE: "de",
  IT: "it",
  NL: "nl",
  PT: "pt",
  PL: "pl",
  CA: "ca",
  CS: "cs",
  DA: "da",
  EL: "el",
  FI: "fi",
  ID: "id",
  JA: "ja",
  RU: "ru",
  SV: "sv",
  TA: "ta",
  TH: "th",
  TR: "tr",
  HU: "hu",
  RO: "ro",
  ZH: "zh",
  AR: "ar",
  TL: "tl",
  HE: "he",
  HI: "hi",
  HR: "hr",
  KO: "ko",
  MS: "ms",
  NO: "no",
  UK: "uk",
  BG: "bg",
  ET: "et",
  SL: "sl",
  SK: "sk"
};
var TranscriptionSettingsRequestClosedCaptionModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var TranscriptionSettingsRequestLanguageEnum = {
  AUTO: "auto",
  EN: "en",
  FR: "fr",
  ES: "es",
  DE: "de",
  IT: "it",
  NL: "nl",
  PT: "pt",
  PL: "pl",
  CA: "ca",
  CS: "cs",
  DA: "da",
  EL: "el",
  FI: "fi",
  ID: "id",
  JA: "ja",
  RU: "ru",
  SV: "sv",
  TA: "ta",
  TH: "th",
  TR: "tr",
  HU: "hu",
  RO: "ro",
  ZH: "zh",
  AR: "ar",
  TL: "tl",
  HE: "he",
  HI: "hi",
  HR: "hr",
  KO: "ko",
  MS: "ms",
  NO: "no",
  UK: "uk",
  BG: "bg",
  ET: "et",
  SL: "sl",
  SK: "sk"
};
var TranscriptionSettingsRequestModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var TranscriptionSettingsResponseClosedCaptionModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var TranscriptionSettingsResponseLanguageEnum = {
  AUTO: "auto",
  EN: "en",
  FR: "fr",
  ES: "es",
  DE: "de",
  IT: "it",
  NL: "nl",
  PT: "pt",
  PL: "pl",
  CA: "ca",
  CS: "cs",
  DA: "da",
  EL: "el",
  FI: "fi",
  ID: "id",
  JA: "ja",
  RU: "ru",
  SV: "sv",
  TA: "ta",
  TH: "th",
  TR: "tr",
  HU: "hu",
  RO: "ro",
  ZH: "zh",
  AR: "ar",
  TL: "tl",
  HE: "he",
  HI: "hi",
  HR: "hr",
  KO: "ko",
  MS: "ms",
  NO: "no",
  UK: "uk",
  BG: "bg",
  ET: "et",
  SL: "sl",
  SK: "sk"
};
var TranscriptionSettingsResponseModeEnum = {
  AVAILABLE: "available",
  DISABLED: "disabled",
  AUTO_ON: "auto-on"
};
var VideoSettingsRequestCameraFacingEnum = {
  FRONT: "front",
  BACK: "back",
  EXTERNAL: "external"
};
var VideoSettingsResponseCameraFacingEnum = {
  FRONT: "front",
  BACK: "back",
  EXTERNAL: "external"
};
var ErrorFromResponse = class extends Error {
  constructor({ message, code, status, response, unrecoverable }) {
    super(message);
    this.name = "ErrorFromResponse";
    this.code = code;
    this.response = response;
    this.status = status;
    this.unrecoverable = unrecoverable;
  }
  // Vitest helper (serialized errors are too large to read)
  // https://github.com/vitest-dev/vitest/blob/v3.1.3/packages/utils/src/error.ts#L60-L62
  toJSON() {
    const extra = [
      ["status", this.status],
      ["code", this.code],
      ["unrecoverable", this.unrecoverable]
    ];
    const joinable = [];
    for (const [key, value] of extra) {
      if (typeof value !== "undefined" && value !== null) {
        joinable.push(`${key}: ${value}`);
      }
    }
    return {
      message: `(${joinable.join(", ")}) - ${this.message}`,
      stack: this.stack,
      name: this.name
    };
  }
};
var NullValue;
(function(NullValue2) {
  NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
})(NullValue || (NullValue = {}));
var Struct$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Struct", [
      {
        no: 1,
        name: "fields",
        kind: "map",
        K: 9,
        V: { kind: "message", T: () => Value }
      }
    ]);
  }
  /**
   * Encode `Struct` to JSON object.
   */
  internalJsonWrite(message, options) {
    let json = {};
    for (let [k2, v2] of Object.entries(message.fields)) {
      json[k2] = Value.toJson(v2);
    }
    return json;
  }
  /**
   * Decode `Struct` from JSON object.
   */
  internalJsonRead(json, options, target) {
    if (!isJsonObject(json))
      throw new globalThis.Error("Unable to parse message " + this.typeName + " from JSON " + typeofJsonValue(json) + ".");
    if (!target)
      target = this.create();
    for (let [k2, v2] of globalThis.Object.entries(json)) {
      target.fields[k2] = Value.fromJson(v2);
    }
    return target;
  }
};
var Struct = new Struct$Type();
var Value$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Value", [
      {
        no: 1,
        name: "null_value",
        kind: "enum",
        oneof: "kind",
        T: () => ["google.protobuf.NullValue", NullValue]
      },
      {
        no: 2,
        name: "number_value",
        kind: "scalar",
        oneof: "kind",
        T: 1
      },
      {
        no: 3,
        name: "string_value",
        kind: "scalar",
        oneof: "kind",
        T: 9
      },
      {
        no: 4,
        name: "bool_value",
        kind: "scalar",
        oneof: "kind",
        T: 8
      },
      {
        no: 5,
        name: "struct_value",
        kind: "message",
        oneof: "kind",
        T: () => Struct
      },
      {
        no: 6,
        name: "list_value",
        kind: "message",
        oneof: "kind",
        T: () => ListValue
      }
    ]);
  }
  /**
   * Encode `Value` to JSON value.
   */
  internalJsonWrite(message, options) {
    if (message.kind.oneofKind === void 0)
      throw new globalThis.Error();
    switch (message.kind.oneofKind) {
      case void 0:
        throw new globalThis.Error();
      case "boolValue":
        return message.kind.boolValue;
      case "nullValue":
        return null;
      case "numberValue":
        let numberValue = message.kind.numberValue;
        if (typeof numberValue == "number" && !Number.isFinite(numberValue))
          throw new globalThis.Error();
        return numberValue;
      case "stringValue":
        return message.kind.stringValue;
      case "listValue":
        let listValueField = this.fields.find((f) => f.no === 6);
        if (listValueField?.kind !== "message")
          throw new globalThis.Error();
        return listValueField.T().toJson(message.kind.listValue);
      case "structValue":
        let structValueField = this.fields.find((f) => f.no === 5);
        if (structValueField?.kind !== "message")
          throw new globalThis.Error();
        return structValueField.T().toJson(message.kind.structValue);
    }
  }
  /**
   * Decode `Value` from JSON value.
   */
  internalJsonRead(json, options, target) {
    if (!target)
      target = this.create();
    switch (typeof json) {
      case "number":
        target.kind = { oneofKind: "numberValue", numberValue: json };
        break;
      case "string":
        target.kind = { oneofKind: "stringValue", stringValue: json };
        break;
      case "boolean":
        target.kind = { oneofKind: "boolValue", boolValue: json };
        break;
      case "object":
        if (json === null) {
          target.kind = {
            oneofKind: "nullValue",
            nullValue: NullValue.NULL_VALUE
          };
        } else if (globalThis.Array.isArray(json)) {
          target.kind = {
            oneofKind: "listValue",
            listValue: ListValue.fromJson(json)
          };
        } else {
          target.kind = {
            oneofKind: "structValue",
            structValue: Struct.fromJson(json)
          };
        }
        break;
      default:
        throw new globalThis.Error("Unable to parse " + this.typeName + " from JSON " + typeofJsonValue(json));
    }
    return target;
  }
};
var Value = new Value$Type();
var ListValue$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.ListValue", [
      {
        no: 1,
        name: "values",
        kind: "message",
        repeat: 2,
        T: () => Value
      }
    ]);
  }
  /**
   * Encode `ListValue` to JSON array.
   */
  internalJsonWrite(message, options) {
    return message.values.map((v2) => Value.toJson(v2));
  }
  /**
   * Decode `ListValue` from JSON array.
   */
  internalJsonRead(json, options, target) {
    if (!globalThis.Array.isArray(json))
      throw new globalThis.Error("Unable to parse " + this.typeName + " from JSON " + typeofJsonValue(json));
    if (!target)
      target = this.create();
    let values = json.map((v2) => Value.fromJson(v2));
    target.values.push(...values);
    return target;
  }
};
var ListValue = new ListValue$Type();
var Timestamp$Type = class extends MessageType {
  constructor() {
    super("google.protobuf.Timestamp", [
      {
        no: 1,
        name: "seconds",
        kind: "scalar",
        T: 3
        /*ScalarType.INT64*/
      },
      {
        no: 2,
        name: "nanos",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
  /**
   * Creates a new `Timestamp` for the current time.
   */
  now() {
    const msg = this.create();
    const ms2 = Date.now();
    msg.seconds = PbLong.from(Math.floor(ms2 / 1e3)).toString();
    msg.nanos = ms2 % 1e3 * 1e6;
    return msg;
  }
  /**
   * Converts a `Timestamp` to a JavaScript Date.
   */
  toDate(message) {
    return new Date(PbLong.from(message.seconds).toNumber() * 1e3 + Math.ceil(message.nanos / 1e6));
  }
  /**
   * Converts a JavaScript Date to a `Timestamp`.
   */
  fromDate(date) {
    const msg = this.create();
    const ms2 = date.getTime();
    msg.seconds = PbLong.from(Math.floor(ms2 / 1e3)).toString();
    msg.nanos = (ms2 % 1e3 + (ms2 < 0 && ms2 % 1e3 !== 0 ? 1e3 : 0)) * 1e6;
    return msg;
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonWrite(message, options) {
    let ms2 = PbLong.from(message.seconds).toNumber() * 1e3;
    if (ms2 < Date.parse("0001-01-01T00:00:00Z") || ms2 > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    if (message.nanos < 0)
      throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
    let z2 = "Z";
    if (message.nanos > 0) {
      let nanosStr = (message.nanos + 1e9).toString().substring(1);
      if (nanosStr.substring(3) === "000000")
        z2 = "." + nanosStr.substring(0, 3) + "Z";
      else if (nanosStr.substring(6) === "000")
        z2 = "." + nanosStr.substring(0, 6) + "Z";
      else
        z2 = "." + nanosStr + "Z";
    }
    return new Date(ms2).toISOString().replace(".000Z", z2);
  }
  /**
   * In JSON format, the `Timestamp` type is encoded as a string
   * in the RFC 3339 format.
   */
  internalJsonRead(json, options, target) {
    if (typeof json !== "string")
      throw new Error("Unable to parse Timestamp from JSON " + typeofJsonValue(json) + ".");
    let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!matches)
      throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
    let ms2 = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
    if (Number.isNaN(ms2))
      throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
    if (ms2 < Date.parse("0001-01-01T00:00:00Z") || ms2 > Date.parse("9999-12-31T23:59:59Z"))
      throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
    if (!target)
      target = this.create();
    target.seconds = PbLong.from(ms2 / 1e3).toString();
    target.nanos = 0;
    if (matches[7])
      target.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
    return target;
  }
};
var Timestamp = new Timestamp$Type();
var PeerType;
(function(PeerType2) {
  PeerType2[PeerType2["PUBLISHER_UNSPECIFIED"] = 0] = "PUBLISHER_UNSPECIFIED";
  PeerType2[PeerType2["SUBSCRIBER"] = 1] = "SUBSCRIBER";
})(PeerType || (PeerType = {}));
var ConnectionQuality;
(function(ConnectionQuality2) {
  ConnectionQuality2[ConnectionQuality2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  ConnectionQuality2[ConnectionQuality2["POOR"] = 1] = "POOR";
  ConnectionQuality2[ConnectionQuality2["GOOD"] = 2] = "GOOD";
  ConnectionQuality2[ConnectionQuality2["EXCELLENT"] = 3] = "EXCELLENT";
})(ConnectionQuality || (ConnectionQuality = {}));
var VideoQuality;
(function(VideoQuality2) {
  VideoQuality2[VideoQuality2["LOW_UNSPECIFIED"] = 0] = "LOW_UNSPECIFIED";
  VideoQuality2[VideoQuality2["MID"] = 1] = "MID";
  VideoQuality2[VideoQuality2["HIGH"] = 2] = "HIGH";
  VideoQuality2[VideoQuality2["OFF"] = 3] = "OFF";
})(VideoQuality || (VideoQuality = {}));
var TrackType;
(function(TrackType2) {
  TrackType2[TrackType2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  TrackType2[TrackType2["AUDIO"] = 1] = "AUDIO";
  TrackType2[TrackType2["VIDEO"] = 2] = "VIDEO";
  TrackType2[TrackType2["SCREEN_SHARE"] = 3] = "SCREEN_SHARE";
  TrackType2[TrackType2["SCREEN_SHARE_AUDIO"] = 4] = "SCREEN_SHARE_AUDIO";
})(TrackType || (TrackType = {}));
var ParticipantSource;
(function(ParticipantSource2) {
  ParticipantSource2[ParticipantSource2["WEBRTC_UNSPECIFIED"] = 0] = "WEBRTC_UNSPECIFIED";
  ParticipantSource2[ParticipantSource2["RTMP"] = 1] = "RTMP";
  ParticipantSource2[ParticipantSource2["WHIP"] = 2] = "WHIP";
  ParticipantSource2[ParticipantSource2["SIP"] = 3] = "SIP";
  ParticipantSource2[ParticipantSource2["RTSP"] = 4] = "RTSP";
  ParticipantSource2[ParticipantSource2["SRT"] = 5] = "SRT";
})(ParticipantSource || (ParticipantSource = {}));
var AudioBitrateProfile;
(function(AudioBitrateProfile2) {
  AudioBitrateProfile2[AudioBitrateProfile2["VOICE_STANDARD_UNSPECIFIED"] = 0] = "VOICE_STANDARD_UNSPECIFIED";
  AudioBitrateProfile2[AudioBitrateProfile2["VOICE_HIGH_QUALITY"] = 1] = "VOICE_HIGH_QUALITY";
  AudioBitrateProfile2[AudioBitrateProfile2["MUSIC_HIGH_QUALITY"] = 2] = "MUSIC_HIGH_QUALITY";
})(AudioBitrateProfile || (AudioBitrateProfile = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  ErrorCode2[ErrorCode2["PUBLISH_TRACK_NOT_FOUND"] = 100] = "PUBLISH_TRACK_NOT_FOUND";
  ErrorCode2[ErrorCode2["PUBLISH_TRACKS_MISMATCH"] = 101] = "PUBLISH_TRACKS_MISMATCH";
  ErrorCode2[ErrorCode2["PUBLISH_TRACK_OUT_OF_ORDER"] = 102] = "PUBLISH_TRACK_OUT_OF_ORDER";
  ErrorCode2[ErrorCode2["PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND"] = 103] = "PUBLISH_TRACK_VIDEO_LAYER_NOT_FOUND";
  ErrorCode2[ErrorCode2["LIVE_ENDED"] = 104] = "LIVE_ENDED";
  ErrorCode2[ErrorCode2["PARTICIPANT_NOT_FOUND"] = 200] = "PARTICIPANT_NOT_FOUND";
  ErrorCode2[ErrorCode2["PARTICIPANT_MIGRATING_OUT"] = 201] = "PARTICIPANT_MIGRATING_OUT";
  ErrorCode2[ErrorCode2["PARTICIPANT_MIGRATION_FAILED"] = 202] = "PARTICIPANT_MIGRATION_FAILED";
  ErrorCode2[ErrorCode2["PARTICIPANT_MIGRATING"] = 203] = "PARTICIPANT_MIGRATING";
  ErrorCode2[ErrorCode2["PARTICIPANT_RECONNECT_FAILED"] = 204] = "PARTICIPANT_RECONNECT_FAILED";
  ErrorCode2[ErrorCode2["PARTICIPANT_MEDIA_TRANSPORT_FAILURE"] = 205] = "PARTICIPANT_MEDIA_TRANSPORT_FAILURE";
  ErrorCode2[ErrorCode2["PARTICIPANT_SIGNAL_LOST"] = 206] = "PARTICIPANT_SIGNAL_LOST";
  ErrorCode2[ErrorCode2["CALL_NOT_FOUND"] = 300] = "CALL_NOT_FOUND";
  ErrorCode2[ErrorCode2["CALL_PARTICIPANT_LIMIT_REACHED"] = 301] = "CALL_PARTICIPANT_LIMIT_REACHED";
  ErrorCode2[ErrorCode2["REQUEST_VALIDATION_FAILED"] = 400] = "REQUEST_VALIDATION_FAILED";
  ErrorCode2[ErrorCode2["UNAUTHENTICATED"] = 401] = "UNAUTHENTICATED";
  ErrorCode2[ErrorCode2["PERMISSION_DENIED"] = 403] = "PERMISSION_DENIED";
  ErrorCode2[ErrorCode2["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
  ErrorCode2[ErrorCode2["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
  ErrorCode2[ErrorCode2["SFU_SHUTTING_DOWN"] = 600] = "SFU_SHUTTING_DOWN";
  ErrorCode2[ErrorCode2["SFU_FULL"] = 700] = "SFU_FULL";
})(ErrorCode || (ErrorCode = {}));
var SdkType;
(function(SdkType2) {
  SdkType2[SdkType2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  SdkType2[SdkType2["REACT"] = 1] = "REACT";
  SdkType2[SdkType2["ANGULAR"] = 2] = "ANGULAR";
  SdkType2[SdkType2["ANDROID"] = 3] = "ANDROID";
  SdkType2[SdkType2["IOS"] = 4] = "IOS";
  SdkType2[SdkType2["FLUTTER"] = 5] = "FLUTTER";
  SdkType2[SdkType2["REACT_NATIVE"] = 6] = "REACT_NATIVE";
  SdkType2[SdkType2["UNITY"] = 7] = "UNITY";
  SdkType2[SdkType2["GO"] = 8] = "GO";
  SdkType2[SdkType2["PLAIN_JAVASCRIPT"] = 9] = "PLAIN_JAVASCRIPT";
})(SdkType || (SdkType = {}));
var TrackUnpublishReason;
(function(TrackUnpublishReason2) {
  TrackUnpublishReason2[TrackUnpublishReason2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  TrackUnpublishReason2[TrackUnpublishReason2["USER_MUTED"] = 1] = "USER_MUTED";
  TrackUnpublishReason2[TrackUnpublishReason2["PERMISSION_REVOKED"] = 2] = "PERMISSION_REVOKED";
  TrackUnpublishReason2[TrackUnpublishReason2["MODERATION"] = 3] = "MODERATION";
})(TrackUnpublishReason || (TrackUnpublishReason = {}));
var GoAwayReason;
(function(GoAwayReason2) {
  GoAwayReason2[GoAwayReason2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  GoAwayReason2[GoAwayReason2["SHUTTING_DOWN"] = 1] = "SHUTTING_DOWN";
  GoAwayReason2[GoAwayReason2["REBALANCE"] = 2] = "REBALANCE";
})(GoAwayReason || (GoAwayReason = {}));
var CallEndedReason;
(function(CallEndedReason2) {
  CallEndedReason2[CallEndedReason2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  CallEndedReason2[CallEndedReason2["ENDED"] = 1] = "ENDED";
  CallEndedReason2[CallEndedReason2["LIVE_ENDED"] = 2] = "LIVE_ENDED";
  CallEndedReason2[CallEndedReason2["KICKED"] = 3] = "KICKED";
  CallEndedReason2[CallEndedReason2["SESSION_ENDED"] = 4] = "SESSION_ENDED";
})(CallEndedReason || (CallEndedReason = {}));
var WebsocketReconnectStrategy;
(function(WebsocketReconnectStrategy2) {
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["DISCONNECT"] = 1] = "DISCONNECT";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["FAST"] = 2] = "FAST";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["REJOIN"] = 3] = "REJOIN";
  WebsocketReconnectStrategy2[WebsocketReconnectStrategy2["MIGRATE"] = 4] = "MIGRATE";
})(WebsocketReconnectStrategy || (WebsocketReconnectStrategy = {}));
var AndroidThermalState;
(function(AndroidThermalState2) {
  AndroidThermalState2[AndroidThermalState2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  AndroidThermalState2[AndroidThermalState2["NONE"] = 1] = "NONE";
  AndroidThermalState2[AndroidThermalState2["LIGHT"] = 2] = "LIGHT";
  AndroidThermalState2[AndroidThermalState2["MODERATE"] = 3] = "MODERATE";
  AndroidThermalState2[AndroidThermalState2["SEVERE"] = 4] = "SEVERE";
  AndroidThermalState2[AndroidThermalState2["CRITICAL"] = 5] = "CRITICAL";
  AndroidThermalState2[AndroidThermalState2["EMERGENCY"] = 6] = "EMERGENCY";
  AndroidThermalState2[AndroidThermalState2["SHUTDOWN"] = 7] = "SHUTDOWN";
})(AndroidThermalState || (AndroidThermalState = {}));
var AppleThermalState;
(function(AppleThermalState2) {
  AppleThermalState2[AppleThermalState2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  AppleThermalState2[AppleThermalState2["NOMINAL"] = 1] = "NOMINAL";
  AppleThermalState2[AppleThermalState2["FAIR"] = 2] = "FAIR";
  AppleThermalState2[AppleThermalState2["SERIOUS"] = 3] = "SERIOUS";
  AppleThermalState2[AppleThermalState2["CRITICAL"] = 4] = "CRITICAL";
})(AppleThermalState || (AppleThermalState = {}));
var ClientCapability;
(function(ClientCapability2) {
  ClientCapability2[ClientCapability2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
  ClientCapability2[ClientCapability2["SUBSCRIBER_VIDEO_PAUSE"] = 1] = "SUBSCRIBER_VIDEO_PAUSE";
})(ClientCapability || (ClientCapability = {}));
var CallState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.CallState", [
      {
        no: 1,
        name: "participants",
        kind: "message",
        repeat: 2,
        T: () => Participant
      },
      { no: 2, name: "started_at", kind: "message", T: () => Timestamp },
      {
        no: 3,
        name: "participant_count",
        kind: "message",
        T: () => ParticipantCount
      },
      {
        no: 4,
        name: "pins",
        kind: "message",
        repeat: 2,
        T: () => Pin
      }
    ]);
  }
};
var CallState$1 = new CallState$Type();
var ParticipantCount$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.ParticipantCount", [
      {
        no: 1,
        name: "total",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "anonymous",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
};
var ParticipantCount = new ParticipantCount$Type();
var Pin$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Pin", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Pin = new Pin$Type();
var Participant$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Participant", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "published_tracks",
        kind: "enum",
        repeat: 1,
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 4, name: "joined_at", kind: "message", T: () => Timestamp },
      {
        no: 5,
        name: "track_lookup_prefix",
        kind: "scalar",
        T: 9
      },
      {
        no: 6,
        name: "connection_quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ConnectionQuality",
          ConnectionQuality,
          "CONNECTION_QUALITY_"
        ]
      },
      {
        no: 7,
        name: "is_speaking",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "is_dominant_speaker",
        kind: "scalar",
        T: 8
      },
      {
        no: 9,
        name: "audio_level",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 10,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 11,
        name: "image",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 12, name: "custom", kind: "message", T: () => Struct },
      {
        no: 13,
        name: "roles",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 14,
        name: "source",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ParticipantSource",
          ParticipantSource,
          "PARTICIPANT_SOURCE_"
        ]
      }
    ]);
  }
};
var Participant = new Participant$Type();
var StreamQuality$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.StreamQuality", [
      {
        no: 1,
        name: "video_quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.VideoQuality",
          VideoQuality,
          "VIDEO_QUALITY_"
        ]
      },
      {
        no: 2,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var StreamQuality = new StreamQuality$Type();
var VideoDimension$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.VideoDimension", [
      {
        no: 1,
        name: "width",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "height",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      }
    ]);
  }
};
var VideoDimension = new VideoDimension$Type();
var VideoLayer$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.VideoLayer", [
      {
        no: 1,
        name: "rid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "video_dimension",
        kind: "message",
        T: () => VideoDimension
      },
      {
        no: 4,
        name: "bitrate",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 5,
        name: "fps",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 6,
        name: "quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.VideoQuality",
          VideoQuality,
          "VIDEO_QUALITY_"
        ]
      }
    ]);
  }
};
var VideoLayer = new VideoLayer$Type();
var SubscribeOption$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.SubscribeOption", [
      {
        no: 1,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 2,
        name: "codecs",
        kind: "message",
        repeat: 2,
        T: () => Codec
      }
    ]);
  }
};
var SubscribeOption = new SubscribeOption$Type();
var PublishOption$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.PublishOption", [
      {
        no: 1,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 2, name: "codec", kind: "message", T: () => Codec },
      {
        no: 3,
        name: "bitrate",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "fps",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 5,
        name: "max_spatial_layers",
        kind: "scalar",
        T: 5
      },
      {
        no: 6,
        name: "max_temporal_layers",
        kind: "scalar",
        T: 5
      },
      {
        no: 7,
        name: "video_dimension",
        kind: "message",
        T: () => VideoDimension
      },
      {
        no: 8,
        name: "id",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 9,
        name: "use_single_layer",
        kind: "scalar",
        T: 8
      },
      {
        no: 10,
        name: "audio_bitrate_profiles",
        kind: "message",
        repeat: 2,
        T: () => AudioBitrate
      }
    ]);
  }
};
var PublishOption = new PublishOption$Type();
var Codec$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Codec", [
      {
        no: 16,
        name: "payload_type",
        kind: "scalar",
        T: 13
      },
      {
        no: 10,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 14,
        name: "clock_rate",
        kind: "scalar",
        T: 13
      },
      {
        no: 15,
        name: "encoding_parameters",
        kind: "scalar",
        T: 9
      },
      {
        no: 12,
        name: "fmtp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Codec = new Codec$Type();
var ICETrickle$Type$1 = class ICETrickle$Type extends MessageType {
  constructor() {
    super("stream.video.sfu.models.ICETrickle", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      },
      {
        no: 2,
        name: "ice_candidate",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ICETrickle$1 = new ICETrickle$Type$1();
var AudioBitrate$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.AudioBitrate", [
      {
        no: 1,
        name: "profile",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.AudioBitrateProfile",
          AudioBitrateProfile,
          "AUDIO_BITRATE_PROFILE_"
        ]
      },
      {
        no: 2,
        name: "bitrate",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      }
    ]);
  }
};
var AudioBitrate = new AudioBitrate$Type();
var TrackInfo$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.TrackInfo", [
      {
        no: 1,
        name: "track_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 5,
        name: "layers",
        kind: "message",
        repeat: 2,
        T: () => VideoLayer
      },
      {
        no: 6,
        name: "mid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "dtx",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 8,
        name: "stereo",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 9,
        name: "red",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 10,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 11, name: "codec", kind: "message", T: () => Codec },
      {
        no: 12,
        name: "publish_option_id",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var TrackInfo = new TrackInfo$Type();
var Error$Type$1 = class Error$Type extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Error", [
      {
        no: 1,
        name: "code",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ErrorCode",
          ErrorCode,
          "ERROR_CODE_"
        ]
      },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "should_retry",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var Error$2 = new Error$Type$1();
var ClientDetails$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.ClientDetails", [
      { no: 1, name: "sdk", kind: "message", T: () => Sdk },
      { no: 2, name: "os", kind: "message", T: () => OS },
      { no: 3, name: "browser", kind: "message", T: () => Browser },
      { no: 4, name: "device", kind: "message", T: () => Device }
    ]);
  }
};
var ClientDetails = new ClientDetails$Type();
var Sdk$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Sdk", [
      {
        no: 1,
        name: "type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.SdkType", SdkType, "SDK_TYPE_"]
      },
      {
        no: 2,
        name: "major",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "minor",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 4,
        name: "patch",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Sdk = new Sdk$Type();
var OS$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.OS", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "architecture",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var OS = new OS$Type();
var Browser$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Browser", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Browser = new Browser$Type();
var RTMPIngress$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.RTMPIngress", [
      {
        no: 1,
        name: "width",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 2,
        name: "height",
        kind: "scalar",
        T: 13
        /*ScalarType.UINT32*/
      },
      {
        no: 3,
        name: "frame_rate",
        kind: "scalar",
        T: 1
        /*ScalarType.DOUBLE*/
      },
      {
        no: 4,
        name: "software",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 5,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "encoder",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 7,
        name: "remote_addr",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var RTMPIngress = new RTMPIngress$Type();
var Device$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Device", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "version",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var Device = new Device$Type();
var Call$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.Call", [
      {
        no: 1,
        name: "type",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "created_by_user_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "host_user_id",
        kind: "scalar",
        T: 9
      },
      { no: 5, name: "custom", kind: "message", T: () => Struct },
      { no: 6, name: "created_at", kind: "message", T: () => Timestamp },
      { no: 7, name: "updated_at", kind: "message", T: () => Timestamp }
    ]);
  }
};
var Call$1 = new Call$Type();
var CallGrants$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.CallGrants", [
      {
        no: 1,
        name: "can_publish_audio",
        kind: "scalar",
        T: 8
      },
      {
        no: 2,
        name: "can_publish_video",
        kind: "scalar",
        T: 8
      },
      {
        no: 3,
        name: "can_screenshare",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var CallGrants = new CallGrants$Type();
var InputDevices$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.InputDevices", [
      {
        no: 1,
        name: "available_devices",
        kind: "scalar",
        repeat: 2,
        T: 9
      },
      {
        no: 2,
        name: "current_device",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "is_permitted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var InputDevices = new InputDevices$Type();
var AndroidState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.AndroidState", [
      {
        no: 1,
        name: "thermal_state",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.AndroidThermalState",
          AndroidThermalState,
          "ANDROID_THERMAL_STATE_"
        ]
      },
      {
        no: 2,
        name: "is_power_saver_mode",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var AndroidState = new AndroidState$Type();
var AppleState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.AppleState", [
      {
        no: 1,
        name: "thermal_state",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.AppleThermalState",
          AppleThermalState,
          "APPLE_THERMAL_STATE_"
        ]
      },
      {
        no: 2,
        name: "is_low_power_mode_enabled",
        kind: "scalar",
        T: 8
      }
    ]);
  }
};
var AppleState = new AppleState$Type();
var PerformanceStats$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.models.PerformanceStats", [
      {
        no: 1,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 2, name: "codec", kind: "message", T: () => Codec },
      {
        no: 3,
        name: "avg_frame_time_ms",
        kind: "scalar",
        T: 2
      },
      {
        no: 4,
        name: "avg_fps",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 5,
        name: "video_dimension",
        kind: "message",
        T: () => VideoDimension
      },
      {
        no: 6,
        name: "target_bitrate",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var PerformanceStats = new PerformanceStats$Type();
var models = Object.freeze({
  __proto__: null,
  AndroidState,
  get AndroidThermalState() {
    return AndroidThermalState;
  },
  AppleState,
  get AppleThermalState() {
    return AppleThermalState;
  },
  AudioBitrate,
  get AudioBitrateProfile() {
    return AudioBitrateProfile;
  },
  Browser,
  Call: Call$1,
  get CallEndedReason() {
    return CallEndedReason;
  },
  CallGrants,
  CallState: CallState$1,
  get ClientCapability() {
    return ClientCapability;
  },
  ClientDetails,
  Codec,
  get ConnectionQuality() {
    return ConnectionQuality;
  },
  Device,
  Error: Error$2,
  get ErrorCode() {
    return ErrorCode;
  },
  get GoAwayReason() {
    return GoAwayReason;
  },
  ICETrickle: ICETrickle$1,
  InputDevices,
  OS,
  Participant,
  ParticipantCount,
  get ParticipantSource() {
    return ParticipantSource;
  },
  get PeerType() {
    return PeerType;
  },
  PerformanceStats,
  Pin,
  PublishOption,
  RTMPIngress,
  Sdk,
  get SdkType() {
    return SdkType;
  },
  StreamQuality,
  SubscribeOption,
  TrackInfo,
  get TrackType() {
    return TrackType;
  },
  get TrackUnpublishReason() {
    return TrackUnpublishReason;
  },
  VideoDimension,
  VideoLayer,
  get VideoQuality() {
    return VideoQuality;
  },
  get WebsocketReconnectStrategy() {
    return WebsocketReconnectStrategy;
  }
});
var StartNoiseCancellationRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StartNoiseCancellationRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var StartNoiseCancellationRequest = new StartNoiseCancellationRequest$Type();
var StartNoiseCancellationResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StartNoiseCancellationResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var StartNoiseCancellationResponse = new StartNoiseCancellationResponse$Type();
var StopNoiseCancellationRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StopNoiseCancellationRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var StopNoiseCancellationRequest = new StopNoiseCancellationRequest$Type();
var StopNoiseCancellationResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.StopNoiseCancellationResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var StopNoiseCancellationResponse = new StopNoiseCancellationResponse$Type();
var Reconnection$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.Reconnection", [
      {
        no: 1,
        name: "time_seconds",
        kind: "scalar",
        T: 2
      },
      {
        no: 2,
        name: "strategy",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.WebsocketReconnectStrategy",
          WebsocketReconnectStrategy,
          "WEBSOCKET_RECONNECT_STRATEGY_"
        ]
      }
    ]);
  }
};
var Reconnection = new Reconnection$Type();
var Telemetry$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.Telemetry", [
      {
        no: 1,
        name: "connection_time_seconds",
        kind: "scalar",
        oneof: "data",
        T: 2
      },
      {
        no: 2,
        name: "reconnection",
        kind: "message",
        oneof: "data",
        T: () => Reconnection
      }
    ]);
  }
};
var Telemetry = new Telemetry$Type();
var SendStatsRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendStatsRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "subscriber_stats",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "publisher_stats",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "webrtc_version",
        kind: "scalar",
        T: 9
      },
      {
        no: 5,
        name: "sdk",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 6,
        name: "sdk_version",
        kind: "scalar",
        T: 9
      },
      { no: 7, name: "audio_devices", kind: "message", T: () => InputDevices },
      { no: 8, name: "video_devices", kind: "message", T: () => InputDevices },
      {
        no: 9,
        name: "android",
        kind: "message",
        oneof: "deviceState",
        T: () => AndroidState
      },
      {
        no: 10,
        name: "apple",
        kind: "message",
        oneof: "deviceState",
        T: () => AppleState
      },
      { no: 11, name: "telemetry", kind: "message", T: () => Telemetry },
      { no: 12, name: "rtmp", kind: "message", T: () => RTMPIngress },
      {
        no: 13,
        name: "subscriber_rtc_stats",
        kind: "scalar",
        T: 9
      },
      {
        no: 14,
        name: "publisher_rtc_stats",
        kind: "scalar",
        T: 9
      },
      {
        no: 15,
        name: "rtc_stats",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 16,
        name: "encode_stats",
        kind: "message",
        repeat: 2,
        T: () => PerformanceStats
      },
      {
        no: 17,
        name: "decode_stats",
        kind: "message",
        repeat: 2,
        T: () => PerformanceStats
      },
      {
        no: 18,
        name: "unified_session_id",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var SendStatsRequest = new SendStatsRequest$Type();
var SendStatsResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendStatsResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var SendStatsResponse = new SendStatsResponse$Type();
var ICERestartRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.ICERestartRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      }
    ]);
  }
};
var ICERestartRequest = new ICERestartRequest$Type();
var ICERestartResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.ICERestartResponse", [
      { no: 1, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var ICERestartResponse = new ICERestartResponse$Type();
var UpdateMuteStatesRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateMuteStatesRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "mute_states",
        kind: "message",
        repeat: 2,
        T: () => TrackMuteState
      }
    ]);
  }
};
var UpdateMuteStatesRequest = new UpdateMuteStatesRequest$Type();
var UpdateMuteStatesResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateMuteStatesResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var UpdateMuteStatesResponse = new UpdateMuteStatesResponse$Type();
var TrackMuteState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.TrackMuteState", [
      {
        no: 1,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 2,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var TrackMuteState = new TrackMuteState$Type();
var AudioMuteChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.AudioMuteChanged", [
      {
        no: 1,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
new AudioMuteChanged$Type();
var VideoMuteChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.VideoMuteChanged", [
      {
        no: 2,
        name: "muted",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
new VideoMuteChanged$Type();
var UpdateSubscriptionsRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateSubscriptionsRequest", [
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "tracks",
        kind: "message",
        repeat: 2,
        T: () => TrackSubscriptionDetails
      }
    ]);
  }
};
var UpdateSubscriptionsRequest = new UpdateSubscriptionsRequest$Type();
var UpdateSubscriptionsResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.UpdateSubscriptionsResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var UpdateSubscriptionsResponse = new UpdateSubscriptionsResponse$Type();
var TrackSubscriptionDetails$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.TrackSubscriptionDetails", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 4, name: "dimension", kind: "message", T: () => VideoDimension }
    ]);
  }
};
var TrackSubscriptionDetails = new TrackSubscriptionDetails$Type();
var SendAnswerRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendAnswerRequest", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      },
      {
        no: 2,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var SendAnswerRequest = new SendAnswerRequest$Type();
var SendAnswerResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SendAnswerResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var SendAnswerResponse = new SendAnswerResponse$Type();
var ICETrickleResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.ICETrickleResponse", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var ICETrickleResponse = new ICETrickleResponse$Type();
var SetPublisherRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SetPublisherRequest", [
      {
        no: 1,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "tracks",
        kind: "message",
        repeat: 2,
        T: () => TrackInfo
      }
    ]);
  }
};
var SetPublisherRequest = new SetPublisherRequest$Type();
var SetPublisherResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.signal.SetPublisherResponse", [
      {
        no: 1,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "ice_restart",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      { no: 4, name: "error", kind: "message", T: () => Error$2 }
    ]);
  }
};
var SetPublisherResponse = new SetPublisherResponse$Type();
var SignalServer = new ServiceType("stream.video.sfu.signal.SignalServer", [
  {
    name: "SetPublisher",
    options: {},
    I: SetPublisherRequest,
    O: SetPublisherResponse
  },
  {
    name: "SendAnswer",
    options: {},
    I: SendAnswerRequest,
    O: SendAnswerResponse
  },
  { name: "IceTrickle", options: {}, I: ICETrickle$1, O: ICETrickleResponse },
  {
    name: "UpdateSubscriptions",
    options: {},
    I: UpdateSubscriptionsRequest,
    O: UpdateSubscriptionsResponse
  },
  {
    name: "UpdateMuteStates",
    options: {},
    I: UpdateMuteStatesRequest,
    O: UpdateMuteStatesResponse
  },
  {
    name: "IceRestart",
    options: {},
    I: ICERestartRequest,
    O: ICERestartResponse
  },
  {
    name: "SendStats",
    options: {},
    I: SendStatsRequest,
    O: SendStatsResponse
  },
  {
    name: "StartNoiseCancellation",
    options: {},
    I: StartNoiseCancellationRequest,
    O: StartNoiseCancellationResponse
  },
  {
    name: "StopNoiseCancellation",
    options: {},
    I: StopNoiseCancellationRequest,
    O: StopNoiseCancellationResponse
  }
]);
var SfuEvent$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.SfuEvent", [
      {
        no: 1,
        name: "subscriber_offer",
        kind: "message",
        oneof: "eventPayload",
        T: () => SubscriberOffer
      },
      {
        no: 2,
        name: "publisher_answer",
        kind: "message",
        oneof: "eventPayload",
        T: () => PublisherAnswer
      },
      {
        no: 3,
        name: "connection_quality_changed",
        kind: "message",
        oneof: "eventPayload",
        T: () => ConnectionQualityChanged
      },
      {
        no: 4,
        name: "audio_level_changed",
        kind: "message",
        oneof: "eventPayload",
        T: () => AudioLevelChanged
      },
      {
        no: 5,
        name: "ice_trickle",
        kind: "message",
        oneof: "eventPayload",
        T: () => ICETrickle$1
      },
      {
        no: 6,
        name: "change_publish_quality",
        kind: "message",
        oneof: "eventPayload",
        T: () => ChangePublishQuality
      },
      {
        no: 10,
        name: "participant_joined",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantJoined
      },
      {
        no: 11,
        name: "participant_left",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantLeft
      },
      {
        no: 12,
        name: "dominant_speaker_changed",
        kind: "message",
        oneof: "eventPayload",
        T: () => DominantSpeakerChanged
      },
      {
        no: 13,
        name: "join_response",
        kind: "message",
        oneof: "eventPayload",
        T: () => JoinResponse
      },
      {
        no: 14,
        name: "health_check_response",
        kind: "message",
        oneof: "eventPayload",
        T: () => HealthCheckResponse
      },
      {
        no: 16,
        name: "track_published",
        kind: "message",
        oneof: "eventPayload",
        T: () => TrackPublished
      },
      {
        no: 17,
        name: "track_unpublished",
        kind: "message",
        oneof: "eventPayload",
        T: () => TrackUnpublished
      },
      {
        no: 18,
        name: "error",
        kind: "message",
        oneof: "eventPayload",
        T: () => Error$1
      },
      {
        no: 19,
        name: "call_grants_updated",
        kind: "message",
        oneof: "eventPayload",
        T: () => CallGrantsUpdated
      },
      {
        no: 20,
        name: "go_away",
        kind: "message",
        oneof: "eventPayload",
        T: () => GoAway
      },
      {
        no: 21,
        name: "ice_restart",
        kind: "message",
        oneof: "eventPayload",
        T: () => ICERestart
      },
      {
        no: 22,
        name: "pins_updated",
        kind: "message",
        oneof: "eventPayload",
        T: () => PinsChanged
      },
      {
        no: 23,
        name: "call_ended",
        kind: "message",
        oneof: "eventPayload",
        T: () => CallEnded
      },
      {
        no: 24,
        name: "participant_updated",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantUpdated
      },
      {
        no: 25,
        name: "participant_migration_complete",
        kind: "message",
        oneof: "eventPayload",
        T: () => ParticipantMigrationComplete
      },
      {
        no: 27,
        name: "change_publish_options",
        kind: "message",
        oneof: "eventPayload",
        T: () => ChangePublishOptions
      },
      {
        no: 28,
        name: "inbound_state_notification",
        kind: "message",
        oneof: "eventPayload",
        T: () => InboundStateNotification
      }
    ]);
  }
};
var SfuEvent = new SfuEvent$Type();
var ChangePublishOptions$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ChangePublishOptions", [
      {
        no: 1,
        name: "publish_options",
        kind: "message",
        repeat: 2,
        T: () => PublishOption
      },
      {
        no: 2,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ChangePublishOptions = new ChangePublishOptions$Type();
var ChangePublishOptionsComplete$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ChangePublishOptionsComplete", []);
  }
};
var ChangePublishOptionsComplete = new ChangePublishOptionsComplete$Type();
var ParticipantMigrationComplete$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantMigrationComplete", []);
  }
};
var ParticipantMigrationComplete = new ParticipantMigrationComplete$Type();
var PinsChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.PinsChanged", [
      {
        no: 1,
        name: "pins",
        kind: "message",
        repeat: 2,
        T: () => Pin
      }
    ]);
  }
};
var PinsChanged = new PinsChanged$Type();
var Error$Type2 = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.Error", [
      { no: 4, name: "error", kind: "message", T: () => Error$2 },
      {
        no: 5,
        name: "reconnect_strategy",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.WebsocketReconnectStrategy",
          WebsocketReconnectStrategy,
          "WEBSOCKET_RECONNECT_STRATEGY_"
        ]
      }
    ]);
  }
};
var Error$1 = new Error$Type2();
var ICETrickle$Type2 = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ICETrickle", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      },
      {
        no: 2,
        name: "ice_candidate",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var ICETrickle = new ICETrickle$Type2();
var ICERestart$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ICERestart", [
      {
        no: 1,
        name: "peer_type",
        kind: "enum",
        T: () => ["stream.video.sfu.models.PeerType", PeerType, "PEER_TYPE_"]
      }
    ]);
  }
};
var ICERestart = new ICERestart$Type();
var SfuRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.SfuRequest", [
      {
        no: 1,
        name: "join_request",
        kind: "message",
        oneof: "requestPayload",
        T: () => JoinRequest
      },
      {
        no: 2,
        name: "health_check_request",
        kind: "message",
        oneof: "requestPayload",
        T: () => HealthCheckRequest
      },
      {
        no: 3,
        name: "leave_call_request",
        kind: "message",
        oneof: "requestPayload",
        T: () => LeaveCallRequest
      }
    ]);
  }
};
var SfuRequest = new SfuRequest$Type();
var LeaveCallRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.LeaveCallRequest", [
      {
        no: 1,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var LeaveCallRequest = new LeaveCallRequest$Type();
var HealthCheckRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.HealthCheckRequest", []);
  }
};
var HealthCheckRequest = new HealthCheckRequest$Type();
var HealthCheckResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.HealthCheckResponse", [
      {
        no: 1,
        name: "participant_count",
        kind: "message",
        T: () => ParticipantCount
      }
    ]);
  }
};
var HealthCheckResponse = new HealthCheckResponse$Type();
var TrackPublished$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.TrackPublished", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      { no: 4, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var TrackPublished = new TrackPublished$Type();
var TrackUnpublished$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.TrackUnpublished", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 4,
        name: "cause",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackUnpublishReason",
          TrackUnpublishReason,
          "TRACK_UNPUBLISH_REASON_"
        ]
      },
      { no: 5, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var TrackUnpublished = new TrackUnpublished$Type();
var JoinRequest$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.JoinRequest", [
      {
        no: 1,
        name: "token",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 13,
        name: "unified_session_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 3,
        name: "subscriber_sdp",
        kind: "scalar",
        T: 9
      },
      {
        no: 8,
        name: "publisher_sdp",
        kind: "scalar",
        T: 9
      },
      {
        no: 4,
        name: "client_details",
        kind: "message",
        T: () => ClientDetails
      },
      { no: 5, name: "migration", kind: "message", T: () => Migration },
      {
        no: 6,
        name: "fast_reconnect",
        kind: "scalar",
        T: 8
      },
      {
        no: 7,
        name: "reconnect_details",
        kind: "message",
        T: () => ReconnectDetails
      },
      {
        no: 9,
        name: "preferred_publish_options",
        kind: "message",
        repeat: 2,
        T: () => PublishOption
      },
      {
        no: 10,
        name: "preferred_subscribe_options",
        kind: "message",
        repeat: 2,
        T: () => SubscribeOption
      },
      {
        no: 11,
        name: "capabilities",
        kind: "enum",
        repeat: 1,
        T: () => [
          "stream.video.sfu.models.ClientCapability",
          ClientCapability,
          "CLIENT_CAPABILITY_"
        ]
      },
      {
        no: 12,
        name: "source",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ParticipantSource",
          ParticipantSource,
          "PARTICIPANT_SOURCE_"
        ]
      }
    ]);
  }
};
var JoinRequest = new JoinRequest$Type();
var ReconnectDetails$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ReconnectDetails", [
      {
        no: 1,
        name: "strategy",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.WebsocketReconnectStrategy",
          WebsocketReconnectStrategy,
          "WEBSOCKET_RECONNECT_STRATEGY_"
        ]
      },
      {
        no: 3,
        name: "announced_tracks",
        kind: "message",
        repeat: 2,
        T: () => TrackInfo
      },
      {
        no: 4,
        name: "subscriptions",
        kind: "message",
        repeat: 2,
        T: () => TrackSubscriptionDetails
      },
      {
        no: 5,
        name: "reconnect_attempt",
        kind: "scalar",
        T: 13
      },
      {
        no: 6,
        name: "from_sfu_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 7,
        name: "previous_session_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 8,
        name: "reason",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var ReconnectDetails = new ReconnectDetails$Type();
var Migration$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.Migration", [
      {
        no: 1,
        name: "from_sfu_id",
        kind: "scalar",
        T: 9
      },
      {
        no: 2,
        name: "announced_tracks",
        kind: "message",
        repeat: 2,
        T: () => TrackInfo
      },
      {
        no: 3,
        name: "subscriptions",
        kind: "message",
        repeat: 2,
        T: () => TrackSubscriptionDetails
      }
    ]);
  }
};
var Migration = new Migration$Type();
var JoinResponse$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.JoinResponse", [
      { no: 1, name: "call_state", kind: "message", T: () => CallState$1 },
      {
        no: 2,
        name: "reconnected",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "fast_reconnect_deadline_seconds",
        kind: "scalar",
        T: 5
      },
      {
        no: 4,
        name: "publish_options",
        kind: "message",
        repeat: 2,
        T: () => PublishOption
      }
    ]);
  }
};
var JoinResponse = new JoinResponse$Type();
var ParticipantJoined$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantJoined", [
      {
        no: 1,
        name: "call_cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var ParticipantJoined = new ParticipantJoined$Type();
var ParticipantLeft$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantLeft", [
      {
        no: 1,
        name: "call_cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var ParticipantLeft = new ParticipantLeft$Type();
var ParticipantUpdated$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ParticipantUpdated", [
      {
        no: 1,
        name: "call_cid",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      { no: 2, name: "participant", kind: "message", T: () => Participant }
    ]);
  }
};
var ParticipantUpdated = new ParticipantUpdated$Type();
var SubscriberOffer$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.SubscriberOffer", [
      {
        no: 1,
        name: "ice_restart",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 2,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var SubscriberOffer = new SubscriberOffer$Type();
var PublisherAnswer$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.PublisherAnswer", [
      {
        no: 1,
        name: "sdp",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var PublisherAnswer = new PublisherAnswer$Type();
var ConnectionQualityChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ConnectionQualityChanged", [
      {
        no: 1,
        name: "connection_quality_updates",
        kind: "message",
        repeat: 2,
        T: () => ConnectionQualityInfo
      }
    ]);
  }
};
var ConnectionQualityChanged = new ConnectionQualityChanged$Type();
var ConnectionQualityInfo$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ConnectionQualityInfo", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "connection_quality",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.ConnectionQuality",
          ConnectionQuality,
          "CONNECTION_QUALITY_"
        ]
      }
    ]);
  }
};
var ConnectionQualityInfo = new ConnectionQualityInfo$Type();
var DominantSpeakerChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.DominantSpeakerChanged", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var DominantSpeakerChanged = new DominantSpeakerChanged$Type();
var AudioLevel$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.AudioLevel", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "level",
        kind: "scalar",
        T: 2
        /*ScalarType.FLOAT*/
      },
      {
        no: 4,
        name: "is_speaking",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var AudioLevel = new AudioLevel$Type();
var AudioLevelChanged$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.AudioLevelChanged", [
      {
        no: 1,
        name: "audio_levels",
        kind: "message",
        repeat: 2,
        T: () => AudioLevel
      }
    ]);
  }
};
var AudioLevelChanged = new AudioLevelChanged$Type();
var AudioSender$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.AudioSender", [
      { no: 2, name: "codec", kind: "message", T: () => Codec },
      {
        no: 3,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 4,
        name: "publish_option_id",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var AudioSender = new AudioSender$Type();
var VideoLayerSetting$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.VideoLayerSetting", [
      {
        no: 1,
        name: "name",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "active",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      },
      {
        no: 3,
        name: "max_bitrate",
        kind: "scalar",
        T: 5
        /*ScalarType.INT32*/
      },
      {
        no: 4,
        name: "scale_resolution_down_by",
        kind: "scalar",
        T: 2
      },
      { no: 6, name: "codec", kind: "message", T: () => Codec },
      {
        no: 7,
        name: "max_framerate",
        kind: "scalar",
        T: 13
      },
      {
        no: 8,
        name: "scalability_mode",
        kind: "scalar",
        T: 9
      }
    ]);
  }
};
var VideoLayerSetting = new VideoLayerSetting$Type();
var VideoSender$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.VideoSender", [
      { no: 2, name: "codec", kind: "message", T: () => Codec },
      {
        no: 3,
        name: "layers",
        kind: "message",
        repeat: 2,
        T: () => VideoLayerSetting
      },
      {
        no: 4,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 5,
        name: "publish_option_id",
        kind: "scalar",
        T: 5
      }
    ]);
  }
};
var VideoSender = new VideoSender$Type();
var ChangePublishQuality$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.ChangePublishQuality", [
      {
        no: 1,
        name: "audio_senders",
        kind: "message",
        repeat: 2,
        T: () => AudioSender
      },
      {
        no: 2,
        name: "video_senders",
        kind: "message",
        repeat: 2,
        T: () => VideoSender
      }
    ]);
  }
};
var ChangePublishQuality = new ChangePublishQuality$Type();
var CallGrantsUpdated$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.CallGrantsUpdated", [
      { no: 1, name: "current_grants", kind: "message", T: () => CallGrants },
      {
        no: 2,
        name: "message",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      }
    ]);
  }
};
var CallGrantsUpdated = new CallGrantsUpdated$Type();
var GoAway$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.GoAway", [
      {
        no: 1,
        name: "reason",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.GoAwayReason",
          GoAwayReason,
          "GO_AWAY_REASON_"
        ]
      }
    ]);
  }
};
var GoAway = new GoAway$Type();
var CallEnded$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.CallEnded", [
      {
        no: 1,
        name: "reason",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.CallEndedReason",
          CallEndedReason,
          "CALL_ENDED_REASON_"
        ]
      }
    ]);
  }
};
var CallEnded = new CallEnded$Type();
var InboundStateNotification$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.InboundStateNotification", [
      {
        no: 1,
        name: "inbound_video_states",
        kind: "message",
        repeat: 2,
        T: () => InboundVideoState
      }
    ]);
  }
};
var InboundStateNotification = new InboundStateNotification$Type();
var InboundVideoState$Type = class extends MessageType {
  constructor() {
    super("stream.video.sfu.event.InboundVideoState", [
      {
        no: 1,
        name: "user_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 2,
        name: "session_id",
        kind: "scalar",
        T: 9
        /*ScalarType.STRING*/
      },
      {
        no: 3,
        name: "track_type",
        kind: "enum",
        T: () => [
          "stream.video.sfu.models.TrackType",
          TrackType,
          "TRACK_TYPE_"
        ]
      },
      {
        no: 4,
        name: "paused",
        kind: "scalar",
        T: 8
        /*ScalarType.BOOL*/
      }
    ]);
  }
};
var InboundVideoState = new InboundVideoState$Type();
var events = Object.freeze({
  __proto__: null,
  AudioLevel,
  AudioLevelChanged,
  AudioSender,
  CallEnded,
  CallGrantsUpdated,
  ChangePublishOptions,
  ChangePublishOptionsComplete,
  ChangePublishQuality,
  ConnectionQualityChanged,
  ConnectionQualityInfo,
  DominantSpeakerChanged,
  Error: Error$1,
  GoAway,
  HealthCheckRequest,
  HealthCheckResponse,
  ICERestart,
  ICETrickle,
  InboundStateNotification,
  InboundVideoState,
  JoinRequest,
  JoinResponse,
  LeaveCallRequest,
  Migration,
  ParticipantJoined,
  ParticipantLeft,
  ParticipantMigrationComplete,
  ParticipantUpdated,
  PinsChanged,
  PublisherAnswer,
  ReconnectDetails,
  SfuEvent,
  SfuRequest,
  SubscriberOffer,
  TrackPublished,
  TrackUnpublished,
  VideoLayerSetting,
  VideoSender
});
var VisibilityState;
(function(VisibilityState2) {
  VisibilityState2["UNKNOWN"] = "UNKNOWN";
  VisibilityState2["VISIBLE"] = "VISIBLE";
  VisibilityState2["INVISIBLE"] = "INVISIBLE";
})(VisibilityState || (VisibilityState = {}));
var DebounceType;
(function(DebounceType2) {
  DebounceType2[DebounceType2["IMMEDIATE"] = 20] = "IMMEDIATE";
  DebounceType2[DebounceType2["FAST"] = 100] = "FAST";
  DebounceType2[DebounceType2["MEDIUM"] = 600] = "MEDIUM";
  DebounceType2[DebounceType2["SLOW"] = 1200] = "SLOW";
})(DebounceType || (DebounceType = {}));
var SignalServerClient = class {
  constructor(_transport) {
    this._transport = _transport;
    this.typeName = SignalServer.typeName;
    this.methods = SignalServer.methods;
    this.options = SignalServer.options;
  }
  /**
   * SetPublisher sends the WebRTC offer for the peer connection used to publish A/V
   *
   * @generated from protobuf rpc: SetPublisher(stream.video.sfu.signal.SetPublisherRequest) returns (stream.video.sfu.signal.SetPublisherResponse);
   */
  setPublisher(input, options) {
    const method = this.methods[0], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * answer is sent by the client to the SFU after receiving a subscriber_offer.
   *
   * @generated from protobuf rpc: SendAnswer(stream.video.sfu.signal.SendAnswerRequest) returns (stream.video.sfu.signal.SendAnswerResponse);
   */
  sendAnswer(input, options) {
    const method = this.methods[1], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * SendICECandidate sends an ICE candidate to the client
   *
   * @generated from protobuf rpc: IceTrickle(stream.video.sfu.models.ICETrickle) returns (stream.video.sfu.signal.ICETrickleResponse);
   */
  iceTrickle(input, options) {
    const method = this.methods[2], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * UpdateSubscribers is used to notify the SFU about the list of video subscriptions
   * TODO: sync subscriptions based on this + update tracks using the dimension info sent by the user
   *
   * @generated from protobuf rpc: UpdateSubscriptions(stream.video.sfu.signal.UpdateSubscriptionsRequest) returns (stream.video.sfu.signal.UpdateSubscriptionsResponse);
   */
  updateSubscriptions(input, options) {
    const method = this.methods[3], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: UpdateMuteStates(stream.video.sfu.signal.UpdateMuteStatesRequest) returns (stream.video.sfu.signal.UpdateMuteStatesResponse);
   */
  updateMuteStates(input, options) {
    const method = this.methods[4], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: IceRestart(stream.video.sfu.signal.ICERestartRequest) returns (stream.video.sfu.signal.ICERestartResponse);
   */
  iceRestart(input, options) {
    const method = this.methods[5], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: SendStats(stream.video.sfu.signal.SendStatsRequest) returns (stream.video.sfu.signal.SendStatsResponse);
   */
  sendStats(input, options) {
    const method = this.methods[6], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: StartNoiseCancellation(stream.video.sfu.signal.StartNoiseCancellationRequest) returns (stream.video.sfu.signal.StartNoiseCancellationResponse);
   */
  startNoiseCancellation(input, options) {
    const method = this.methods[7], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: StopNoiseCancellation(stream.video.sfu.signal.StopNoiseCancellationRequest) returns (stream.video.sfu.signal.StopNoiseCancellationResponse);
   */
  stopNoiseCancellation(input, options) {
    const method = this.methods[8], opt = this._transport.mergeOptions(options);
    return stackIntercept("unary", this._transport, method, opt, input);
  }
};
var defaultOptions = {
  baseUrl: "",
  sendJson: true,
  timeout: 5 * 1e3,
  // ms.
  jsonOptions: {
    ignoreUnknownFields: true
  }
};
var withHeaders = (headers) => {
  return {
    interceptUnary(next, method, input, options) {
      options.meta = { ...options.meta, ...headers };
      return next(method, input, options);
    }
  };
};
var withRequestLogger = (logger, level) => {
  return {
    interceptUnary: (next, method, input, options) => {
      const invocation = next(method, input, options);
      logger[level](`Invoked SFU RPC method ${method.name}`, {
        request: invocation.request,
        headers: invocation.requestHeaders,
        response: invocation.response
      });
      return invocation;
    }
  };
};
var withRequestTracer = (trace) => {
  const traceError = (name2, input, err) => trace(`${name2}OnFailure`, [err, input]);
  const exclusions = {
    SendStats: true
  };
  return {
    interceptUnary(next, method, input, options) {
      if (exclusions[method.name]) {
        return next(method, input, options);
      }
      trace(method.name, input);
      const unaryCall = next(method, input, options);
      unaryCall.then((invocation) => {
        const err = invocation.response?.error;
        if (err)
          traceError(method.name, input, err);
      }, (err) => traceError(method.name, input, err));
      return unaryCall;
    }
  };
};
var createSignalClient = (options) => {
  const transport = new TwirpFetchTransport({
    ...defaultOptions,
    ...options
  });
  return new SignalServerClient(transport);
};
var sleep = (m2) => new Promise((r2) => setTimeout(r2, m2));
function isFunction2(value) {
  return value && (Object.prototype.toString.call(value) === "[object Function]" || "function" === typeof value || value instanceof Function);
}
var KnownCodes = {
  TOKEN_EXPIRED: 40,
  WS_CLOSED_SUCCESS: 1e3
};
function retryInterval(numberOfFailures) {
  const max2 = Math.min(500 + numberOfFailures * 2e3, 5e3);
  const min2 = Math.min(Math.max(250, (numberOfFailures - 1) * 2e3), 5e3);
  return Math.floor(Math.random() * (max2 - min2) + min2);
}
function hex(bytes) {
  let s2 = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    s2 += bytes[i2].toString(16).padStart(2, "0");
  }
  return s2;
}
function generateUUIDv4() {
  const bytes = getRandomBytes(16);
  bytes[6] = bytes[6] & 15 | 64;
  bytes[8] = bytes[8] & 191 | 128;
  return [
    hex(bytes.subarray(0, 4)),
    hex(bytes.subarray(4, 6)),
    hex(bytes.subarray(6, 8)),
    hex(bytes.subarray(8, 10)),
    hex(bytes.subarray(10, 16))
  ].join("-");
}
var getRandomValues = (() => {
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    return crypto.getRandomValues.bind(crypto);
  }
  return function getRandomValuesWithMathRandom(bytes) {
    const max2 = Math.pow(2, 8 * bytes.byteLength / bytes.length);
    for (let i2 = 0; i2 < bytes.length; i2++) {
      bytes[i2] = Math.random() * max2;
    }
  };
})();
function getRandomBytes(length) {
  const bytes = new Uint8Array(length);
  getRandomValues(bytes);
  return bytes;
}
function addConnectionEventListeners(cb) {
  if (typeof window !== "undefined" && window.addEventListener) {
    window.addEventListener("offline", cb);
    window.addEventListener("online", cb);
  }
}
function removeConnectionEventListeners(cb) {
  if (typeof window !== "undefined" && window.removeEventListener) {
    window.removeEventListener("offline", cb);
    window.removeEventListener("online", cb);
  }
}
function isErrorResponse(res) {
  return !res.status || res.status < 200 || 300 <= res.status;
}
function isCloseEvent(res) {
  return res.code !== void 0;
}
var isReactNative2 = () => {
  if (typeof navigator === "undefined")
    return false;
  return navigator.product?.toLowerCase() === "reactnative";
};
var logToConsole2 = (logLevel, message, ...args) => {
  let logMethod;
  switch (logLevel) {
    case "error":
      if (isReactNative2()) {
        message = `ERROR: ${message}`;
        logMethod = console.info;
        break;
      }
      logMethod = console.error;
      break;
    case "warn":
      if (isReactNative2()) {
        message = `WARN: ${message}`;
        logMethod = console.info;
        break;
      }
      logMethod = console.warn;
      break;
    case "info":
      logMethod = console.info;
      break;
    case "trace":
      logMethod = console.trace;
      break;
    default:
      logMethod = console.log;
      break;
  }
  logMethod(message, ...args);
};
var videoLoggerSystem = createLoggerSystem();
var retryable = async (rpc, signal) => {
  let attempt = 0;
  let result = void 0;
  do {
    if (attempt > 0)
      await sleep(retryInterval(attempt));
    try {
      result = await rpc();
    } catch (err) {
      const isRequestCancelled = err instanceof RpcError && err.code === TwirpErrorCode[TwirpErrorCode.cancelled];
      const isAborted = signal?.aborted ?? false;
      if (isRequestCancelled || isAborted)
        throw err;
      videoLoggerSystem.getLogger("sfu-client", { tags: ["rpc"] }).debug(`rpc failed (${attempt})`, err);
      attempt++;
    }
  } while (!result || result.response.error?.shouldRetry);
  return result;
};
var extractMid = (transceiver, transceiverInitIndex, sdp2) => {
  if (transceiver.mid)
    return transceiver.mid;
  if (!sdp2)
    return String(transceiverInitIndex);
  const track = transceiver.sender.track;
  const parsedSdp = (0, import_sdp_transform.parse)(sdp2);
  const media = parsedSdp.media.find((m2) => {
    return m2.type === track.kind && // if `msid` is not present, we assume that the track is the first one
    (m2.msid?.includes(track.id) ?? true);
  });
  if (typeof media?.mid !== "undefined")
    return String(media.mid);
  if (transceiverInitIndex < 0)
    return "";
  return String(transceiverInitIndex);
};
var enableStereo = (offerSdp, answerSdp) => {
  const offeredStereoMids = /* @__PURE__ */ new Set();
  const parsedOfferSdp = (0, import_sdp_transform.parse)(offerSdp);
  for (const media of parsedOfferSdp.media) {
    if (media.type !== "audio")
      continue;
    const opus = media.rtp.find((r2) => r2.codec === "opus");
    if (!opus)
      continue;
    for (const fmtp of media.fmtp) {
      if (fmtp.payload === opus.payload && fmtp.config.includes("stereo=1")) {
        offeredStereoMids.add(media.mid);
      }
    }
  }
  if (offeredStereoMids.size === 0)
    return answerSdp;
  const parsedAnswerSdp = (0, import_sdp_transform.parse)(answerSdp);
  for (const media of parsedAnswerSdp.media) {
    if (media.type !== "audio" || !offeredStereoMids.has(media.mid))
      continue;
    const opus = media.rtp.find((r2) => r2.codec === "opus");
    if (!opus)
      continue;
    for (const fmtp of media.fmtp) {
      if (fmtp.payload === opus.payload && !fmtp.config.includes("stereo=1")) {
        fmtp.config += ";stereo=1";
      }
    }
  }
  return (0, import_sdp_transform.write)(parsedAnswerSdp);
};
var removeCodecsExcept = (sdp2, codecMimeTypeToKeep, fmtpProfileToKeep) => {
  const [kind, codec] = toMimeType(codecMimeTypeToKeep).split("/");
  if (!kind || !codec)
    return sdp2;
  const parsed = (0, import_sdp_transform.parse)(sdp2);
  for (const media of parsed.media) {
    if (media.type !== kind)
      continue;
    let payloadsToKeep = /* @__PURE__ */ new Set();
    for (const rtp of media.rtp) {
      if (rtp.codec.toLowerCase() !== codec)
        continue;
      payloadsToKeep.add(rtp.payload);
    }
    if (fmtpProfileToKeep) {
      const filtered = /* @__PURE__ */ new Set();
      const required = new Set(fmtpProfileToKeep.split(";"));
      for (const fmtp of media.fmtp) {
        if (payloadsToKeep.has(fmtp.payload) && required.difference(new Set(fmtp.config.split(";"))).size === 0) {
          filtered.add(fmtp.payload);
        }
      }
      payloadsToKeep = filtered;
    }
    if (payloadsToKeep.size === 0 && !fmtpProfileToKeep)
      continue;
    for (const fmtp of media.fmtp) {
      const matches = /\s*apt\s*=\s*(\d+)\s*/i.exec(fmtp.config);
      if (!matches)
        continue;
      const primaryPayloadApt = Number(matches[1]);
      if (!payloadsToKeep.has(primaryPayloadApt))
        continue;
      payloadsToKeep.add(fmtp.payload);
    }
    media.rtp = media.rtp.filter((rtp) => payloadsToKeep.has(rtp.payload));
    media.fmtp = media.fmtp.filter((fmtp) => payloadsToKeep.has(fmtp.payload));
    media.rtcpFb = media.rtcpFb?.filter((fb) => typeof fb.payload === "number" ? payloadsToKeep.has(fb.payload) : true);
    const payloads = [];
    for (const id of (media.payloads || "").split(/\s+/)) {
      const payload = Number(id);
      if (!payloadsToKeep.has(payload))
        continue;
      payloads.push(payload);
    }
    media.payloads = payloads.join(" ");
  }
  return (0, import_sdp_transform.write)(parsed);
};
var toMimeType = (codec, kind = "video") => codec.includes("/") ? codec : `${kind}/${codec}`;
var getGenericSdp = async (direction, codecToKeep, fmtpProfileToKeep) => {
  const tempPc = new RTCPeerConnection();
  tempPc.addTransceiver("video", { direction });
  tempPc.addTransceiver("audio", { direction });
  const offer = await tempPc.createOffer();
  const { sdp: baseSdp = "" } = offer;
  const sdp2 = codecToKeep ? removeCodecsExcept(baseSdp, codecToKeep, fmtpProfileToKeep) : baseSdp;
  tempPc.getTransceivers().forEach((t2) => {
    t2.stop?.();
  });
  tempPc.close();
  return sdp2;
};
var isSvcCodec = (codecOrMimeType) => {
  if (!codecOrMimeType)
    return false;
  codecOrMimeType = codecOrMimeType.toLowerCase();
  return codecOrMimeType === "vp9" || codecOrMimeType === "av1" || codecOrMimeType === "video/vp9" || codecOrMimeType === "video/av1";
};
var sfuEventKinds = {
  subscriberOffer: void 0,
  publisherAnswer: void 0,
  connectionQualityChanged: void 0,
  audioLevelChanged: void 0,
  iceTrickle: void 0,
  changePublishQuality: void 0,
  participantJoined: void 0,
  participantLeft: void 0,
  dominantSpeakerChanged: void 0,
  joinResponse: void 0,
  healthCheckResponse: void 0,
  trackPublished: void 0,
  trackUnpublished: void 0,
  error: void 0,
  callGrantsUpdated: void 0,
  goAway: void 0,
  iceRestart: void 0,
  pinsUpdated: void 0,
  callEnded: void 0,
  participantUpdated: void 0,
  participantMigrationComplete: void 0,
  changePublishOptions: void 0,
  inboundStateNotification: void 0
};
var isSfuEvent = (eventName) => {
  return Object.prototype.hasOwnProperty.call(sfuEventKinds, eventName);
};
var Dispatcher = class {
  constructor() {
    this.logger = videoLoggerSystem.getLogger("Dispatcher");
    this.subscribers = {};
    this.dispatch = (message, tag = "0") => {
      const eventKind = message.eventPayload.oneofKind;
      if (!eventKind)
        return;
      const payload = message.eventPayload[eventKind];
      this.logger.debug(`Dispatching ${eventKind}, tag=${tag}`, payload);
      const listeners = this.subscribers[eventKind];
      if (!listeners)
        return;
      for (const fn2 of listeners) {
        try {
          fn2(payload);
        } catch (e2) {
          this.logger.warn("Listener failed with error", e2);
        }
      }
    };
    this.on = (eventName, fn2) => {
      var _a2;
      ((_a2 = this.subscribers)[eventName] ?? (_a2[eventName] = [])).push(fn2);
      return () => {
        this.off(eventName, fn2);
      };
    };
    this.off = (eventName, fn2) => {
      this.subscribers[eventName] = (this.subscribers[eventName] || []).filter((f) => f !== fn2);
    };
  }
};
var IceTrickleBuffer = class {
  constructor() {
    this.subscriberCandidates = new ReplaySubject();
    this.publisherCandidates = new ReplaySubject();
    this.push = (iceTrickle) => {
      const iceCandidate = toIceCandidate(iceTrickle);
      if (!iceCandidate)
        return;
      if (iceTrickle.peerType === PeerType.SUBSCRIBER) {
        this.subscriberCandidates.next(iceCandidate);
      } else if (iceTrickle.peerType === PeerType.PUBLISHER_UNSPECIFIED) {
        this.publisherCandidates.next(iceCandidate);
      } else {
        const logger = videoLoggerSystem.getLogger("sfu-client");
        logger.warn(`ICETrickle, Unknown peer type`, iceTrickle);
      }
    };
    this.dispose = () => {
      this.subscriberCandidates.complete();
      this.publisherCandidates.complete();
    };
  }
};
var toIceCandidate = (iceTrickle) => {
  try {
    return JSON.parse(iceTrickle.iceCandidate);
  } catch (e2) {
    const logger = videoLoggerSystem.getLogger("sfu-client");
    logger.error(`Failed to parse ICE Trickle`, e2, iceTrickle);
    return void 0;
  }
};
var withoutConcurrency = createRunner(wrapWithContinuationTracking);
var withCancellation = createRunner(wrapWithCancellation);
var pendingPromises = /* @__PURE__ */ new Map();
function hasPending(tag) {
  return pendingPromises.has(tag);
}
async function settled(tag) {
  let pending;
  while (pending = pendingPromises.get(tag)) {
    await pending.promise;
  }
}
function createRunner(wrapper) {
  return function run(tag, cb) {
    const { cb: wrapped, onContinued } = wrapper(tag, cb);
    const pending = pendingPromises.get(tag);
    pending?.onContinued();
    const promise = pending ? pending.promise.then(wrapped, wrapped) : wrapped();
    pendingPromises.set(tag, { promise, onContinued });
    return promise;
  };
}
function wrapWithContinuationTracking(tag, cb) {
  let hasContinuation = false;
  const wrapped = () => cb().finally(() => {
    if (!hasContinuation) {
      pendingPromises.delete(tag);
    }
  });
  const onContinued = () => hasContinuation = true;
  return { cb: wrapped, onContinued };
}
function wrapWithCancellation(tag, cb) {
  const ac2 = new AbortController();
  const wrapped = () => {
    if (ac2.signal.aborted) {
      return Promise.resolve("canceled");
    }
    return cb(ac2.signal).finally(() => {
      if (!ac2.signal.aborted) {
        pendingPromises.delete(tag);
      }
    });
  };
  const onContinued = () => ac2.abort();
  return { cb: wrapped, onContinued };
}
var isFunctionPatch = (update) => typeof update === "function";
var getCurrentValue = (observable$) => {
  let value;
  let err = void 0;
  combineLatest([observable$]).subscribe({
    next: ([v2]) => {
      value = v2;
    },
    error: (e2) => {
      err = e2;
    }
  }).unsubscribe();
  if (err)
    throw err;
  return value;
};
var setCurrentValue = (subject, update) => {
  const next = isFunctionPatch(update) ? update(getCurrentValue(subject)) : update;
  subject.next(next);
  return next;
};
var updateValue = (subject, update) => {
  const lastValue = subject.getValue();
  const value = setCurrentValue(subject, update);
  return {
    lastValue,
    value,
    rollback: () => setCurrentValue(subject, lastValue)
  };
};
var createSubscription = (observable2, handler, onError = (error) => videoLoggerSystem.getLogger("RxUtils").warn("An observable emitted an error", error)) => {
  const subscription = observable2.subscribe({ next: handler, error: onError });
  return () => {
    subscription.unsubscribe();
  };
};
var createSafeAsyncSubscription = (observable2, handler) => {
  const tag = Symbol();
  return createSubscription(observable2, (value) => {
    withoutConcurrency(tag, () => handler(value));
  });
};
var rxUtils = Object.freeze({
  __proto__: null,
  createSafeAsyncSubscription,
  createSubscription,
  getCurrentValue,
  setCurrentValue,
  updateValue
});
var CallingState;
(function(CallingState2) {
  CallingState2["UNKNOWN"] = "unknown";
  CallingState2["IDLE"] = "idle";
  CallingState2["RINGING"] = "ringing";
  CallingState2["JOINING"] = "joining";
  CallingState2["JOINED"] = "joined";
  CallingState2["LEFT"] = "left";
  CallingState2["RECONNECTING"] = "reconnecting";
  CallingState2["MIGRATING"] = "migrating";
  CallingState2["RECONNECTING_FAILED"] = "reconnecting-failed";
  CallingState2["OFFLINE"] = "offline";
})(CallingState || (CallingState = {}));
var StreamVideoWriteableStateStore = class {
  constructor() {
    this.connectedUserSubject = new BehaviorSubject(void 0);
    this.callsSubject = new BehaviorSubject([]);
    this.setConnectedUser = (user) => {
      return setCurrentValue(this.connectedUserSubject, user);
    };
    this.setCalls = (calls) => {
      return setCurrentValue(this.callsSubject, calls);
    };
    this.registerCall = (call) => {
      if (!this.calls.find((c2) => c2.cid === call.cid)) {
        this.setCalls((calls) => [...calls, call]);
      }
    };
    this.unregisterCall = (call) => {
      const logger = videoLoggerSystem.getLogger("client-state");
      logger.trace(`Unregistering call: ${call.cid}`);
      return this.setCalls((calls) => calls.filter((c2) => c2 !== call));
    };
    this.findCall = (type, id) => {
      return this.calls.find((c2) => c2.type === type && c2.id === id);
    };
    this.connectedUserSubject.subscribe(async (user) => {
      if (!user) {
        const logger = videoLoggerSystem.getLogger("client-state");
        for (const call of this.calls) {
          if (call.state.callingState === CallingState.LEFT)
            continue;
          logger.info(`User disconnected, leaving call: ${call.cid}`);
          await call.leave({ message: "client.disconnectUser() called" }).catch((err) => {
            logger.error(`Error leaving call: ${call.cid}`, err);
          });
        }
      }
    });
  }
  /**
   * The currently connected user.
   */
  get connectedUser() {
    return getCurrentValue(this.connectedUserSubject);
  }
  /**
   * A list of {@link Call} objects created/tracked by this client.
   */
  get calls() {
    return getCurrentValue(this.callsSubject);
  }
};
var StreamVideoReadOnlyStateStore = class {
  constructor(store) {
    this.connectedUser$ = store.connectedUserSubject.asObservable();
    this.calls$ = store.callsSubject.asObservable();
  }
  /**
   * The current user connected over WS to the backend.
   */
  get connectedUser() {
    return getCurrentValue(this.connectedUser$);
  }
  /**
   * A list of {@link Call} objects created/tracked by this client.
   */
  get calls() {
    return getCurrentValue(this.calls$);
  }
};
var combineComparators = (...comparators) => {
  return (a2, b2) => {
    for (const comparator of comparators) {
      const result = comparator(a2, b2);
      if (result !== 0)
        return result;
    }
    return 0;
  };
};
var descending = (comparator) => {
  return (a2, b2) => comparator(b2, a2);
};
var conditional = (predicate) => {
  return (comparator) => {
    return (a2, b2) => {
      if (!predicate(a2, b2))
        return 0;
      return comparator(a2, b2);
    };
  };
};
var noopComparator = () => {
  return () => 0;
};
var hasVideo = (p2) => p2.publishedTracks.includes(TrackType.VIDEO);
var hasAudio = (p2) => p2.publishedTracks.includes(TrackType.AUDIO);
var hasScreenShare = (p2) => p2.publishedTracks.includes(TrackType.SCREEN_SHARE);
var hasScreenShareAudio = (p2) => p2.publishedTracks.includes(TrackType.SCREEN_SHARE_AUDIO);
var isPinned = (p2) => !!p2.pin && (p2.pin.isLocalPin || p2.pin.pinnedAt > 0);
var hasPausedTrack = (p2, videoTrackType) => {
  if (!p2.pausedTracks)
    return false;
  const trackType = videoTrackType === "videoTrack" ? TrackType.VIDEO : videoTrackType === "screenShareTrack" ? TrackType.SCREEN_SHARE : void 0;
  if (!trackType)
    return false;
  return p2.pausedTracks.includes(trackType);
};
var dominantSpeaker = (a2, b2) => {
  if (a2.isDominantSpeaker && !b2.isDominantSpeaker)
    return -1;
  if (!a2.isDominantSpeaker && b2.isDominantSpeaker)
    return 1;
  return 0;
};
var speaking = (a2, b2) => {
  if (a2.isSpeaking && !b2.isSpeaking)
    return -1;
  if (!a2.isSpeaking && b2.isSpeaking)
    return 1;
  return 0;
};
var screenSharing = (a2, b2) => {
  const hasA = hasScreenShare(a2);
  const hasB = hasScreenShare(b2);
  if (hasA && !hasB)
    return -1;
  if (!hasA && hasB)
    return 1;
  return 0;
};
var publishingVideo = (a2, b2) => {
  const hasA = hasVideo(a2);
  const hasB = hasVideo(b2);
  if (hasA && !hasB)
    return -1;
  if (!hasA && hasB)
    return 1;
  return 0;
};
var publishingAudio = (a2, b2) => {
  const hasA = hasAudio(a2);
  const hasB = hasAudio(b2);
  if (hasA && !hasB)
    return -1;
  if (!hasA && hasB)
    return 1;
  return 0;
};
var pinned = (a2, b2) => {
  if (a2.pin && b2.pin) {
    if (!a2.pin.isLocalPin && b2.pin.isLocalPin)
      return -1;
    if (a2.pin.isLocalPin && !b2.pin.isLocalPin)
      return 1;
    if (a2.pin.pinnedAt > b2.pin.pinnedAt)
      return -1;
    if (a2.pin.pinnedAt < b2.pin.pinnedAt)
      return 1;
  }
  if (a2.pin && !b2.pin)
    return -1;
  if (!a2.pin && b2.pin)
    return 1;
  return 0;
};
var withParticipantSource = (...sources) => {
  const priority = (i2) => i2 === -1 ? Number.MAX_SAFE_INTEGER : i2;
  return (a2, b2) => {
    const priorityA = priority(sources.indexOf(a2.source));
    const priorityB = priority(sources.indexOf(b2.source));
    if (priorityA < priorityB)
      return -1;
    if (priorityA > priorityB)
      return 1;
    return 0;
  };
};
var reactionType = (type) => {
  return (a2, b2) => {
    if (a2.reaction?.type === type && b2.reaction?.type !== type)
      return -1;
    if (a2.reaction?.type !== type && b2.reaction?.type === type)
      return 1;
    return 0;
  };
};
var role = (...roles) => (a2, b2) => {
  const hasA = hasAnyRole(a2, roles);
  const hasB = hasAnyRole(b2, roles);
  if (hasA && !hasB)
    return -1;
  if (!hasA && hasB)
    return 1;
  return 0;
};
var name = (a2, b2) => {
  if (a2.name < b2.name)
    return -1;
  if (a2.name > b2.name)
    return 1;
  return 0;
};
var hasAnyRole = (p2, roles) => (p2.roles || []).some((r2) => roles.includes(r2));
var ifInvisibleBy = conditional((a2, b2) => a2.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b2.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE);
var ifInvisibleOrUnknownBy = conditional((a2, b2) => a2.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || a2.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN || b2.viewportVisibilityState?.videoTrack === VisibilityState.INVISIBLE || b2.viewportVisibilityState?.videoTrack === VisibilityState.UNKNOWN);
var withVideoIngressSource = withParticipantSource(ParticipantSource.RTMP, ParticipantSource.SRT, ParticipantSource.WHIP, ParticipantSource.RTSP);
var defaultSortPreset = combineComparators(screenSharing, pinned, ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType("raised-hand"), publishingVideo, publishingAudio)));
var speakerLayoutSortPreset = combineComparators(screenSharing, pinned, dominantSpeaker, ifInvisibleBy(combineComparators(speaking, reactionType("raised-hand"), withVideoIngressSource, publishingVideo, publishingAudio)));
var paginatedLayoutSortPreset = combineComparators(pinned, ifInvisibleOrUnknownBy(combineComparators(dominantSpeaker, speaking, reactionType("raised-hand"), withVideoIngressSource, publishingVideo, publishingAudio)));
var livestreamOrAudioRoomSortPreset = combineComparators(ifInvisibleBy(combineComparators(dominantSpeaker, speaking, reactionType("raised-hand"), withVideoIngressSource, publishingVideo, publishingAudio)), role("admin", "host", "speaker"));
var defaultEgress = {
  broadcasting: false,
  hls: { playlist_url: "", status: "" },
  rtmps: []
};
var createStableParticipantsFilter = (predicate) => {
  const empty2 = [];
  return (participants) => {
    if (!participants.length)
      return participants;
    const filteredParticipants = participants.filter(predicate);
    if (!filteredParticipants.length)
      return empty2;
    return filteredParticipants;
  };
};
var CallState = class {
  /**
   * Creates a new instance of the CallState class.
   *
   */
  constructor() {
    this.backstageSubject = new BehaviorSubject(true);
    this.blockedUserIdsSubject = new BehaviorSubject([]);
    this.createdAtSubject = new BehaviorSubject(/* @__PURE__ */ new Date());
    this.endedAtSubject = new BehaviorSubject(void 0);
    this.startsAtSubject = new BehaviorSubject(void 0);
    this.updatedAtSubject = new BehaviorSubject(/* @__PURE__ */ new Date());
    this.createdBySubject = new BehaviorSubject(void 0);
    this.customSubject = new BehaviorSubject({});
    this.egressSubject = new BehaviorSubject(void 0);
    this.ingressSubject = new BehaviorSubject(void 0);
    this.recordingSubject = new BehaviorSubject(false);
    this.sessionSubject = new BehaviorSubject(void 0);
    this.settingsSubject = new BehaviorSubject(void 0);
    this.transcribingSubject = new BehaviorSubject(false);
    this.captioningSubject = new BehaviorSubject(false);
    this.endedBySubject = new BehaviorSubject(void 0);
    this.thumbnailsSubject = new BehaviorSubject(void 0);
    this.membersSubject = new BehaviorSubject([]);
    this.ownCapabilitiesSubject = new BehaviorSubject([]);
    this.callingStateSubject = new BehaviorSubject(CallingState.UNKNOWN);
    this.startedAtSubject = new BehaviorSubject(void 0);
    this.participantCountSubject = new BehaviorSubject(0);
    this.anonymousParticipantCountSubject = new BehaviorSubject(0);
    this.participantsSubject = new BehaviorSubject([]);
    this.callStatsReportSubject = new BehaviorSubject(void 0);
    this.closedCaptionsSubject = new BehaviorSubject([]);
    this.orphanedTracks = [];
    this.callGrantsSubject = new ReplaySubject(1);
    this.logger = videoLoggerSystem.getLogger("CallState");
    this.sortParticipantsBy = defaultSortPreset;
    this.closedCaptionsTasks = /* @__PURE__ */ new Map();
    this.dispose = () => {
      for (const [ccKey, taskId] of this.closedCaptionsTasks.entries()) {
        clearTimeout(taskId);
        this.closedCaptionsTasks.delete(ccKey);
      }
    };
    this.setSortParticipantsBy = (comparator) => {
      this.sortParticipantsBy = comparator;
      this.setCurrentValue(this.participantsSubject, (ps2) => ps2);
    };
    this.getCurrentValue = getCurrentValue;
    this.setCurrentValue = setCurrentValue;
    this.setParticipantCount = (count2) => {
      return this.setCurrentValue(this.participantCountSubject, count2);
    };
    this.setStartedAt = (startedAt) => {
      return this.setCurrentValue(this.startedAtSubject, startedAt);
    };
    this.setCaptioning = (captioning) => {
      return updateValue(this.captioningSubject, captioning);
    };
    this.setAnonymousParticipantCount = (count2) => {
      return this.setCurrentValue(this.anonymousParticipantCountSubject, count2);
    };
    this.getParticipantsSnapshot = () => {
      return this.participantsSubject.getValue();
    };
    this.setParticipants = (participants) => {
      return this.setCurrentValue(this.participantsSubject, participants);
    };
    this.setCallingState = (state) => {
      return this.setCurrentValue(this.callingStateSubject, state);
    };
    this.setCallStatsReport = (report) => {
      return this.setCurrentValue(this.callStatsReportSubject, report);
    };
    this.setMembers = (members) => {
      this.setCurrentValue(this.membersSubject, members);
    };
    this.setOwnCapabilities = (capabilities) => {
      return this.setCurrentValue(this.ownCapabilitiesSubject, capabilities);
    };
    this.setCallGrants = (grants) => {
      return this.setCurrentValue(this.callGrantsSubject, grants);
    };
    this.setBackstage = (backstage) => {
      return this.setCurrentValue(this.backstageSubject, backstage);
    };
    this.setEndedAt = (endedAt) => {
      return this.setCurrentValue(this.endedAtSubject, endedAt);
    };
    this.findParticipantBySessionId = (sessionId) => {
      return this.participants.find((p2) => p2.sessionId === sessionId);
    };
    this.getParticipantLookupBySessionId = () => {
      return this.participants.reduce((lookupTable, participant) => {
        lookupTable[participant.sessionId] = participant;
        return lookupTable;
      }, {});
    };
    this.updateParticipant = (sessionId, patch3) => {
      const participant = this.findParticipantBySessionId(sessionId);
      if (!participant) {
        this.logger.warn(`Participant with sessionId ${sessionId} not found`);
        return;
      }
      const thePatch = typeof patch3 === "function" ? patch3(participant) : patch3;
      const updatedParticipant = {
        ...participant,
        ...thePatch
      };
      return this.setParticipants((participants) => participants.map((p2) => p2.sessionId === sessionId ? updatedParticipant : p2));
    };
    this.updateOrAddParticipant = (sessionId, participant, patch3) => {
      return this.setParticipants((participants) => {
        let add = true;
        const nextParticipants = participants.map((p2) => {
          if (p2.sessionId === sessionId) {
            add = false;
            const updated = { ...p2, ...participant };
            const thePatch = typeof patch3 === "function" ? patch3(updated) : patch3;
            return Object.assign(updated, thePatch);
          }
          return p2;
        });
        if (add)
          nextParticipants.push(participant);
        return nextParticipants;
      });
    };
    this.updateParticipants = (patch3) => {
      if (Object.keys(patch3).length === 0)
        return this.participants;
      return this.setParticipants((participants) => participants.map((p2) => {
        const thePatch = patch3[p2.sessionId];
        if (thePatch) {
          return {
            ...p2,
            ...thePatch
          };
        }
        return p2;
      }));
    };
    this.updateParticipantTracks = (trackType, changes) => {
      return this.updateParticipants(Object.entries(changes).reduce((acc, [sessionId, change]) => {
        if (change.dimension) {
          change.dimension.height = Math.ceil(change.dimension.height);
          change.dimension.width = Math.ceil(change.dimension.width);
        }
        const prop = trackType === "videoTrack" ? "videoDimension" : trackType === "screenShareTrack" ? "screenShareDimension" : void 0;
        if (prop) {
          acc[sessionId] = {
            [prop]: change.dimension
          };
        }
        return acc;
      }, {}));
    };
    this.updateFromEvent = (event) => {
      const update = this.eventHandlers[event.type];
      if (update) {
        update(event);
      }
    };
    this.setServerSidePins = (pins) => {
      const now = Date.now();
      const unknownSymbol = Symbol("unknown");
      const pinnedAtByIdentifier = pins.reduce((lookup, pin, index) => {
        var _a2;
        const pinnedAt = now + (pins.length - index);
        if (lookup[pin.userId]) {
          lookup[pin.userId] = unknownSymbol;
        } else {
          lookup[pin.userId] = pinnedAt;
        }
        lookup[_a2 = pin.sessionId] ?? (lookup[_a2] = pinnedAt);
        return lookup;
      }, {});
      return this.setParticipants((participants) => participants.map((participant) => {
        const serverSidePinnedAt = pinnedAtByIdentifier[participant.sessionId] ?? pinnedAtByIdentifier[participant.userId];
        if (typeof serverSidePinnedAt === "number" && typeof participant.pin?.pinnedAt !== "number") {
          return {
            ...participant,
            pin: {
              isLocalPin: false,
              pinnedAt: serverSidePinnedAt
            }
          };
        }
        if (typeof serverSidePinnedAt !== "number" && participant.pin?.isLocalPin === false) {
          return {
            ...participant,
            pin: void 0
          };
        }
        return participant;
      }));
    };
    this.registerOrphanedTrack = (orphanedTrack) => {
      this.orphanedTracks.push(orphanedTrack);
    };
    this.removeOrphanedTrack = (id) => {
      this.orphanedTracks = this.orphanedTracks.filter((o2) => o2.id !== id);
    };
    this.takeOrphanedTracks = (trackLookupPrefix) => {
      const orphans = this.orphanedTracks.filter((orphan) => orphan.trackLookupPrefix === trackLookupPrefix);
      if (orphans.length > 0) {
        this.orphanedTracks = this.orphanedTracks.filter((orphan) => orphan.trackLookupPrefix !== trackLookupPrefix);
      }
      return orphans;
    };
    this.updateClosedCaptionSettings = (config2) => {
      this.closedCaptionsSettings = { ...this.closedCaptionsSettings, ...config2 };
    };
    this.updateFromCallResponse = (call) => {
      this.setBackstage(call.backstage);
      this.setCurrentValue(this.blockedUserIdsSubject, call.blocked_user_ids);
      this.setCurrentValue(this.createdAtSubject, new Date(call.created_at));
      this.setCurrentValue(this.updatedAtSubject, new Date(call.updated_at));
      this.setCurrentValue(this.startsAtSubject, call.starts_at ? new Date(call.starts_at) : void 0);
      this.setEndedAt(call.ended_at ? new Date(call.ended_at) : void 0);
      this.setCurrentValue(this.createdBySubject, call.created_by);
      this.setCurrentValue(this.customSubject, call.custom);
      this.setCurrentValue(this.egressSubject, call.egress);
      this.setCurrentValue(this.ingressSubject, call.ingress);
      this.setCurrentValue(this.recordingSubject, call.recording);
      const s2 = this.setCurrentValue(this.sessionSubject, call.session);
      this.updateParticipantCountFromSession(s2);
      this.setCurrentValue(this.settingsSubject, call.settings);
      this.setCurrentValue(this.transcribingSubject, call.transcribing);
      this.setCurrentValue(this.captioningSubject, call.captioning);
      this.setCurrentValue(this.thumbnailsSubject, call.thumbnails);
    };
    this.updateFromSfuCallState = (callState, currentSessionId, reconnectDetails) => {
      const { participants, participantCount, startedAt, pins } = callState;
      const localPublishedTracks = reconnectDetails?.announcedTracks.map((t2) => t2.trackType) ?? [];
      this.setParticipants(() => {
        const participantLookup = this.getParticipantLookupBySessionId();
        return participants.map((p2) => {
          const existingParticipant = participantLookup[p2.sessionId];
          const isLocalParticipant = p2.sessionId === currentSessionId;
          return Object.assign({}, existingParticipant, p2, {
            isLocalParticipant,
            publishedTracks: isLocalParticipant ? localPublishedTracks : p2.publishedTracks,
            viewportVisibilityState: existingParticipant?.viewportVisibilityState ?? {
              videoTrack: VisibilityState.UNKNOWN,
              screenShareTrack: VisibilityState.UNKNOWN
            }
          });
        });
      });
      this.setParticipantCount(participantCount?.total || 0);
      this.setAnonymousParticipantCount(participantCount?.anonymous || 0);
      this.setStartedAt(startedAt ? Timestamp.toDate(startedAt) : /* @__PURE__ */ new Date());
      this.setServerSidePins(pins);
    };
    this.updateFromMemberRemoved = (event) => {
      this.updateFromCallResponse(event.call);
      this.setCurrentValue(this.membersSubject, (members) => members.filter((m2) => event.members.indexOf(m2.user_id) === -1));
    };
    this.updateFromMemberAdded = (event) => {
      this.updateFromCallResponse(event.call);
      this.setCurrentValue(this.membersSubject, (members) => [
        ...members,
        ...event.members
      ]);
    };
    this.updateFromHLSBroadcastStopped = () => {
      this.setCurrentValue(this.egressSubject, (egress = defaultEgress) => ({
        ...egress,
        broadcasting: false,
        hls: {
          ...egress.hls,
          status: ""
        }
      }));
    };
    this.updateFromHLSBroadcastingFailed = () => {
      this.setCurrentValue(this.egressSubject, (egress = defaultEgress) => ({
        ...egress,
        broadcasting: false,
        hls: {
          ...egress.hls,
          status: ""
        }
      }));
    };
    this.updateParticipantCountFromSession = (session) => {
      if (!session || this.callingState === CallingState.JOINED)
        return;
      const byRoleCount = Object.values(session.participants_count_by_role).reduce((total, countByRole) => total + countByRole, 0);
      const participantCount = Math.max(byRoleCount, session.participants.length);
      this.setParticipantCount(participantCount);
      this.setAnonymousParticipantCount(session.anonymous_participant_count || 0);
    };
    this.updateFromSessionParticipantCountUpdate = (event) => {
      const s2 = this.setCurrentValue(this.sessionSubject, (session) => {
        if (!session)
          return session;
        return {
          ...session,
          anonymous_participant_count: event.anonymous_participant_count,
          participants_count_by_role: event.participants_count_by_role
        };
      });
      this.updateParticipantCountFromSession(s2);
    };
    this.updateFromSessionParticipantLeft = (event) => {
      const s2 = this.setCurrentValue(this.sessionSubject, (session) => {
        if (!session)
          return session;
        const { participants, participants_count_by_role } = session;
        const { user, user_session_id } = event.participant;
        return {
          ...session,
          participants: participants.filter((p2) => p2.user_session_id !== user_session_id),
          participants_count_by_role: {
            ...participants_count_by_role,
            [user.role]: Math.max(0, (participants_count_by_role[user.role] || 0) - 1)
          }
        };
      });
      this.updateParticipantCountFromSession(s2);
    };
    this.updateFromSessionParticipantJoined = (event) => {
      const s2 = this.setCurrentValue(this.sessionSubject, (session) => {
        if (!session)
          return session;
        const { participants, participants_count_by_role } = session;
        const { user, user_session_id } = event.participant;
        let shouldInsertParticipant = true;
        const updatedParticipants = participants.map((p2) => {
          if (p2.user_session_id === user_session_id) {
            shouldInsertParticipant = false;
            return event.participant;
          }
          return p2;
        });
        if (shouldInsertParticipant) {
          updatedParticipants.push(event.participant);
        }
        const increment = shouldInsertParticipant ? 1 : 0;
        return {
          ...session,
          participants: updatedParticipants,
          participants_count_by_role: {
            ...participants_count_by_role,
            [user.role]: (participants_count_by_role[user.role] || 0) + increment
          }
        };
      });
      this.updateParticipantCountFromSession(s2);
    };
    this.updateMembers = (event) => {
      this.updateFromCallResponse(event.call);
      this.setCurrentValue(this.membersSubject, (members) => members.map((member) => {
        const memberUpdate = event.members.find((m2) => m2.user_id === member.user_id);
        return memberUpdate ? memberUpdate : member;
      }));
    };
    this.updateParticipantReaction = (event) => {
      const { user, custom, type, emoji_code } = event.reaction;
      this.setParticipants((participants) => {
        return participants.map((p2) => {
          if (p2.userId !== user.id)
            return p2;
          return {
            ...p2,
            reaction: {
              type,
              emoji_code,
              custom
            }
          };
        });
      });
    };
    this.unblockUser = (event) => {
      this.setCurrentValue(this.blockedUserIdsSubject, (current) => {
        if (!current)
          return current;
        return current.filter((id) => id !== event.user.id);
      });
    };
    this.blockUser = (event) => {
      this.setCurrentValue(this.blockedUserIdsSubject, (current) => [
        ...current || [],
        event.user.id
      ]);
    };
    this.updateOwnCapabilities = (event) => {
      if (event.user.id === this.localParticipant?.userId) {
        this.setOwnCapabilities(event.own_capabilities);
      }
    };
    this.updateFromClosedCaptions = (event) => {
      this.setCurrentValue(this.closedCaptionsSubject, (queue2) => {
        const { closed_caption } = event;
        const keyOf = (c2) => `${c2.speaker_id}/${c2.start_time}`;
        const currentKey = keyOf(closed_caption);
        const duplicate = queue2.some((caption) => keyOf(caption) === currentKey);
        if (duplicate)
          return queue2;
        const nextQueue = [...queue2, closed_caption];
        const { visibilityDurationMs = 2700, maxVisibleCaptions = 2 } = this.closedCaptionsSettings || {};
        if (visibilityDurationMs > 0) {
          const taskId = setTimeout(() => {
            this.setCurrentValue(this.closedCaptionsSubject, (captions) => captions.filter((caption) => caption !== closed_caption));
            this.closedCaptionsTasks.delete(currentKey);
          }, visibilityDurationMs);
          this.closedCaptionsTasks.set(currentKey, taskId);
          for (let i2 = 0; i2 < nextQueue.length - maxVisibleCaptions; i2++) {
            const key = keyOf(nextQueue[i2]);
            const task = this.closedCaptionsTasks.get(key);
            clearTimeout(task);
            this.closedCaptionsTasks.delete(key);
          }
        }
        return nextQueue.slice(-maxVisibleCaptions);
      });
    };
    this.rawParticipants$ = this.participantsSubject.asObservable().pipe(shareReplay({ bufferSize: 1, refCount: true }));
    this.participants$ = this.participantsSubject.asObservable().pipe(
      // maintain stable-sort by mutating the participants stored
      // in the original subject
      map((ps2) => ps2.sort(this.sortParticipantsBy)),
      shareReplay({ bufferSize: 1, refCount: true })
    );
    this.localParticipant$ = this.participants$.pipe(map((participants) => participants.find((p2) => p2.isLocalParticipant)), shareReplay({ bufferSize: 1, refCount: true }));
    this.remoteParticipants$ = this.participants$.pipe(map(createStableParticipantsFilter((p2) => !p2.isLocalParticipant)), shareReplay({ bufferSize: 1, refCount: true }));
    this.pinnedParticipants$ = this.participants$.pipe(map(createStableParticipantsFilter((p2) => !!p2.pin)), shareReplay({ bufferSize: 1, refCount: true }));
    this.dominantSpeaker$ = this.participants$.pipe(map((participants) => participants.find((p2) => p2.isDominantSpeaker)), shareReplay({ bufferSize: 1, refCount: true }));
    this.hasOngoingScreenShare$ = this.participants$.pipe(map((participants) => participants.some((p2) => hasScreenShare(p2))), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));
    this.createdAt$ = this.createdAtSubject.asObservable();
    this.endedAt$ = this.endedAtSubject.asObservable();
    this.startsAt$ = this.startsAtSubject.asObservable();
    this.startedAt$ = this.startedAtSubject.asObservable();
    this.updatedAt$ = this.updatedAtSubject.asObservable();
    this.callStatsReport$ = this.callStatsReportSubject.asObservable();
    this.members$ = this.membersSubject.asObservable();
    this.createdBy$ = this.createdBySubject.asObservable();
    this.custom$ = this.customSubject.asObservable();
    this.egress$ = this.egressSubject.asObservable();
    this.ingress$ = this.ingressSubject.asObservable();
    this.session$ = this.sessionSubject.asObservable();
    this.settings$ = this.settingsSubject.asObservable();
    this.endedBy$ = this.endedBySubject.asObservable();
    this.thumbnails$ = this.thumbnailsSubject.asObservable();
    this.closedCaptions$ = this.closedCaptionsSubject.asObservable();
    const isShallowEqual = (a2, b2) => {
      if (a2.length !== b2.length)
        return false;
      for (const item of a2) {
        if (!b2.includes(item))
          return false;
      }
      for (const item of b2) {
        if (!a2.includes(item))
          return false;
      }
      return true;
    };
    const duc = (subject, comparator) => subject.pipe(distinctUntilChanged(comparator));
    this.anonymousParticipantCount$ = duc(this.anonymousParticipantCountSubject);
    this.blockedUserIds$ = duc(this.blockedUserIdsSubject, isShallowEqual);
    this.backstage$ = duc(this.backstageSubject);
    this.callingState$ = duc(this.callingStateSubject);
    this.ownCapabilities$ = combineLatest([
      this.ownCapabilitiesSubject,
      this.callGrantsSubject.pipe(startWith(void 0))
    ]).pipe(map(([capabilities, grants]) => {
      if (!grants)
        return capabilities;
      const { canPublishAudio, canPublishVideo, canScreenshare } = grants;
      const update = {
        [OwnCapability.SEND_AUDIO]: canPublishAudio,
        [OwnCapability.SEND_VIDEO]: canPublishVideo,
        [OwnCapability.SCREENSHARE]: canScreenshare
      };
      const nextCapabilities = [...capabilities];
      for (const _capability in update) {
        const capability = _capability;
        const allowed = update[capability];
        if (allowed && !nextCapabilities.includes(capability)) {
          nextCapabilities.push(capability);
        } else if (!allowed && nextCapabilities.includes(capability)) {
          const index = nextCapabilities.indexOf(capability);
          nextCapabilities.splice(index, 1);
        }
      }
      return nextCapabilities;
    }), distinctUntilChanged(isShallowEqual), shareReplay({ bufferSize: 1, refCount: true }));
    this.participantCount$ = duc(this.participantCountSubject);
    this.recording$ = duc(this.recordingSubject);
    this.transcribing$ = duc(this.transcribingSubject);
    this.captioning$ = duc(this.captioningSubject);
    this.eventHandlers = {
      // these events are not updating the call state:
      "call.frame_recording_ready": void 0,
      "call.kicked_user": void 0,
      "call.moderation_blur": void 0,
      "call.moderation_warning": void 0,
      "call.permission_request": void 0,
      "call.recording_ready": void 0,
      "call.rtmp_broadcast_failed": void 0,
      "call.rtmp_broadcast_started": void 0,
      "call.rtmp_broadcast_stopped": void 0,
      "call.stats_report_ready": void 0,
      "call.transcription_ready": void 0,
      "call.user_feedback_submitted": void 0,
      "call.user_muted": void 0,
      "connection.error": void 0,
      "connection.ok": void 0,
      "health.check": void 0,
      "user.updated": void 0,
      custom: void 0,
      // events that update call state:
      "call.accepted": (e2) => this.updateFromCallResponse(e2.call),
      "call.blocked_user": this.blockUser,
      "call.closed_caption": this.updateFromClosedCaptions,
      "call.closed_captions_failed": () => {
        this.setCurrentValue(this.captioningSubject, false);
      },
      "call.closed_captions_started": () => {
        this.setCurrentValue(this.captioningSubject, true);
      },
      "call.closed_captions_stopped": () => {
        this.setCurrentValue(this.captioningSubject, false);
      },
      "call.created": (e2) => this.updateFromCallResponse(e2.call),
      "call.deleted": (e2) => this.updateFromCallResponse(e2.call),
      "call.ended": (e2) => {
        this.updateFromCallResponse(e2.call);
        this.setCurrentValue(this.endedBySubject, e2.user);
      },
      "call.frame_recording_failed": (e2) => {
        this.updateFromCallResponse(e2.call);
      },
      "call.frame_recording_started": (e2) => {
        this.updateFromCallResponse(e2.call);
      },
      "call.frame_recording_stopped": (e2) => {
        this.updateFromCallResponse(e2.call);
      },
      "call.hls_broadcasting_failed": this.updateFromHLSBroadcastingFailed,
      "call.hls_broadcasting_started": (e2) => {
        this.updateFromCallResponse(e2.call);
      },
      "call.hls_broadcasting_stopped": this.updateFromHLSBroadcastStopped,
      "call.live_started": (e2) => this.updateFromCallResponse(e2.call),
      "call.member_added": this.updateFromMemberAdded,
      "call.member_removed": this.updateFromMemberRemoved,
      "call.member_updated_permission": this.updateMembers,
      "call.member_updated": this.updateMembers,
      "call.notification": (e2) => {
        this.updateFromCallResponse(e2.call);
        this.setMembers(e2.members);
      },
      "call.permissions_updated": this.updateOwnCapabilities,
      "call.reaction_new": this.updateParticipantReaction,
      "call.recording_started": () => this.setCurrentValue(this.recordingSubject, true),
      "call.recording_stopped": () => this.setCurrentValue(this.recordingSubject, false),
      "call.recording_failed": () => this.setCurrentValue(this.recordingSubject, false),
      "call.rejected": (e2) => this.updateFromCallResponse(e2.call),
      "call.ring": (e2) => this.updateFromCallResponse(e2.call),
      "call.missed": (e2) => this.updateFromCallResponse(e2.call),
      "call.session_ended": (e2) => this.updateFromCallResponse(e2.call),
      "call.session_participant_count_updated": this.updateFromSessionParticipantCountUpdate,
      "call.session_participant_joined": this.updateFromSessionParticipantJoined,
      "call.session_participant_left": this.updateFromSessionParticipantLeft,
      "call.session_started": (e2) => this.updateFromCallResponse(e2.call),
      "call.transcription_started": () => {
        this.setCurrentValue(this.transcribingSubject, true);
      },
      "call.transcription_stopped": () => {
        this.setCurrentValue(this.transcribingSubject, false);
      },
      "call.transcription_failed": () => {
        this.setCurrentValue(this.transcribingSubject, false);
      },
      "call.unblocked_user": this.unblockUser,
      "call.updated": (e2) => this.updateFromCallResponse(e2.call)
    };
  }
  /**
   * The server-side counted number of participants connected to the current call.
   * This number includes the anonymous participants as well.
   */
  get participantCount() {
    return this.getCurrentValue(this.participantCount$);
  }
  /**
   * The time the call session actually started.
   * Useful for displaying the call duration.
   */
  get startedAt() {
    return this.getCurrentValue(this.startedAt$);
  }
  /**
   * Returns whether closed captions are enabled in the current call.
   */
  get captioning() {
    return this.getCurrentValue(this.captioning$);
  }
  /**
   * The server-side counted number of anonymous participants connected to the current call.
   * This number includes the anonymous participants as well.
   */
  get anonymousParticipantCount() {
    return this.getCurrentValue(this.anonymousParticipantCount$);
  }
  /**
   * The list of participants in the current call.
   */
  get participants() {
    return this.getCurrentValue(this.participants$);
  }
  /**
   * The stable list of participants in the current call, unsorted.
   */
  get rawParticipants() {
    return this.getCurrentValue(this.rawParticipants$);
  }
  /**
   * The local participant in the current call.
   */
  get localParticipant() {
    return this.getCurrentValue(this.localParticipant$);
  }
  /**
   * The list of remote participants in the current call.
   */
  get remoteParticipants() {
    return this.getCurrentValue(this.remoteParticipants$);
  }
  /**
   * The dominant speaker in the current call.
   */
  get dominantSpeaker() {
    return this.getCurrentValue(this.dominantSpeaker$);
  }
  /**
   * The list of pinned participants in the current call.
   */
  get pinnedParticipants() {
    return this.getCurrentValue(this.pinnedParticipants$);
  }
  /**
   * Tell if there is an ongoing screen share in this call.
   */
  get hasOngoingScreenShare() {
    return this.getCurrentValue(this.hasOngoingScreenShare$);
  }
  /**
   * The calling state.
   */
  get callingState() {
    return this.getCurrentValue(this.callingState$);
  }
  /**
   * The call stats report.
   */
  get callStatsReport() {
    return this.getCurrentValue(this.callStatsReport$);
  }
  /**
   * Returns whether the call stats report is being observed or not.
   * @internal
   */
  get isCallStatsReportObserved() {
    return this.callStatsReportSubject.observed;
  }
  /**
   * The members of the current call.
   */
  get members() {
    return this.getCurrentValue(this.members$);
  }
  /**
   * The capabilities of the current user for the current call.
   */
  get ownCapabilities() {
    return this.getCurrentValue(this.ownCapabilities$);
  }
  /**
   * The backstage state.
   */
  get backstage() {
    return this.getCurrentValue(this.backstage$);
  }
  /**
   * Will provide the list of blocked user IDs.
   */
  get blockedUserIds() {
    return this.getCurrentValue(this.blockedUserIds$);
  }
  /**
   * Will provide the time when this call has been created.
   */
  get createdAt() {
    return this.getCurrentValue(this.createdAt$);
  }
  /**
   * Will provide the time when this call has been ended.
   */
  get endedAt() {
    return this.getCurrentValue(this.endedAt$);
  }
  /**
   * Will provide the time when this call has been scheduled to start.
   */
  get startsAt() {
    return this.getCurrentValue(this.startsAt$);
  }
  /**
   * Will provide the time when this call has been updated.
   */
  get updatedAt() {
    return this.getCurrentValue(this.updatedAt$);
  }
  /**
   * Will provide the user who created this call.
   */
  get createdBy() {
    return this.getCurrentValue(this.createdBy$);
  }
  /**
   * Will provide the custom data of this call.
   */
  get custom() {
    return this.getCurrentValue(this.custom$);
  }
  /**
   * Will provide the egress data of this call.
   */
  get egress() {
    return this.getCurrentValue(this.egress$);
  }
  /**
   * Will provide the ingress data of this call.
   */
  get ingress() {
    return this.getCurrentValue(this.ingress$);
  }
  /**
   * Will provide the recording state of this call.
   */
  get recording() {
    return this.getCurrentValue(this.recording$);
  }
  /**
   * Will provide the session data of this call.
   */
  get session() {
    return this.getCurrentValue(this.session$);
  }
  /**
   * Will provide the settings of this call.
   */
  get settings() {
    return this.getCurrentValue(this.settings$);
  }
  /**
   * Will provide the transcribing state of this call.
   */
  get transcribing() {
    return this.getCurrentValue(this.transcribing$);
  }
  /**
   * Will provide the user who ended this call.
   */
  get endedBy() {
    return this.getCurrentValue(this.endedBy$);
  }
  /**
   * Will provide the thumbnails of this call, if enabled in the call settings.
   */
  get thumbnails() {
    return this.getCurrentValue(this.thumbnails$);
  }
  /**
   * Returns the current queue of closed captions.
   */
  get closedCaptions() {
    return this.getCurrentValue(this.closedCaptions$);
  }
};
var NegotiationError = class extends Error {
  /**
   * Creates an instance of NegotiationError.
   */
  constructor(error) {
    super(error.message);
    this.name = "NegotiationError";
    this.error = error;
  }
};
var flatten = (report) => {
  const stats = [];
  report.forEach((s2) => {
    stats.push(s2);
  });
  return stats;
};
var dumpStream = (stream) => ({
  id: stream.id,
  tracks: stream.getTracks().map((track) => ({
    id: track.id,
    kind: track.kind,
    label: track.label,
    enabled: track.enabled,
    muted: track.muted,
    readyState: track.readyState
  }))
});
var getSdkSignature = (clientDetails) => {
  const { sdk, ...platform } = clientDetails;
  const sdkName = getSdkName(sdk);
  const sdkVersion = getSdkVersion(sdk);
  return {
    sdkName,
    sdkVersion,
    ...platform
  };
};
var getSdkName = (sdk) => {
  return sdk && sdk.type === SdkType.REACT ? "stream-react" : sdk && sdk.type === SdkType.REACT_NATIVE ? "stream-react-native" : "stream-js";
};
var getSdkVersion = (sdk) => {
  return sdk ? `${sdk.major}.${sdk.minor}.${sdk.patch}` : "0.0.0-development";
};
var version = "1.37.3";
var [major, minor, patch] = version.split(".");
var sdkInfo = {
  type: SdkType.PLAIN_JAVASCRIPT,
  major,
  minor,
  patch
};
var osInfo;
var deviceInfo;
var webRtcInfo;
var deviceState = { oneofKind: void 0 };
var setSdkInfo = (info) => {
  sdkInfo = info;
};
var getSdkInfo = () => {
  return sdkInfo;
};
var setOSInfo = (info) => {
  osInfo = info;
};
var setDeviceInfo = (info) => {
  deviceInfo = info;
};
var getWebRTCInfo = () => {
  return webRtcInfo;
};
var setWebRTCInfo = (info) => {
  webRtcInfo = info;
};
var setThermalState = (state) => {
  if (!osInfo) {
    deviceState = { oneofKind: void 0 };
    return;
  }
  if (osInfo.name === "android") {
    const thermalState = AndroidThermalState[state] || AndroidThermalState.UNSPECIFIED;
    deviceState = {
      oneofKind: "android",
      android: {
        thermalState,
        isPowerSaverMode: deviceState?.oneofKind === "android" && deviceState.android.isPowerSaverMode
      }
    };
  }
  if (osInfo.name.toLowerCase() === "ios") {
    const thermalState = AppleThermalState[state] || AppleThermalState.UNSPECIFIED;
    deviceState = {
      oneofKind: "apple",
      apple: {
        thermalState,
        isLowPowerModeEnabled: deviceState?.oneofKind === "apple" && deviceState.apple.isLowPowerModeEnabled
      }
    };
  }
};
var setPowerState = (powerMode) => {
  if (!osInfo) {
    deviceState = { oneofKind: void 0 };
    return;
  }
  if (osInfo.name === "android") {
    deviceState = {
      oneofKind: "android",
      android: {
        thermalState: deviceState?.oneofKind === "android" ? deviceState.android.thermalState : AndroidThermalState.UNSPECIFIED,
        isPowerSaverMode: powerMode
      }
    };
  }
  if (osInfo.name.toLowerCase() === "ios") {
    deviceState = {
      oneofKind: "apple",
      apple: {
        thermalState: deviceState?.oneofKind === "apple" ? deviceState.apple.thermalState : AppleThermalState.UNSPECIFIED,
        isLowPowerModeEnabled: powerMode
      }
    };
  }
};
var getDeviceState = () => {
  return deviceState;
};
var getClientDetails = async () => {
  if (isReactNative2()) {
    return {
      sdk: sdkInfo,
      os: osInfo,
      device: deviceInfo
    };
  }
  const userAgentDataApi = navigator.userAgentData;
  let userAgentData;
  if (userAgentDataApi && userAgentDataApi.getHighEntropyValues) {
    try {
      userAgentData = await userAgentDataApi.getHighEntropyValues([
        "platform",
        "platformVersion",
        "fullVersionList"
      ]);
    } catch {
    }
  }
  const userAgent = new import_ua_parser_js.UAParser(navigator.userAgent);
  const { browser, os: os2, device, cpu } = userAgent.getResult();
  const uaBrowser = userAgentData?.fullVersionList?.find((v2) => !v2.brand.includes("Chromium") && !v2.brand.match(/[()\-./:;=?_]/g));
  return {
    sdk: sdkInfo,
    browser: {
      name: uaBrowser?.brand || browser.name || navigator.userAgent,
      version: uaBrowser?.version || browser.version || ""
    },
    os: {
      name: userAgentData?.platform || os2.name || "",
      version: userAgentData?.platformVersion || os2.version || "",
      architecture: cpu.architecture || ""
    },
    device: {
      name: [device.vendor, device.model, device.type].filter(Boolean).join(" "),
      version: ""
    }
  };
};
var isSafari = () => {
  if (typeof navigator === "undefined")
    return false;
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent || "");
};
var isFirefox = () => {
  if (typeof navigator === "undefined")
    return false;
  return navigator.userAgent?.includes("Firefox");
};
var isChrome = () => {
  if (typeof navigator === "undefined")
    return false;
  return navigator.userAgent?.includes("Chrome");
};
var isSupportedBrowser = async () => {
  const { browser } = await getClientDetails();
  if (!browser)
    return false;
  const name2 = browser.name.toLowerCase();
  const [major3] = browser.version.split(".");
  const version3 = parseInt(major3, 10);
  return name2.includes("chrome") && version3 >= 124 || name2.includes("edge") && version3 >= 124 || name2.includes("firefox") && version3 >= 124 || name2.includes("safari") && version3 >= 17 || name2.includes("webkit") && version3 >= 605 || // WebView on iOS
  name2.includes("webview") && version3 >= 124;
};
var browsers = Object.freeze({
  __proto__: null,
  isChrome,
  isFirefox,
  isSafari,
  isSupportedBrowser
});
var createStatsReporter = ({ subscriber, publisher, state, datacenter, pollingIntervalInMs = 2e3 }) => {
  const logger = videoLoggerSystem.getLogger("stats");
  const getRawStatsForTrack = async (kind, selector) => {
    if (kind === "subscriber" && subscriber) {
      return subscriber.getStats(selector);
    } else if (kind === "publisher" && publisher) {
      return publisher.getStats(selector);
    } else {
      return void 0;
    }
  };
  const getStatsForStream = async (kind, tracks) => {
    const pc2 = kind === "subscriber" ? subscriber : publisher;
    if (!pc2)
      return [];
    const statsForStream = [];
    for (const track of tracks) {
      const report = await pc2.getStats(track);
      const stats = transform(report, {
        trackKind: track.kind,
        kind,
        publisher: void 0
      });
      statsForStream.push(stats);
    }
    return statsForStream;
  };
  const startReportingStatsFor = (sessionId) => {
    sessionIdsToTrack.add(sessionId);
    void run();
  };
  const stopReportingStatsFor = (sessionId) => {
    sessionIdsToTrack.delete(sessionId);
    void run();
  };
  const sessionIdsToTrack = /* @__PURE__ */ new Set();
  const run = async () => {
    const participantStats = {};
    if (sessionIdsToTrack.size > 0) {
      const sessionIds = new Set(sessionIdsToTrack);
      for (const participant of state.participants) {
        if (!sessionIds.has(participant.sessionId))
          continue;
        const { audioStream, isLocalParticipant, sessionId, userId, videoStream } = participant;
        const kind = isLocalParticipant ? "publisher" : "subscriber";
        try {
          const tracks = isLocalParticipant ? publisher?.getPublishedTracks() || [] : [
            ...videoStream?.getVideoTracks() || [],
            ...audioStream?.getAudioTracks() || []
          ];
          participantStats[sessionId] = await getStatsForStream(kind, tracks);
        } catch (e2) {
          logger.warn(`Failed to collect ${kind} stats for ${userId}`, e2);
        }
      }
    }
    const [subscriberRawStats, publisherRawStats] = await Promise.all([
      getRawStatsForTrack("subscriber"),
      publisher ? getRawStatsForTrack("publisher") : void 0
    ]);
    const process2 = (report, kind) => aggregate(transform(report, { kind, trackKind: "video", publisher }));
    const subscriberStats = subscriberRawStats ? process2(subscriberRawStats, "subscriber") : getEmptyStats();
    const publisherStats = publisherRawStats ? process2(publisherRawStats, "publisher") : getEmptyStats();
    state.setCallStatsReport({
      datacenter,
      publisherStats,
      subscriberStats,
      subscriberRawStats,
      publisherRawStats,
      participants: participantStats,
      timestamp: Date.now()
    });
  };
  let timeoutId;
  if (pollingIntervalInMs > 0) {
    const loop = async () => {
      if (state.isCallStatsReportObserved) {
        await run().catch((e2) => {
          logger.debug("Failed to collect stats", e2);
        });
      }
      timeoutId = setTimeout(loop, pollingIntervalInMs);
    };
    void loop();
  }
  const stop = () => {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  };
  return {
    getRawStatsForTrack,
    getStatsForStream,
    startReportingStatsFor,
    stopReportingStatsFor,
    stop
  };
};
var transform = (report, opts) => {
  const { trackKind, kind, publisher } = opts;
  const direction = kind === "subscriber" ? "inbound-rtp" : "outbound-rtp";
  const stats = flatten(report);
  const streams = stats.filter((stat) => stat.type === direction && stat.kind === trackKind).map((stat) => {
    const rtcStreamStats = stat;
    const codec = stats.find((s2) => s2.type === "codec" && s2.id === rtcStreamStats.codecId);
    const transport = stats.find((s2) => s2.type === "transport" && s2.id === rtcStreamStats.transportId);
    let roundTripTime;
    if (transport && transport.dtlsState === "connected") {
      const candidatePair = stats.find((s2) => s2.type === "candidate-pair" && s2.id === transport.selectedCandidatePairId);
      roundTripTime = candidatePair?.currentRoundTripTime;
    }
    let trackType;
    if (kind === "publisher" && publisher) {
      const firefox = isFirefox();
      const mediaSource = stats.find((s2) => s2.type === "media-source" && // Firefox doesn't have mediaSourceId, so we need to guess the media source
      (firefox ? true : s2.id === rtcStreamStats.mediaSourceId));
      if (mediaSource) {
        trackType = publisher.getTrackType(mediaSource.trackIdentifier);
      }
    }
    return {
      bytesSent: rtcStreamStats.bytesSent,
      bytesReceived: rtcStreamStats.bytesReceived,
      codec: codec?.mimeType,
      currentRoundTripTime: roundTripTime,
      frameHeight: rtcStreamStats.frameHeight,
      frameWidth: rtcStreamStats.frameWidth,
      framesPerSecond: rtcStreamStats.framesPerSecond,
      jitter: rtcStreamStats.jitter,
      kind: rtcStreamStats.kind,
      mediaSourceId: rtcStreamStats.mediaSourceId,
      qualityLimitationReason: rtcStreamStats.qualityLimitationReason,
      rid: rtcStreamStats.rid,
      ssrc: rtcStreamStats.ssrc,
      trackType
    };
  });
  return {
    rawStats: report,
    streams,
    timestamp: Date.now()
  };
};
var getEmptyStats = (stats) => {
  return {
    rawReport: stats ?? { streams: [], timestamp: Date.now() },
    totalBytesSent: 0,
    totalBytesReceived: 0,
    averageJitterInMs: 0,
    averageRoundTripTimeInMs: 0,
    qualityLimitationReasons: "none",
    highestFrameWidth: 0,
    highestFrameHeight: 0,
    highestFramesPerSecond: 0,
    codec: "",
    codecPerTrackType: {},
    timestamp: Date.now()
  };
};
var aggregate = (stats) => {
  const aggregatedStats = getEmptyStats(stats);
  let maxArea = -1;
  const area = (w2, h2) => w2 * h2;
  const qualityLimitationReasons = /* @__PURE__ */ new Set();
  const streams = stats.streams;
  const report = streams.reduce((acc, stream) => {
    acc.totalBytesSent += stream.bytesSent || 0;
    acc.totalBytesReceived += stream.bytesReceived || 0;
    acc.averageJitterInMs += stream.jitter || 0;
    acc.averageRoundTripTimeInMs += stream.currentRoundTripTime || 0;
    const streamArea = area(stream.frameWidth || 0, stream.frameHeight || 0);
    if (streamArea > maxArea) {
      acc.highestFrameWidth = stream.frameWidth || 0;
      acc.highestFrameHeight = stream.frameHeight || 0;
      acc.highestFramesPerSecond = stream.framesPerSecond || 0;
      maxArea = streamArea;
    }
    qualityLimitationReasons.add(stream.qualityLimitationReason || "");
    return acc;
  }, aggregatedStats);
  if (streams.length > 0) {
    report.averageJitterInMs = Math.round(report.averageJitterInMs / streams.length * 1e3);
    report.averageRoundTripTimeInMs = Math.round(report.averageRoundTripTimeInMs / streams.length * 1e3);
    report.codec = streams[0].codec || "";
    report.codecPerTrackType = streams.reduce((acc, stream) => {
      if (stream.trackType) {
        acc[stream.trackType] = stream.codec || "";
      }
      return acc;
    }, {});
  }
  const qualityLimitationReason = [
    qualityLimitationReasons.has("cpu") && "cpu",
    qualityLimitationReasons.has("bandwidth") && "bandwidth",
    qualityLimitationReasons.has("other") && "other"
  ].filter(Boolean).join(", ");
  if (qualityLimitationReason) {
    report.qualityLimitationReasons = qualityLimitationReason;
  }
  return report;
};
var SfuStatsReporter = class {
  constructor(sfuClient, { options, clientDetails, subscriber, publisher, microphone, camera, state, tracer, unifiedSessionId }) {
    this.logger = videoLoggerSystem.getLogger("SfuStatsReporter");
    this.inputDevices = /* @__PURE__ */ new Map();
    this.observeDevice = (device, kind) => {
      const { browserPermissionState$ } = device.state;
      this.unsubscribeDevicePermissionsSubscription?.();
      this.unsubscribeDevicePermissionsSubscription = createSubscription(combineLatest([browserPermissionState$, this.state.ownCapabilities$]), ([browserPermissionState, ownCapabilities]) => {
        this.unsubscribeListDevicesSubscription?.();
        const hasCapability = kind === "mic" ? ownCapabilities.includes(OwnCapability.SEND_AUDIO) : ownCapabilities.includes(OwnCapability.SEND_VIDEO);
        if (browserPermissionState !== "granted" || !hasCapability) {
          this.inputDevices.set(kind, {
            currentDevice: "",
            availableDevices: [],
            isPermitted: false
          });
          return;
        }
        this.unsubscribeListDevicesSubscription = createSubscription(combineLatest([device.listDevices(), device.state.selectedDevice$]), ([devices, deviceId]) => {
          const selected = devices.find((d) => d.deviceId === deviceId);
          this.inputDevices.set(kind, {
            currentDevice: selected?.label || deviceId || "",
            availableDevices: devices.map((d) => d.label),
            isPermitted: true
          });
        });
      });
    };
    this.sendConnectionTime = (connectionTimeSeconds) => {
      this.sendTelemetryData({
        data: {
          oneofKind: "connectionTimeSeconds",
          connectionTimeSeconds
        }
      });
    };
    this.sendReconnectionTime = (strategy, timeSeconds) => {
      this.sendTelemetryData({
        data: {
          oneofKind: "reconnection",
          reconnection: { strategy, timeSeconds }
        }
      });
    };
    this.sendTelemetryData = (telemetryData) => {
      this.run(telemetryData).catch((err) => {
        this.logger.warn("Failed to send telemetry data", err);
      });
    };
    this.run = async (telemetry) => {
      const [subscriberStats, publisherStats] = await Promise.all([
        this.subscriber.stats.get(),
        this.publisher?.stats.get()
      ]);
      this.subscriber.tracer?.trace("getstats", subscriberStats.delta);
      if (publisherStats) {
        this.publisher?.tracer?.trace("getstats", publisherStats.delta);
      }
      const subscriberTrace = this.subscriber.tracer?.take();
      const publisherTrace = this.publisher?.tracer?.take();
      const tracer2 = this.tracer.take();
      const sfuTrace = this.sfuClient.getTrace();
      const traces = [
        ...tracer2.snapshot,
        ...sfuTrace?.snapshot ?? [],
        ...publisherTrace?.snapshot ?? [],
        ...subscriberTrace?.snapshot ?? []
      ];
      try {
        await this.sfuClient.sendStats({
          sdk: this.sdkName,
          sdkVersion: this.sdkVersion,
          webrtcVersion: this.webRTCVersion,
          subscriberStats: JSON.stringify(flatten(subscriberStats.stats)),
          publisherStats: publisherStats ? JSON.stringify(flatten(publisherStats.stats)) : "[]",
          subscriberRtcStats: "",
          publisherRtcStats: "",
          rtcStats: JSON.stringify(traces),
          encodeStats: publisherStats?.performanceStats ?? [],
          decodeStats: subscriberStats.performanceStats,
          audioDevices: this.inputDevices.get("mic"),
          videoDevices: this.inputDevices.get("camera"),
          unifiedSessionId: this.unifiedSessionId,
          deviceState: getDeviceState(),
          telemetry
        });
      } catch (err) {
        publisherTrace?.rollback();
        subscriberTrace?.rollback();
        tracer2.rollback();
        sfuTrace?.rollback();
        throw err;
      }
    };
    this.start = () => {
      if (this.options.reporting_interval_ms <= 0)
        return;
      this.observeDevice(this.microphone, "mic");
      this.observeDevice(this.camera, "camera");
      clearInterval(this.intervalId);
      this.intervalId = setInterval(() => {
        this.run().catch((err) => {
          this.logger.warn("Failed to report stats", err);
        });
      }, this.options.reporting_interval_ms);
    };
    this.stop = () => {
      this.unsubscribeDevicePermissionsSubscription?.();
      this.unsubscribeDevicePermissionsSubscription = void 0;
      this.unsubscribeListDevicesSubscription?.();
      this.unsubscribeListDevicesSubscription = void 0;
      this.inputDevices.clear();
      clearInterval(this.intervalId);
      this.intervalId = void 0;
      clearTimeout(this.timeoutId);
      this.timeoutId = void 0;
    };
    this.flush = () => {
      this.run().catch((err) => {
        this.logger.warn("Failed to flush report stats", err);
      });
    };
    this.scheduleOne = (timeout2) => {
      clearTimeout(this.timeoutId);
      this.timeoutId = setTimeout(() => {
        this.run().catch((err) => {
          this.logger.warn("Failed to report stats", err);
        });
      }, timeout2);
    };
    this.sfuClient = sfuClient;
    this.options = options;
    this.subscriber = subscriber;
    this.publisher = publisher;
    this.microphone = microphone;
    this.camera = camera;
    this.state = state;
    this.tracer = tracer;
    this.unifiedSessionId = unifiedSessionId;
    const { sdk, browser } = clientDetails;
    this.sdkName = getSdkName(sdk);
    this.sdkVersion = getSdkVersion(sdk);
    const webRTCInfo = getWebRTCInfo();
    this.webRTCVersion = webRTCInfo?.version || `${browser?.name || ""}-${browser?.version || ""}` || "N/A";
  }
};
var traceRTCPeerConnection = (pc2, trace) => {
  pc2.addEventListener("icecandidate", (e2) => {
    trace("onicecandidate", e2.candidate);
  });
  pc2.addEventListener("track", (e2) => {
    const streams = e2.streams.map((stream) => `stream:${stream.id}`);
    trace("ontrack", `${e2.track.kind}:${e2.track.id} ${streams}`);
  });
  pc2.addEventListener("signalingstatechange", () => {
    trace("signalingstatechange", pc2.signalingState);
  });
  pc2.addEventListener("iceconnectionstatechange", () => {
    trace("iceconnectionstatechange", pc2.iceConnectionState);
  });
  pc2.addEventListener("icegatheringstatechange", () => {
    trace("icegatheringstatechange", pc2.iceGatheringState);
  });
  pc2.addEventListener("connectionstatechange", () => {
    trace("connectionstatechange", pc2.connectionState);
  });
  pc2.addEventListener("negotiationneeded", () => {
    trace("negotiationneeded", void 0);
  });
  pc2.addEventListener("datachannel", ({ channel }) => {
    trace("datachannel", [channel.id, channel.label]);
  });
  const origClose = pc2.close;
  pc2.close = function tracedClose() {
    trace("close", void 0);
    return origClose.call(this);
  };
  for (const method of [
    "createOffer",
    "createAnswer",
    "setLocalDescription",
    "setRemoteDescription",
    "addIceCandidate"
  ]) {
    const original = pc2[method];
    if (!original)
      continue;
    pc2[method] = async function tracedMethod(...args) {
      try {
        trace(method, args);
        const result = await original.apply(this, args);
        trace(`${method}OnSuccess`, result);
        return result;
      } catch (err) {
        trace(`${method}OnFailure`, err.toString());
        throw err;
      }
    };
  }
};
var StatsTracer = class {
  /**
   * Creates a new StatsTracer instance.
   */
  constructor(pc2, peerType, trackIdToTrackType) {
    this.previousStats = {};
    this.frameTimeHistory = [];
    this.fpsHistory = [];
    this.get = async () => {
      const stats = await this.pc.getStats();
      const currentStats = toObject(stats);
      const performanceStats = this.withOverrides(this.peerType === PeerType.SUBSCRIBER ? this.getDecodeStats(currentStats) : this.getEncodeStats(currentStats));
      const delta = deltaCompression(this.previousStats, currentStats);
      this.previousStats = currentStats;
      this.frameTimeHistory = this.frameTimeHistory.slice(-2);
      this.fpsHistory = this.fpsHistory.slice(-2);
      return { performanceStats, delta, stats };
    };
    this.getEncodeStats = (currentStats) => {
      const encodeStats = [];
      for (const rtp of Object.values(currentStats)) {
        if (rtp.type !== "outbound-rtp")
          continue;
        const { codecId, framesSent = 0, kind, id, totalEncodeTime = 0, framesPerSecond = 0, frameHeight = 0, frameWidth = 0, targetBitrate = 0, mediaSourceId } = rtp;
        if (kind === "audio" || !this.previousStats[id])
          continue;
        const prevRtp = this.previousStats[id];
        const deltaTotalEncodeTime = totalEncodeTime - (prevRtp.totalEncodeTime || 0);
        const deltaFramesSent = framesSent - (prevRtp.framesSent || 0);
        const framesEncodeTime = deltaFramesSent > 0 ? deltaTotalEncodeTime / deltaFramesSent * 1e3 : 0;
        this.frameTimeHistory.push(framesEncodeTime);
        this.fpsHistory.push(framesPerSecond);
        let trackType = TrackType.VIDEO;
        if (mediaSourceId && currentStats[mediaSourceId]) {
          const mediaSource = currentStats[mediaSourceId];
          trackType = this.trackIdToTrackType.get(mediaSource.trackIdentifier) || trackType;
        }
        encodeStats.push({
          trackType,
          codec: getCodecFromStats(currentStats, codecId),
          avgFrameTimeMs: average(this.frameTimeHistory),
          avgFps: average(this.fpsHistory),
          targetBitrate: Math.round(targetBitrate),
          videoDimension: { width: frameWidth, height: frameHeight }
        });
      }
      return encodeStats;
    };
    this.getDecodeStats = (currentStats) => {
      let rtp = void 0;
      let max2 = 0;
      for (const item of Object.values(currentStats)) {
        if (item.type !== "inbound-rtp")
          continue;
        const rtpItem = item;
        const { kind, frameWidth = 0, frameHeight = 0 } = rtpItem;
        const area = frameWidth * frameHeight;
        if (kind === "video" && area > max2) {
          rtp = rtpItem;
          max2 = area;
        }
      }
      if (!rtp || !this.previousStats[rtp.id])
        return [];
      const prevRtp = this.previousStats[rtp.id];
      const { framesDecoded = 0, framesPerSecond = 0, totalDecodeTime = 0, trackIdentifier } = rtp;
      const deltaTotalDecodeTime = totalDecodeTime - (prevRtp.totalDecodeTime || 0);
      const deltaFramesDecoded = framesDecoded - (prevRtp.framesDecoded || 0);
      const framesDecodeTime = deltaFramesDecoded > 0 ? deltaTotalDecodeTime / deltaFramesDecoded * 1e3 : 0;
      this.frameTimeHistory.push(framesDecodeTime);
      this.fpsHistory.push(framesPerSecond);
      const trackType = this.trackIdToTrackType.get(trackIdentifier) || TrackType.VIDEO;
      return [
        PerformanceStats.create({
          trackType,
          codec: getCodecFromStats(currentStats, rtp.codecId),
          avgFrameTimeMs: average(this.frameTimeHistory),
          avgFps: average(this.fpsHistory),
          videoDimension: { width: rtp.frameWidth, height: rtp.frameHeight }
        })
      ];
    };
    this.withOverrides = (performanceStats) => {
      if (this.costOverrides) {
        for (const s2 of performanceStats) {
          const override = this.costOverrides.get(s2.trackType);
          if (override !== void 0) {
            s2.avgFrameTimeMs = override + (s2.avgFrameTimeMs || 0) / 1e3;
          }
        }
      }
      return performanceStats;
    };
    this.setCost = (cost, trackType = TrackType.VIDEO) => {
      if (!this.costOverrides)
        this.costOverrides = /* @__PURE__ */ new Map();
      this.costOverrides.set(trackType, cost);
    };
    this.pc = pc2;
    this.peerType = peerType;
    this.trackIdToTrackType = trackIdToTrackType;
  }
};
var toObject = (report) => {
  const obj = {};
  report.forEach((v2, k2) => {
    obj[k2] = v2;
  });
  return obj;
};
var deltaCompression = (oldStats, newStats) => {
  newStats = JSON.parse(JSON.stringify(newStats));
  for (const [id, report] of Object.entries(newStats)) {
    delete report.id;
    if (!oldStats[id])
      continue;
    for (const [name2, value] of Object.entries(report)) {
      if (value === oldStats[id][name2]) {
        delete report[name2];
      }
    }
  }
  let timestamp2 = -Infinity;
  const values = Object.values(newStats);
  for (const report of values) {
    if (report.timestamp > timestamp2) {
      timestamp2 = report.timestamp;
    }
  }
  for (const report of values) {
    if (report.timestamp === timestamp2) {
      report.timestamp = 0;
    }
  }
  newStats.timestamp = timestamp2;
  return newStats;
};
var average = (arr) => arr.reduce((a2, b2) => a2 + b2, 0) / arr.length;
var getCodecFromStats = (stats, codecId) => {
  if (!codecId || !stats[codecId])
    return;
  const codecStats = stats[codecId];
  return Codec.create({
    name: codecStats.mimeType.split("/").pop(),
    // video/av1 -> av1
    clockRate: codecStats.clockRate,
    payloadType: codecStats.payloadType,
    fmtp: codecStats.sdpFmtpLine
  });
};
var Tracer = class {
  constructor(id) {
    this.buffer = [];
    this.enabled = true;
    this.setEnabled = (enabled) => {
      if (this.enabled === enabled)
        return;
      this.enabled = enabled;
      this.buffer = [];
    };
    this.trace = (tag, data) => {
      if (!this.enabled)
        return;
      this.buffer.push([tag, this.id, data, Date.now()]);
    };
    this.traceOnce = (key, tag, data) => {
      if (this.keys?.has(key))
        return;
      this.trace(tag, data);
      (this.keys ?? (this.keys = /* @__PURE__ */ new Map())).set(key, true);
    };
    this.resetTrace = (key) => {
      this.keys?.delete(key);
    };
    this.take = () => {
      const snapshot = this.buffer;
      this.buffer = [];
      return {
        snapshot,
        rollback: () => {
          this.buffer.unshift(...snapshot);
        }
      };
    };
    this.dispose = () => {
      this.buffer = [];
      this.keys?.clear();
    };
    this.id = id;
  }
};
var BasePeerConnection = class {
  /**
   * Constructs a new `BasePeerConnection` instance.
   */
  constructor(peerType, { sfuClient, connectionConfig, state, dispatcher, onReconnectionNeeded, tag, enableTracing, clientPublishOptions, iceRestartDelay = 2500 }) {
    this.isIceRestarting = false;
    this.isDisposed = false;
    this.trackIdToTrackType = /* @__PURE__ */ new Map();
    this.subscriptions = [];
    this.lock = Math.random().toString(36).slice(2);
    this.createPeerConnection = (connectionConfig2) => {
      const pc2 = new RTCPeerConnection(connectionConfig2);
      pc2.addEventListener("icecandidate", this.onIceCandidate);
      pc2.addEventListener("icecandidateerror", this.onIceCandidateError);
      pc2.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      pc2.addEventListener("icegatheringstatechange", this.onIceGatherChange);
      pc2.addEventListener("signalingstatechange", this.onSignalingChange);
      pc2.addEventListener("connectionstatechange", this.onConnectionStateChange);
      return pc2;
    };
    this.tryRestartIce = () => {
      this.restartIce().catch((e2) => {
        const reason = "restartICE() failed, initiating reconnect";
        this.logger.error(reason, e2);
        const strategy = e2 instanceof NegotiationError && e2.error.code === ErrorCode.PARTICIPANT_SIGNAL_LOST ? WebsocketReconnectStrategy.FAST : WebsocketReconnectStrategy.REJOIN;
        this.onReconnectionNeeded?.(strategy, reason, this.peerType);
      });
    };
    this.on = (event, fn2) => {
      this.subscriptions.push(this.dispatcher.on(event, (e2) => {
        const lockKey = `pc.${this.lock}.${event}`;
        withoutConcurrency(lockKey, async () => fn2(e2)).catch((err) => {
          if (this.isDisposed)
            return;
          this.logger.warn(`Error handling ${event}`, err);
        });
      }));
    };
    this.addTrickledIceCandidates = () => {
      const { iceTrickleBuffer } = this.sfuClient;
      const observable2 = this.peerType === PeerType.SUBSCRIBER ? iceTrickleBuffer.subscriberCandidates : iceTrickleBuffer.publisherCandidates;
      this.unsubscribeIceTrickle?.();
      this.unsubscribeIceTrickle = createSafeAsyncSubscription(observable2, async (candidate) => {
        return this.pc.addIceCandidate(candidate).catch((e2) => {
          if (this.isDisposed)
            return;
          this.logger.warn(`ICE candidate error`, e2, candidate);
        });
      });
    };
    this.setSfuClient = (sfuClient2) => {
      this.sfuClient = sfuClient2;
    };
    this.getStats = (selector) => {
      return this.pc.getStats(selector);
    };
    this.getTrackType = (trackId) => {
      return this.trackIdToTrackType.get(trackId);
    };
    this.isHealthy = () => {
      const failedStates = /* @__PURE__ */ new Set(["failed", "closed"]);
      const iceState = this.pc.iceConnectionState;
      const connectionState = this.pc.connectionState;
      return !failedStates.has(iceState) && !failedStates.has(connectionState);
    };
    this.onIceCandidate = (e2) => {
      const { candidate } = e2;
      if (!candidate) {
        this.logger.debug("null ice candidate");
        return;
      }
      const iceCandidate = this.asJSON(candidate);
      this.sfuClient.iceTrickle({ peerType: this.peerType, iceCandidate }).catch((err) => {
        if (this.isDisposed)
          return;
        this.logger.warn(`ICETrickle failed`, err);
      });
    };
    this.asJSON = (candidate) => {
      if (!candidate.usernameFragment) {
        const segments = candidate.candidate.split(" ");
        const ufragIndex = segments.findIndex((s2) => s2 === "ufrag") + 1;
        const usernameFragment = segments[ufragIndex];
        return JSON.stringify({ ...candidate, usernameFragment });
      }
      return JSON.stringify(candidate.toJSON());
    };
    this.onConnectionStateChange = async () => {
      const state2 = this.pc.connectionState;
      this.logger.debug(`Connection state changed`, state2);
      if (this.tracer && (state2 === "connected" || state2 === "failed")) {
        try {
          const stats = await this.stats.get();
          this.tracer.trace("getstats", stats.delta);
        } catch (err) {
          this.tracer.trace("getstatsOnFailure", err.toString());
        }
      }
      if (state2 === "failed") {
        this.onReconnectionNeeded?.(WebsocketReconnectStrategy.REJOIN, "Connection failed", this.peerType);
        return;
      }
      this.handleConnectionStateUpdate(state2);
    };
    this.onIceConnectionStateChange = () => {
      const state2 = this.pc.iceConnectionState;
      this.logger.debug(`ICE connection state changed`, state2);
      this.handleConnectionStateUpdate(state2);
    };
    this.handleConnectionStateUpdate = (state2) => {
      const { callingState } = this.state;
      if (callingState === CallingState.OFFLINE)
        return;
      if (callingState === CallingState.RECONNECTING)
        return;
      if (this.isIceRestarting)
        return;
      switch (state2) {
        case "failed":
          this.logger.info("restartICE due to failed connection");
          this.tryRestartIce();
          break;
        case "disconnected":
          this.logger.info("disconnected connection, scheduling restartICE");
          clearTimeout(this.iceRestartTimeout);
          this.iceRestartTimeout = setTimeout(() => {
            const currentState = this.pc.iceConnectionState;
            if (currentState === "disconnected" || currentState === "failed") {
              this.tryRestartIce();
            }
          }, this.iceRestartDelay);
          break;
        case "connected":
          if (this.iceRestartTimeout) {
            this.logger.info("connected connection, canceling restartICE");
            clearTimeout(this.iceRestartTimeout);
            this.iceRestartTimeout = void 0;
          }
          break;
      }
    };
    this.onIceCandidateError = (e2) => {
      const errorMessage = e2 instanceof RTCPeerConnectionIceErrorEvent ? `${e2.errorCode}: ${e2.errorText}` : e2;
      this.logger.debug("ICE Candidate error", errorMessage);
    };
    this.onIceGatherChange = () => {
      this.logger.debug(`ICE Gathering State`, this.pc.iceGatheringState);
    };
    this.onSignalingChange = () => {
      this.logger.debug(`Signaling state changed`, this.pc.signalingState);
    };
    this.peerType = peerType;
    this.sfuClient = sfuClient;
    this.state = state;
    this.dispatcher = dispatcher;
    this.iceRestartDelay = iceRestartDelay;
    this.clientPublishOptions = clientPublishOptions;
    this.onReconnectionNeeded = onReconnectionNeeded;
    this.logger = videoLoggerSystem.getLogger(peerType === PeerType.SUBSCRIBER ? "Subscriber" : "Publisher", { tags: [tag] });
    this.pc = this.createPeerConnection(connectionConfig);
    this.stats = new StatsTracer(this.pc, peerType, this.trackIdToTrackType);
    if (enableTracing) {
      this.tracer = new Tracer(`${tag}-${peerType === PeerType.SUBSCRIBER ? "sub" : "pub"}`);
      this.tracer.trace("create", {
        url: sfuClient.edgeName,
        ...connectionConfig
      });
      traceRTCPeerConnection(this.pc, this.tracer.trace);
    }
  }
  /**
   * Disposes the `RTCPeerConnection` instance.
   */
  dispose() {
    clearTimeout(this.iceRestartTimeout);
    this.iceRestartTimeout = void 0;
    this.onReconnectionNeeded = void 0;
    this.isDisposed = true;
    this.detachEventHandlers();
    this.pc.close();
    this.tracer?.dispose();
  }
  /**
   * Detaches the event handlers from the `RTCPeerConnection`.
   */
  detachEventHandlers() {
    const pc2 = this.pc;
    pc2.removeEventListener("icecandidate", this.onIceCandidate);
    pc2.removeEventListener("icecandidateerror", this.onIceCandidateError);
    pc2.removeEventListener("signalingstatechange", this.onSignalingChange);
    pc2.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
    pc2.removeEventListener("icegatheringstatechange", this.onIceGatherChange);
    this.unsubscribeIceTrickle?.();
    this.subscriptions.forEach((unsubscribe) => unsubscribe());
  }
};
var TransceiverCache = class {
  constructor() {
    this.cache = [];
    this.layers = [];
    this.transceiverOrder = [];
    this.add = (bundle) => {
      this.cache.push(bundle);
      this.transceiverOrder.push(bundle.transceiver);
    };
    this.get = (publishOption) => {
      return this.cache.find((bundle) => bundle.publishOption.id === publishOption.id && bundle.publishOption.trackType === publishOption.trackType);
    };
    this.update = (publishOption, patch3) => {
      const bundle = this.get(publishOption);
      if (bundle)
        Object.assign(bundle, patch3);
    };
    this.has = (publishOption) => {
      return !!this.get(publishOption);
    };
    this.find = (predicate) => {
      return this.cache.find(predicate);
    };
    this.items = () => {
      return this.cache;
    };
    this.indexOf = (transceiver) => {
      return this.transceiverOrder.indexOf(transceiver);
    };
    this.getLayers = (publishOption) => {
      const entry = this.layers.find((item) => item.publishOption.id === publishOption.id && item.publishOption.trackType === publishOption.trackType);
      return entry?.layers;
    };
    this.setLayers = (publishOption, layers = []) => {
      const entry = this.findLayer(publishOption);
      if (entry) {
        entry.layers = layers;
      } else {
        this.layers.push({ publishOption, layers });
      }
    };
    this.findLayer = (publishOption) => {
      return this.layers.find((item) => item.publishOption.id === publishOption.id && item.publishOption.trackType === publishOption.trackType);
    };
  }
};
var ensureExhausted = (x2, message) => {
  videoLoggerSystem.getLogger("helpers").warn(message, x2);
};
var trackTypeToParticipantStreamKey = (trackType) => {
  switch (trackType) {
    case TrackType.SCREEN_SHARE:
      return "screenShareStream";
    case TrackType.SCREEN_SHARE_AUDIO:
      return "screenShareAudioStream";
    case TrackType.VIDEO:
      return "videoStream";
    case TrackType.AUDIO:
      return "audioStream";
    case TrackType.UNSPECIFIED:
      throw new Error("Track type is unspecified");
    default:
      ensureExhausted(trackType, "Unknown track type");
  }
};
var muteTypeToTrackType = (muteType) => {
  switch (muteType) {
    case "audio":
      return TrackType.AUDIO;
    case "video":
      return TrackType.VIDEO;
    case "screenshare":
      return TrackType.SCREEN_SHARE;
    case "screenshare_audio":
      return TrackType.SCREEN_SHARE_AUDIO;
    default:
      ensureExhausted(muteType, "Unknown mute type");
  }
};
var toTrackType = (trackType) => {
  switch (trackType) {
    case "TRACK_TYPE_AUDIO":
      return TrackType.AUDIO;
    case "TRACK_TYPE_VIDEO":
      return TrackType.VIDEO;
    case "TRACK_TYPE_SCREEN_SHARE":
      return TrackType.SCREEN_SHARE;
    case "TRACK_TYPE_SCREEN_SHARE_AUDIO":
      return TrackType.SCREEN_SHARE_AUDIO;
    default:
      return void 0;
  }
};
var isAudioTrackType = (trackType) => trackType === TrackType.AUDIO || trackType === TrackType.SCREEN_SHARE_AUDIO;
var computeAudioLayers = (publishOption, options) => {
  const { audioBitrateProfile } = options;
  const profileConfig = publishOption.audioBitrateProfiles?.find((config2) => config2.profile === audioBitrateProfile);
  const maxBitrate = profileConfig?.bitrate || {
    [AudioBitrateProfile.VOICE_STANDARD_UNSPECIFIED]: 64e3,
    [AudioBitrateProfile.VOICE_HIGH_QUALITY]: 128e3,
    [AudioBitrateProfile.MUSIC_HIGH_QUALITY]: 128e3
  }[audioBitrateProfile || AudioBitrateProfile.VOICE_STANDARD_UNSPECIFIED];
  return [{ maxBitrate }];
};
var toSvcEncodings = (layers) => {
  if (!layers)
    return;
  const withRid = (rid) => (layer) => layer.rid === rid;
  const highestLayer = layers.find(withRid("f")) || layers.find(withRid("h")) || layers.find(withRid("q"));
  return [{ ...highestLayer, rid: "q" }];
};
var ridToVideoQuality = (rid) => {
  return rid === "q" ? VideoQuality.LOW_UNSPECIFIED : rid === "h" ? VideoQuality.MID : VideoQuality.HIGH;
};
var toVideoLayers = (layers = []) => {
  return layers.map((layer) => ({
    rid: layer.rid || "",
    bitrate: layer.maxBitrate || 0,
    fps: layer.maxFramerate || 0,
    quality: ridToVideoQuality(layer.rid || ""),
    videoDimension: { width: layer.width, height: layer.height }
  }));
};
var toScalabilityMode = (spatialLayers, temporalLayers) => `L${spatialLayers}T${temporalLayers}${spatialLayers > 1 ? "_KEY" : ""}`;
var computeVideoLayers = (videoTrack, publishOption) => {
  if (isAudioTrackType(publishOption.trackType))
    return;
  const optimalVideoLayers = [];
  const { bitrate, codec, fps = 30, maxSpatialLayers = 3, maxTemporalLayers = 3, videoDimension = { width: 1280, height: 720 }, useSingleLayer } = publishOption;
  const { width = videoDimension.width, height = videoDimension.height } = videoTrack.getSettings();
  const maxBitrate = getComputedMaxBitrate(videoDimension, width, height, bitrate);
  let downscaleFactor = 1;
  let bitrateFactor = 1;
  const svcCodec = isSvcCodec(codec?.name);
  for (const rid of ["f", "h", "q"].slice(0, maxSpatialLayers)) {
    const layer = {
      active: true,
      rid,
      width: Math.round(width / downscaleFactor),
      height: Math.round(height / downscaleFactor),
      maxBitrate: Math.round(maxBitrate / bitrateFactor) || { q: 3e5, h: 75e4, f: 125e4 }[rid],
      maxFramerate: fps
    };
    if (svcCodec) {
      layer.scalabilityMode = toScalabilityMode(useSingleLayer ? 1 : maxSpatialLayers, maxTemporalLayers);
    } else {
      layer.scaleResolutionDownBy = downscaleFactor;
    }
    downscaleFactor *= 2;
    bitrateFactor *= 2;
    optimalVideoLayers.unshift(layer);
  }
  return withSimulcastConstraints(width, height, optimalVideoLayers, useSingleLayer);
};
var getComputedMaxBitrate = (targetResolution, currentWidth, currentHeight, bitrate) => {
  const { width: targetWidth, height: targetHeight } = targetResolution;
  if (currentWidth < targetWidth || currentHeight < targetHeight) {
    const currentPixels = currentWidth * currentHeight;
    const targetPixels = targetWidth * targetHeight;
    const reductionFactor = currentPixels / targetPixels;
    return Math.round(bitrate * reductionFactor);
  }
  return bitrate;
};
var withSimulcastConstraints = (width, height, optimalVideoLayers, useSingleLayer) => {
  let layers;
  const size2 = Math.max(width, height);
  if (size2 <= 320) {
    layers = optimalVideoLayers.filter((layer) => layer.rid === "f");
  } else if (size2 <= 640) {
    layers = optimalVideoLayers.filter((layer) => layer.rid !== "q");
  } else {
    layers = optimalVideoLayers;
  }
  const ridMapping = ["q", "h", "f"];
  return layers.map((layer, index, arr) => ({
    ...layer,
    rid: ridMapping[index],
    // reassign rid
    active: useSingleLayer && index < arr.length - 1 ? false : layer.active
  }));
};
var Publisher = class extends BasePeerConnection {
  /**
   * Constructs a new `Publisher` instance.
   */
  constructor(baseOptions, publishOptions) {
    super(PeerType.PUBLISHER_UNSPECIFIED, baseOptions);
    this.transceiverCache = new TransceiverCache();
    this.clonedTracks = /* @__PURE__ */ new Set();
    this.publish = async (track, trackType, options = {}) => {
      if (!this.publishOptions.some((o2) => o2.trackType === trackType)) {
        throw new Error(`No publish options found for ${TrackType[trackType]}`);
      }
      for (const publishOption of this.publishOptions) {
        if (publishOption.trackType !== trackType)
          continue;
        const trackToPublish = this.cloneTrack(track);
        const { transceiver } = this.transceiverCache.get(publishOption) || {};
        if (!transceiver) {
          await this.addTransceiver(trackToPublish, publishOption, options);
        } else {
          const previousTrack = transceiver.sender.track;
          await this.updateTransceiver(transceiver, trackToPublish, trackType, options);
          if (!isReactNative2()) {
            this.stopTrack(previousTrack);
          }
        }
      }
    };
    this.addTransceiver = async (track, publishOption, options) => {
      const encodings = isAudioTrackType(publishOption.trackType) ? computeAudioLayers(publishOption, options) : computeVideoLayers(track, publishOption);
      const sendEncodings = isSvcCodec(publishOption.codec?.name) ? toSvcEncodings(encodings) : encodings;
      const transceiver = this.pc.addTransceiver(track, {
        direction: "sendonly",
        sendEncodings
      });
      const params = transceiver.sender.getParameters();
      params.degradationPreference = "maintain-framerate";
      await transceiver.sender.setParameters(params);
      const trackType = publishOption.trackType;
      this.logger.debug(`Added ${TrackType[trackType]} transceiver`);
      this.transceiverCache.add({ publishOption, transceiver, options });
      this.trackIdToTrackType.set(track.id, trackType);
      await this.negotiate();
    };
    this.updateTransceiver = async (transceiver, track, trackType, options = {}) => {
      const sender = transceiver.sender;
      if (sender.track)
        this.trackIdToTrackType.delete(sender.track.id);
      await sender.replaceTrack(track);
      if (track)
        this.trackIdToTrackType.set(track.id, trackType);
      if (isAudioTrackType(trackType)) {
        await this.updateAudioPublishOptions(trackType, options);
      }
    };
    this.updateAudioPublishOptions = async (trackType, options) => {
      for (const publishOption of this.publishOptions) {
        if (publishOption.trackType !== trackType)
          continue;
        const bundle = this.transceiverCache.get(publishOption);
        if (!bundle)
          continue;
        const { transceiver, options: current } = bundle;
        if (current.audioBitrateProfile !== options.audioBitrateProfile) {
          const encodings = computeAudioLayers(publishOption, options);
          if (encodings && encodings.length > 0) {
            const params = transceiver.sender.getParameters();
            const [currentEncoding] = params.encodings;
            const [targetEncoding] = encodings;
            if (currentEncoding.maxBitrate !== targetEncoding.maxBitrate) {
              currentEncoding.maxBitrate = targetEncoding.maxBitrate;
            }
            await transceiver.sender.setParameters(params);
          }
        }
        this.transceiverCache.update(publishOption, { options });
      }
    };
    this.syncPublishOptions = async () => {
      for (const publishOption of this.publishOptions) {
        const { trackType } = publishOption;
        if (!this.isPublishing(trackType))
          continue;
        if (this.transceiverCache.has(publishOption))
          continue;
        const item = this.transceiverCache.find((i2) => !!i2.transceiver.sender.track && i2.publishOption.trackType === trackType);
        if (!item)
          continue;
        const track = this.cloneTrack(item.transceiver.sender.track);
        await this.addTransceiver(track, publishOption, item.options);
      }
      for (const item of this.transceiverCache.items()) {
        const { publishOption, transceiver } = item;
        const hasPublishOption = this.publishOptions.some((option) => option.id === publishOption.id && option.trackType === publishOption.trackType);
        if (hasPublishOption)
          continue;
        this.stopTrack(transceiver.sender.track);
        await this.updateTransceiver(transceiver, null, publishOption.trackType);
      }
    };
    this.isPublishing = (trackType) => {
      for (const item of this.transceiverCache.items()) {
        if (trackType && item.publishOption.trackType !== trackType)
          continue;
        const track = item.transceiver.sender.track;
        if (!track)
          continue;
        if (track.readyState === "live" && track.enabled)
          return true;
      }
      return false;
    };
    this.stopTracks = (...trackTypes) => {
      for (const item of this.transceiverCache.items()) {
        const { publishOption, transceiver } = item;
        if (!trackTypes.includes(publishOption.trackType))
          continue;
        this.stopTrack(transceiver.sender.track);
      }
    };
    this.stopAllTracks = () => {
      for (const { transceiver } of this.transceiverCache.items()) {
        this.stopTrack(transceiver.sender.track);
      }
      for (const track of this.clonedTracks) {
        this.stopTrack(track);
      }
    };
    this.changePublishQuality = async (videoSender) => {
      const { trackType, layers, publishOptionId } = videoSender;
      const enabledLayers = layers.filter((l) => l.active);
      const tag = "Update publish quality:";
      this.logger.info(`${tag} requested layers by SFU:`, enabledLayers);
      const transceiverId = this.transceiverCache.find((t2) => t2.publishOption.id === publishOptionId && t2.publishOption.trackType === trackType);
      const sender = transceiverId?.transceiver.sender;
      if (!sender) {
        return this.logger.warn(`${tag} no video sender found.`);
      }
      const params = sender.getParameters();
      if (params.encodings.length === 0) {
        return this.logger.warn(`${tag} there are no encodings set.`);
      }
      const codecInUse = transceiverId?.publishOption.codec?.name;
      const usesSvcCodec = codecInUse && isSvcCodec(codecInUse);
      let changed = false;
      for (const encoder of params.encodings) {
        const layer = usesSvcCodec ? (
          // for SVC, we only have one layer (q) and often rid is omitted
          enabledLayers[0]
        ) : (
          // for non-SVC, we need to find the layer by rid (simulcast)
          enabledLayers.find((l) => l.name === encoder.rid) ?? (params.encodings.length === 1 ? enabledLayers[0] : void 0)
        );
        const shouldActivate = !!layer?.active;
        if (shouldActivate !== encoder.active) {
          encoder.active = shouldActivate;
          changed = true;
        }
        if (!layer)
          continue;
        const { maxFramerate, scaleResolutionDownBy, maxBitrate, scalabilityMode } = layer;
        if (scaleResolutionDownBy >= 1 && scaleResolutionDownBy !== encoder.scaleResolutionDownBy) {
          encoder.scaleResolutionDownBy = scaleResolutionDownBy;
          changed = true;
        }
        if (maxBitrate > 0 && maxBitrate !== encoder.maxBitrate) {
          encoder.maxBitrate = maxBitrate;
          changed = true;
        }
        if (maxFramerate > 0 && maxFramerate !== encoder.maxFramerate) {
          encoder.maxFramerate = maxFramerate;
          changed = true;
        }
        if (scalabilityMode && scalabilityMode !== encoder.scalabilityMode) {
          encoder.scalabilityMode = scalabilityMode;
          changed = true;
        }
      }
      const activeEncoders = params.encodings.filter((e2) => e2.active);
      if (!changed) {
        return this.logger.info(`${tag} no change:`, activeEncoders);
      }
      await sender.setParameters(params);
      this.logger.info(`${tag} enabled rids:`, activeEncoders);
    };
    this.restartIce = async () => {
      this.logger.debug("Restarting ICE connection");
      const signalingState = this.pc.signalingState;
      if (this.isIceRestarting || signalingState === "have-local-offer") {
        this.logger.debug("ICE restart is already in progress");
        return;
      }
      await this.negotiate({ iceRestart: true });
    };
    this.negotiate = async (options) => {
      return withoutConcurrency(`publisher.negotiate.${this.lock}`, async () => {
        const offer = await this.pc.createOffer(options);
        const tracks = this.getAnnouncedTracks(offer.sdp);
        if (!tracks.length)
          throw new Error(`Can't negotiate without any tracks`);
        try {
          this.isIceRestarting = options?.iceRestart ?? false;
          await this.pc.setLocalDescription(offer);
          const { sdp: baseSdp = "" } = offer;
          const { dangerouslyForceCodec, fmtpLine } = this.clientPublishOptions || {};
          const sdp2 = dangerouslyForceCodec ? removeCodecsExcept(baseSdp, dangerouslyForceCodec, fmtpLine) : baseSdp;
          const { response } = await this.sfuClient.setPublisher({ sdp: sdp2, tracks });
          if (response.error)
            throw new NegotiationError(response.error);
          const { sdp: answerSdp } = response;
          await this.pc.setRemoteDescription({ type: "answer", sdp: answerSdp });
        } catch (err) {
          if (this.pc.signalingState === "have-local-offer") {
            await this.pc.setLocalDescription({ type: "rollback" });
          }
          throw err;
        } finally {
          this.isIceRestarting = false;
        }
        this.addTrickledIceCandidates();
      });
    };
    this.getPublishedTracks = () => {
      const tracks = [];
      for (const { transceiver } of this.transceiverCache.items()) {
        const track = transceiver.sender.track;
        if (track && track.readyState === "live")
          tracks.push(track);
      }
      return tracks;
    };
    this.getAnnouncedTracks = (sdp2) => {
      const trackInfos = [];
      for (const bundle of this.transceiverCache.items()) {
        if (!bundle.transceiver.sender.track)
          continue;
        trackInfos.push(this.toTrackInfo(bundle, sdp2));
      }
      return trackInfos;
    };
    this.getAnnouncedTracksForReconnect = () => {
      const sdp2 = this.pc.localDescription?.sdp;
      const trackInfos = [];
      for (const publishOption of this.publishOptions) {
        const bundle = this.transceiverCache.get(publishOption);
        if (!bundle || !bundle.transceiver.sender.track)
          continue;
        trackInfos.push(this.toTrackInfo(bundle, sdp2));
      }
      return trackInfos;
    };
    this.toTrackInfo = (bundle, sdp2) => {
      const { transceiver, publishOption } = bundle;
      const track = transceiver.sender.track;
      const isTrackLive = track.readyState === "live";
      const layers = isTrackLive ? computeVideoLayers(track, publishOption) : this.transceiverCache.getLayers(publishOption);
      this.transceiverCache.setLayers(publishOption, layers);
      const isAudioTrack = isAudioTrackType(publishOption.trackType);
      const transceiverIndex = this.transceiverCache.indexOf(transceiver);
      const audioSettings = this.state.settings?.audio;
      const stereo = publishOption.trackType === TrackType.SCREEN_SHARE_AUDIO || isAudioTrack && !!audioSettings?.hifi_audio_enabled;
      return {
        trackId: track.id,
        layers: toVideoLayers(layers),
        trackType: publishOption.trackType,
        mid: extractMid(transceiver, transceiverIndex, sdp2),
        stereo,
        dtx: isAudioTrack && !!audioSettings?.opus_dtx_enabled,
        red: isAudioTrack && !!audioSettings?.redundant_coding_enabled,
        muted: !isTrackLive,
        codec: publishOption.codec,
        publishOptionId: publishOption.id
      };
    };
    this.cloneTrack = (track) => {
      const clone = track.clone();
      this.clonedTracks.add(clone);
      return clone;
    };
    this.stopTrack = (track) => {
      if (!track)
        return;
      track.stop();
      this.clonedTracks.delete(track);
    };
    this.publishOptions = publishOptions;
    this.on("iceRestart", (iceRestart) => {
      if (iceRestart.peerType !== PeerType.PUBLISHER_UNSPECIFIED)
        return;
      this.tryRestartIce();
    });
    this.on("changePublishQuality", async (event) => {
      for (const videoSender of event.videoSenders) {
        await this.changePublishQuality(videoSender);
      }
    });
    this.on("changePublishOptions", (event) => {
      this.publishOptions = event.publishOptions;
      return this.syncPublishOptions();
    });
  }
  /**
   * Disposes this Publisher instance.
   */
  dispose() {
    super.dispose();
    this.stopAllTracks();
    this.clonedTracks.clear();
  }
};
var Subscriber2 = class extends BasePeerConnection {
  /**
   * Constructs a new `Subscriber` instance.
   */
  constructor(opts) {
    super(PeerType.SUBSCRIBER, opts);
    this.restartIce = async () => {
      this.logger.debug("Restarting ICE connection");
      if (this.pc.signalingState === "have-remote-offer") {
        this.logger.debug("ICE restart is already in progress");
        return;
      }
      if (this.pc.connectionState === "new") {
        this.logger.debug(`ICE connection is not yet established, skipping restart.`);
        return;
      }
      const previousIsIceRestarting = this.isIceRestarting;
      this.isIceRestarting = true;
      try {
        const { response } = await this.sfuClient.iceRestart({
          peerType: PeerType.SUBSCRIBER
        });
        if (response.error)
          throw new NegotiationError(response.error);
      } catch (e2) {
        this.isIceRestarting = previousIsIceRestarting;
        throw e2;
      }
    };
    this.handleOnTrack = (e2) => {
      const [primaryStream] = e2.streams;
      const [trackId, rawTrackType] = primaryStream.id.split(":");
      const participantToUpdate = this.state.participants.find((p2) => p2.trackLookupPrefix === trackId);
      this.logger.debug(`[onTrack]: Got remote ${rawTrackType} track for userId: ${participantToUpdate?.userId}`, e2.track.id, e2.track);
      const trackDebugInfo = `${participantToUpdate?.userId} ${rawTrackType}:${trackId}`;
      e2.track.addEventListener("mute", () => {
        this.logger.info(`[onTrack]: Track muted: ${trackDebugInfo}`);
      });
      e2.track.addEventListener("unmute", () => {
        this.logger.info(`[onTrack]: Track unmuted: ${trackDebugInfo}`);
      });
      e2.track.addEventListener("ended", () => {
        this.logger.info(`[onTrack]: Track ended: ${trackDebugInfo}`);
        this.state.removeOrphanedTrack(primaryStream.id);
      });
      const trackType = toTrackType(rawTrackType);
      if (!trackType) {
        return this.logger.error(`Unknown track type: ${rawTrackType}`);
      }
      this.trackIdToTrackType.set(e2.track.id, trackType);
      if (!participantToUpdate) {
        this.logger.warn(`[onTrack]: Received track for unknown participant: ${trackId}`, e2);
        this.state.registerOrphanedTrack({
          id: primaryStream.id,
          trackLookupPrefix: trackId,
          track: primaryStream,
          trackType
        });
        return;
      }
      const streamKindProp = trackTypeToParticipantStreamKey(trackType);
      if (!streamKindProp) {
        this.logger.error(`Unknown track type: ${rawTrackType}`);
        return;
      }
      const previousStream = participantToUpdate[streamKindProp];
      this.state.updateParticipant(participantToUpdate.sessionId, {
        [streamKindProp]: primaryStream
      });
      if (previousStream) {
        this.logger.info(`[onTrack]: Cleaning up previous remote ${e2.track.kind} tracks for userId: ${participantToUpdate.userId}`);
        previousStream.getTracks().forEach((t2) => {
          t2.stop();
          previousStream.removeTrack(t2);
        });
      }
    };
    this.negotiate = async (subscriberOffer) => {
      await this.pc.setRemoteDescription({
        type: "offer",
        sdp: subscriberOffer.sdp
      });
      this.addTrickledIceCandidates();
      const answer = await this.pc.createAnswer();
      if (answer.sdp) {
        answer.sdp = enableStereo(subscriberOffer.sdp, answer.sdp);
        const { dangerouslyForceCodec, subscriberFmtpLine } = this.clientPublishOptions || {};
        if (dangerouslyForceCodec) {
          answer.sdp = removeCodecsExcept(answer.sdp, dangerouslyForceCodec, subscriberFmtpLine);
        }
      }
      await this.pc.setLocalDescription(answer);
      await this.sfuClient.sendAnswer({
        peerType: PeerType.SUBSCRIBER,
        sdp: answer.sdp || ""
      });
      this.isIceRestarting = false;
    };
    this.pc.addEventListener("track", this.handleOnTrack);
    this.on("subscriberOffer", async (subscriberOffer) => {
      return this.negotiate(subscriberOffer).catch((err) => {
        this.logger.error(`Negotiation failed.`, err);
      });
    });
  }
  /**
   * Detaches the event handlers from the `RTCPeerConnection`.
   * This is useful when we want to replace the `RTCPeerConnection`
   * instance with a new one (in case of migration).
   */
  detachEventHandlers() {
    super.detachEventHandlers();
    this.pc.removeEventListener("track", this.handleOnTrack);
  }
};
var createWebSocketSignalChannel = (opts) => {
  const { endpoint, onMessage, tag, tracer } = opts;
  const logger = videoLoggerSystem.getLogger("SfuClientWS", { tags: [tag] });
  logger.debug("Creating signaling WS channel:", endpoint);
  const ws2 = new WebSocket(endpoint);
  ws2.binaryType = "arraybuffer";
  ws2.addEventListener("error", (e2) => {
    logger.error("Signaling WS channel error", e2);
    tracer?.trace("signal.ws.error", e2);
  });
  ws2.addEventListener("close", (e2) => {
    logger.info("Signaling WS channel is closed", e2);
    tracer?.trace("signal.ws.close", e2);
  });
  ws2.addEventListener("open", (e2) => {
    logger.info("Signaling WS channel is open", e2);
    tracer?.trace("signal.ws.open", e2);
  });
  ws2.addEventListener("message", (e2) => {
    try {
      const message = e2.data instanceof ArrayBuffer ? SfuEvent.fromBinary(new Uint8Array(e2.data)) : SfuEvent.fromJsonString(e2.data.toString());
      onMessage(message);
    } catch (err) {
      const message = "Failed to decode a message. Check whether the Proto models match.";
      logger.error(message, { event: e2, error: err });
      tracer?.trace("signal.ws.message.error", message);
    }
  });
  return ws2;
};
var toRtcConfiguration = (config2) => {
  return {
    bundlePolicy: "max-bundle",
    iceServers: config2.map((ice) => ({
      urls: ice.urls,
      username: ice.username,
      credential: ice.password
    }))
  };
};
function makeSafePromise(promise) {
  let isPending = true;
  const safePromise = promise.then((result) => ({ status: "resolved", result }), (error) => ({ status: "rejected", error })).finally(() => isPending = false);
  const unwrapPromise = () => safePromise.then((fulfillment) => {
    if (fulfillment.status === "rejected")
      throw fulfillment.error;
    return fulfillment.result;
  });
  unwrapPromise.checkPending = () => isPending;
  return unwrapPromise;
}
var promiseWithResolvers = () => {
  let resolve;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  let isResolved = false;
  let isRejected = false;
  const resolver = (value) => {
    isResolved = true;
    resolve(value);
  };
  const rejecter = (reason) => {
    isRejected = true;
    reject(reason);
  };
  return {
    promise,
    resolve: resolver,
    reject: rejecter,
    isResolved: () => isResolved,
    isRejected: () => isRejected
  };
};
var uninitialized = Symbol("uninitialized");
function lazy(factory) {
  let value = uninitialized;
  return (...args) => {
    if (value === uninitialized) {
      value = factory(...args);
    }
    return value;
  };
}
var timerWorkerEnabled = false;
var enableTimerWorker = () => {
  timerWorkerEnabled = true;
};
var getTimers = lazy(() => {
  return new WorkerTimer({ useWorker: timerWorkerEnabled });
});
var StreamSfuClient = class _StreamSfuClient {
  /**
   * Constructs a new SFU client.
   */
  constructor({ dispatcher, credentials, sessionId, cid, tag, joinResponseTimeout = 5e3, onSignalClose, streamClient, enableTracing }) {
    this.iceTrickleBuffer = new IceTrickleBuffer();
    this.isLeaving = false;
    this.isClosingClean = false;
    this.pingIntervalInMs = 5 * 1e3;
    this.unhealthyTimeoutInMs = 15 * 1e3;
    this.joinResponseTask = promiseWithResolvers();
    this.abortController = new AbortController();
    this.createWebSocket = (params) => {
      const eventsToTrace = {
        callEnded: true,
        changePublishQuality: true,
        changePublishOptions: true,
        connectionQualityChanged: true,
        error: true,
        goAway: true,
        inboundStateNotification: true
      };
      this.signalWs = createWebSocketSignalChannel({
        tag: this.tag,
        endpoint: `${this.credentials.server.ws_endpoint}?${new URLSearchParams(params).toString()}`,
        tracer: this.tracer,
        onMessage: (message) => {
          this.lastMessageTimestamp = /* @__PURE__ */ new Date();
          this.scheduleConnectionCheck();
          const eventKind = message.eventPayload.oneofKind;
          if (eventsToTrace[eventKind]) {
            this.tracer?.trace(eventKind, message);
          }
          this.dispatcher.dispatch(message, this.tag);
        }
      });
      let timeoutId;
      this.signalReady = makeSafePromise(Promise.race([
        new Promise((resolve, reject) => {
          let didOpen = false;
          const onOpen = () => {
            didOpen = true;
            clearTimeout(timeoutId);
            this.signalWs.removeEventListener("open", onOpen);
            resolve(this.signalWs);
          };
          this.signalWs.addEventListener("open", onOpen);
          this.signalWs.addEventListener("close", (e2) => {
            this.handleWebSocketClose(e2);
            const message = didOpen ? `SFU WS closed: ${e2.code} ${e2.reason}` : `SFU WS connection can't be established: ${e2.code} ${e2.reason}`;
            this.tracer?.trace("signal.close", message);
            clearTimeout(timeoutId);
            reject(new Error(message));
          });
        }),
        new Promise((resolve, reject) => {
          timeoutId = setTimeout(() => {
            const message = `SFU WS connection failed to open after ${this.joinResponseTimeout}ms`;
            this.tracer?.trace("signal.timeout", message);
            reject(new Error(message));
          }, this.joinResponseTimeout);
        })
      ]));
    };
    this.handleWebSocketClose = (e2) => {
      this.signalWs.removeEventListener("close", this.handleWebSocketClose);
      getTimers().clearInterval(this.keepAliveInterval);
      clearTimeout(this.connectionCheckTimeout);
      this.onSignalClose?.(`${e2.code} ${e2.reason}`);
    };
    this.close = (code = _StreamSfuClient.NORMAL_CLOSURE, reason) => {
      this.isClosingClean = code !== _StreamSfuClient.ERROR_CONNECTION_UNHEALTHY;
      if (this.signalWs.readyState === WebSocket.OPEN) {
        this.logger.debug(`Closing SFU WS connection: ${code} - ${reason}`);
        this.signalWs.close(code, `js-client: ${reason}`);
        this.signalWs.removeEventListener("close", this.handleWebSocketClose);
      }
      this.dispose();
    };
    this.dispose = () => {
      this.logger.debug("Disposing SFU client");
      this.unsubscribeIceTrickle();
      this.unsubscribeNetworkChanged();
      clearInterval(this.keepAliveInterval);
      clearTimeout(this.connectionCheckTimeout);
      clearTimeout(this.migrateAwayTimeout);
      this.abortController.abort();
      this.migrationTask?.resolve();
      this.iceTrickleBuffer.dispose();
    };
    this.getTrace = () => {
      return this.tracer?.take();
    };
    this.leaveAndClose = async (reason) => {
      try {
        this.isLeaving = true;
        await this.joinTask;
        await this.notifyLeave(reason);
      } catch (err) {
        this.logger.debug("Error notifying SFU about leaving call", err);
      }
      this.close(_StreamSfuClient.NORMAL_CLOSURE, reason.substring(0, 115));
    };
    this.updateSubscriptions = async (tracks) => {
      await this.joinTask;
      return retryable(() => this.rpc.updateSubscriptions({ sessionId: this.sessionId, tracks }), this.abortController.signal);
    };
    this.setPublisher = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.setPublisher({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.sendAnswer = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.sendAnswer({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.iceTrickle = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.iceTrickle({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.iceRestart = async (data) => {
      await this.joinTask;
      return retryable(() => this.rpc.iceRestart({ ...data, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.updateMuteStates = async (muteStates) => {
      await this.joinTask;
      return retryable(() => this.rpc.updateMuteStates({ muteStates, sessionId: this.sessionId }), this.abortController.signal);
    };
    this.sendStats = async (stats) => {
      await this.joinTask;
      return this.rpc.sendStats({ ...stats, sessionId: this.sessionId });
    };
    this.startNoiseCancellation = async () => {
      await this.joinTask;
      return retryable(() => this.rpc.startNoiseCancellation({ sessionId: this.sessionId }), this.abortController.signal);
    };
    this.stopNoiseCancellation = async () => {
      await this.joinTask;
      return retryable(() => this.rpc.stopNoiseCancellation({ sessionId: this.sessionId }), this.abortController.signal);
    };
    this.enterMigration = async (opts = {}) => {
      this.isLeaving = true;
      const { timeout: timeout2 = 7 * 1e3 } = opts;
      this.migrationTask?.reject(new Error("Cancelled previous migration"));
      const task = this.migrationTask = promiseWithResolvers();
      const unsubscribe = this.dispatcher.on("participantMigrationComplete", () => {
        unsubscribe();
        clearTimeout(this.migrateAwayTimeout);
        task.resolve();
      });
      this.migrateAwayTimeout = setTimeout(() => {
        unsubscribe();
        task.reject(new Error(`Migration (${this.tag}) failed to complete in ${timeout2}ms`));
      }, timeout2);
      return task.promise;
    };
    this.join = async (data) => {
      await this.signalReady();
      if (this.joinResponseTask.isResolved() || this.joinResponseTask.isRejected()) {
        this.joinResponseTask = promiseWithResolvers();
      }
      const current = this.joinResponseTask;
      let timeoutId = void 0;
      const unsubscribe = this.dispatcher.on("joinResponse", (joinResponse) => {
        clearTimeout(timeoutId);
        unsubscribe();
        this.keepAlive();
        current.resolve(joinResponse);
      });
      timeoutId = setTimeout(() => {
        unsubscribe();
        const message = `Waiting for "joinResponse" has timed out after ${this.joinResponseTimeout}ms`;
        this.tracer?.trace("joinRequestTimeout", message);
        current.reject(new Error(message));
      }, this.joinResponseTimeout);
      const joinRequest = SfuRequest.create({
        requestPayload: {
          oneofKind: "joinRequest",
          joinRequest: JoinRequest.create({
            ...data,
            sessionId: this.sessionId,
            token: this.credentials.token
          })
        }
      });
      this.tracer?.trace("joinRequest", joinRequest);
      await this.send(joinRequest);
      return current.promise;
    };
    this.ping = async () => {
      return this.send(SfuRequest.create({
        requestPayload: {
          oneofKind: "healthCheckRequest",
          healthCheckRequest: {}
        }
      }));
    };
    this.notifyLeave = async (reason) => {
      return this.send(SfuRequest.create({
        requestPayload: {
          oneofKind: "leaveCallRequest",
          leaveCallRequest: {
            sessionId: this.sessionId,
            reason
          }
        }
      }));
    };
    this.send = async (message) => {
      await this.signalReady();
      const msgJson = SfuRequest.toJson(message);
      if (this.signalWs.readyState !== WebSocket.OPEN) {
        this.logger.debug("Signal WS is not open. Skipping message", msgJson);
        return;
      }
      this.logger.debug(`Sending message to: ${this.edgeName}`, msgJson);
      this.signalWs.send(SfuRequest.toBinary(message));
    };
    this.keepAlive = () => {
      const timers = getTimers();
      timers.clearInterval(this.keepAliveInterval);
      this.keepAliveInterval = timers.setInterval(() => {
        this.ping().catch((e2) => {
          this.logger.error("Error sending healthCheckRequest to SFU", e2);
        });
      }, this.pingIntervalInMs);
    };
    this.scheduleConnectionCheck = () => {
      clearTimeout(this.connectionCheckTimeout);
      this.connectionCheckTimeout = setTimeout(() => {
        if (this.lastMessageTimestamp) {
          const timeSinceLastMessage = (/* @__PURE__ */ new Date()).getTime() - this.lastMessageTimestamp.getTime();
          if (timeSinceLastMessage > this.unhealthyTimeoutInMs) {
            this.close(_StreamSfuClient.ERROR_CONNECTION_UNHEALTHY, `SFU connection unhealthy. Didn't receive any message for ${this.unhealthyTimeoutInMs}ms`);
          }
        }
      }, this.unhealthyTimeoutInMs);
    };
    this.dispatcher = dispatcher;
    this.sessionId = sessionId || generateUUIDv4();
    this.onSignalClose = onSignalClose;
    this.credentials = credentials;
    const { server, token } = credentials;
    this.edgeName = server.edge_name;
    this.joinResponseTimeout = joinResponseTimeout;
    this.tag = tag;
    this.logger = videoLoggerSystem.getLogger("SfuClient", { tags: [tag] });
    this.tracer = enableTracing ? new Tracer(`${tag}-${this.edgeName}`) : void 0;
    this.rpc = createSignalClient({
      baseUrl: server.url,
      interceptors: [
        withHeaders({ Authorization: `Bearer ${token}` }),
        this.tracer && withRequestTracer(this.tracer.trace),
        this.logger.getLogLevel() === "trace" && withRequestLogger(this.logger, "trace")
      ].filter((v2) => !!v2)
    });
    this.unsubscribeIceTrickle = dispatcher.on("iceTrickle", (iceTrickle) => {
      this.iceTrickleBuffer.push(iceTrickle);
    });
    this.unsubscribeNetworkChanged = streamClient.on("network.changed", (e2) => {
      if (!e2.online) {
        this.networkAvailableTask = promiseWithResolvers();
      } else {
        this.networkAvailableTask?.resolve();
      }
    });
    this.createWebSocket({
      attempt: tag,
      user_id: streamClient.user?.id || "",
      api_key: streamClient.key,
      user_session_id: this.sessionId,
      cid
    });
  }
  get isHealthy() {
    return this.signalWs.readyState === WebSocket.OPEN && this.joinResponseTask.isResolved();
  }
  get joinTask() {
    return this.joinResponseTask.promise;
  }
};
StreamSfuClient.NORMAL_CLOSURE = 1e3;
StreamSfuClient.ERROR_CONNECTION_UNHEALTHY = 4001;
StreamSfuClient.DISPOSE_OLD_SOCKET = 4100;
StreamSfuClient.JOIN_FAILED = 4101;
var watchCallAccepted = (call) => {
  return async function onCallAccepted(event) {
    if (event.user.id === call.currentUserId)
      return;
    const { state } = call;
    if (event.call.created_by.id === call.currentUserId && state.callingState === CallingState.RINGING) {
      await call.join();
    }
  };
};
var watchCallRejected = (call) => {
  return async function onCallRejected(event) {
    if (event.user.id === call.currentUserId)
      return;
    const { call: eventCall } = event;
    const { session: callSession } = eventCall;
    if (!callSession) {
      call.logger.warn("No call session provided. Ignoring call.rejected event.", event);
      return;
    }
    const rejectedBy = callSession.rejected_by;
    const { members, callingState } = call.state;
    if (callingState !== CallingState.RINGING) {
      call.logger.info("Call is not in ringing mode (it is either accepted or rejected already). Ignoring call.rejected event.", event);
      return;
    }
    if (call.isCreatedByMe) {
      const everyoneElseRejected = members.filter((m2) => m2.user_id !== call.currentUserId).every((m2) => rejectedBy[m2.user_id]);
      if (everyoneElseRejected) {
        call.logger.info("everyone rejected, leaving the call");
        await call.leave({
          reject: true,
          reason: "cancel",
          message: "ring: everyone rejected"
        });
      }
    } else {
      if (rejectedBy[eventCall.created_by.id]) {
        call.logger.info("call creator rejected, leaving call");
        await call.leave({ message: "ring: creator rejected" });
      }
    }
  };
};
var watchCallEnded = (call) => {
  return function onCallEnded() {
    const { callingState } = call.state;
    if (callingState !== CallingState.IDLE && callingState !== CallingState.LEFT) {
      call.leave({ message: "call.ended event received", reject: false }).catch((err) => {
        call.logger.error("Failed to leave call after call.ended ", err);
      });
    }
  };
};
var watchSfuCallEnded = (call) => {
  return call.on("callEnded", async (e2) => {
    if (call.state.callingState === CallingState.LEFT)
      return;
    try {
      if (e2.reason === CallEndedReason.LIVE_ENDED) {
        call.state.setBackstage(true);
        const { hasPermission } = call.permissionsContext;
        if (hasPermission(OwnCapability.JOIN_BACKSTAGE))
          return;
      }
      call.state.setEndedAt(/* @__PURE__ */ new Date());
      const reason = CallEndedReason[e2.reason];
      await call.leave({ message: `callEnded received: ${reason}` });
    } catch (err) {
      call.logger.error("Failed to leave call after being ended by the SFU", err);
    }
  });
};
var watchCallGrantsUpdated = (state) => {
  return function onCallGrantsUpdated(event) {
    const { currentGrants } = event;
    if (!currentGrants)
      return;
    state.setCallGrants(currentGrants);
  };
};
var pushToIfMissing = (arr, ...values) => {
  for (const v2 of values) {
    if (!arr.includes(v2)) {
      arr.push(v2);
    }
  }
  return arr;
};
var removeFromIfPresent = (arr, ...values) => {
  for (const v2 of values) {
    const index = arr.indexOf(v2);
    if (index !== -1) {
      arr.splice(index, 1);
    }
  }
  return arr;
};
var watchConnectionQualityChanged = (dispatcher, state) => {
  return dispatcher.on("connectionQualityChanged", (e2) => {
    const { connectionQualityUpdates } = e2;
    if (!connectionQualityUpdates)
      return;
    state.updateParticipants(connectionQualityUpdates.reduce((patches, update) => {
      const { sessionId, connectionQuality } = update;
      patches[sessionId] = {
        connectionQuality
      };
      return patches;
    }, {}));
  });
};
var watchParticipantCountChanged = (dispatcher, state) => {
  return dispatcher.on("healthCheckResponse", (e2) => {
    const { participantCount } = e2;
    if (participantCount) {
      state.setParticipantCount(participantCount.total);
      state.setAnonymousParticipantCount(participantCount.anonymous);
    }
  });
};
var watchLiveEnded = (dispatcher, call) => {
  return dispatcher.on("error", (e2) => {
    if (e2.error && e2.error.code !== ErrorCode.LIVE_ENDED)
      return;
    call.state.setBackstage(true);
    if (!call.permissionsContext.hasPermission(OwnCapability.JOIN_BACKSTAGE)) {
      call.leave({ message: "live ended" }).catch((err) => {
        call.logger.error("Failed to leave call after live ended", err);
      });
    }
  });
};
var watchSfuErrorReports = (dispatcher) => {
  return dispatcher.on("error", (e2) => {
    if (!e2.error)
      return;
    const logger = videoLoggerSystem.getLogger("SfuClient");
    const { error, reconnectStrategy } = e2;
    logger.error("SFU reported error", {
      code: ErrorCode[error.code],
      reconnectStrategy: WebsocketReconnectStrategy[reconnectStrategy],
      message: error.message,
      shouldRetry: error.shouldRetry
    });
  });
};
var watchPinsUpdated = (state) => {
  return function onPinsUpdated(e2) {
    const { pins } = e2;
    state.setServerSidePins(pins);
  };
};
var watchInboundStateNotification = (state) => {
  return function onInboundStateNotification(e2) {
    const { inboundVideoStates } = e2;
    const current = state.getParticipantLookupBySessionId();
    const patches = {};
    for (const { sessionId, trackType, paused } of inboundVideoStates) {
      const pausedTracks = [...current[sessionId]?.pausedTracks ?? []];
      if (paused) {
        pushToIfMissing(pausedTracks, trackType);
      } else {
        removeFromIfPresent(pausedTracks, trackType);
      }
      patches[sessionId] = { pausedTracks };
    }
    state.updateParticipants(patches);
  };
};
var handleRemoteSoftMute = (call) => {
  return call.on("trackUnpublished", async (event) => {
    const { cause, type, sessionId } = event;
    const { localParticipant } = call.state;
    if (cause === TrackUnpublishReason.MODERATION && sessionId === localParticipant?.sessionId) {
      const logger = call.logger;
      logger.info(`Local participant's ${TrackType[type]} track is muted remotely`);
      try {
        if (type === TrackType.VIDEO) {
          await call.camera.disable();
        } else if (type === TrackType.AUDIO) {
          await call.microphone.disable();
        } else if (type === TrackType.SCREEN_SHARE || type === TrackType.SCREEN_SHARE_AUDIO) {
          await call.screenShare.disable();
        } else {
          logger.warn("Unsupported track type to soft mute", TrackType[type]);
        }
      } catch (error) {
        logger.error("Failed to stop publishing", error);
      }
    }
  });
};
var watchParticipantJoined = (state) => {
  return function onParticipantJoined(e2) {
    const { participant } = e2;
    if (!participant)
      return;
    const orphanedTracks = reconcileOrphanedTracks(state, participant);
    state.updateOrAddParticipant(participant.sessionId, Object.assign(participant, orphanedTracks, {
      viewportVisibilityState: {
        videoTrack: VisibilityState.UNKNOWN,
        screenShareTrack: VisibilityState.UNKNOWN
      }
    }));
  };
};
var watchParticipantLeft = (state) => {
  return function onParticipantLeft(e2) {
    const { participant } = e2;
    if (!participant)
      return;
    state.setParticipants((participants) => participants.filter((p2) => p2.sessionId !== participant.sessionId));
  };
};
var watchParticipantUpdated = (state) => {
  return function onParticipantUpdated(e2) {
    const { participant } = e2;
    if (!participant)
      return;
    state.updateParticipant(participant.sessionId, participant);
  };
};
var watchTrackPublished = (state) => {
  return function onTrackPublished(e2) {
    const { type, sessionId } = e2;
    if (e2.participant) {
      const orphanedTracks = reconcileOrphanedTracks(state, e2.participant);
      const participant = Object.assign(e2.participant, orphanedTracks);
      state.updateOrAddParticipant(sessionId, participant);
    } else {
      state.updateParticipant(sessionId, (p2) => ({
        publishedTracks: pushToIfMissing([...p2.publishedTracks], type)
      }));
    }
  };
};
var watchTrackUnpublished = (state) => {
  return function onTrackUnpublished(e2) {
    const { type, sessionId } = e2;
    if (e2.participant) {
      const orphanedTracks = reconcileOrphanedTracks(state, e2.participant);
      const participant = Object.assign(e2.participant, orphanedTracks);
      state.updateOrAddParticipant(sessionId, participant, (p2) => ({
        pausedTracks: p2.pausedTracks?.filter((t2) => t2 !== type)
      }));
    } else {
      state.updateParticipant(sessionId, (p2) => ({
        publishedTracks: p2.publishedTracks.filter((t2) => t2 !== type),
        pausedTracks: p2.pausedTracks?.filter((t2) => t2 !== type)
      }));
    }
  };
};
var reconcileOrphanedTracks = (state, participant) => {
  const orphanTracks = state.takeOrphanedTracks(participant.trackLookupPrefix);
  if (!orphanTracks.length)
    return;
  const reconciledTracks = {};
  for (const orphan of orphanTracks) {
    const key = trackTypeToParticipantStreamKey(orphan.trackType);
    if (!key)
      continue;
    reconciledTracks[key] = orphan.track;
  }
  return reconciledTracks;
};
var watchDominantSpeakerChanged = (dispatcher, state) => {
  return dispatcher.on("dominantSpeakerChanged", (e2) => {
    const { sessionId } = e2;
    if (sessionId === state.dominantSpeaker?.sessionId)
      return;
    state.setParticipants((participants) => participants.map((participant) => {
      if (participant.sessionId === sessionId) {
        return {
          ...participant,
          isDominantSpeaker: true
        };
      }
      if (participant.isDominantSpeaker) {
        return {
          ...participant,
          isDominantSpeaker: false
        };
      }
      return participant;
    }));
  });
};
var watchAudioLevelChanged = (dispatcher, state) => {
  return dispatcher.on("audioLevelChanged", (e2) => {
    const { audioLevels } = e2;
    state.updateParticipants(audioLevels.reduce((patches, current) => {
      patches[current.sessionId] = {
        audioLevel: current.level,
        isSpeaking: current.isSpeaking
      };
      return patches;
    }, {}));
  });
};
var registerEventHandlers = (call, dispatcher) => {
  const state = call.state;
  const eventHandlers = [
    call.on("call.ended", watchCallEnded(call)),
    watchSfuCallEnded(call),
    watchLiveEnded(dispatcher, call),
    watchSfuErrorReports(dispatcher),
    watchConnectionQualityChanged(dispatcher, state),
    watchParticipantCountChanged(dispatcher, state),
    call.on("participantJoined", watchParticipantJoined(state)),
    call.on("participantLeft", watchParticipantLeft(state)),
    call.on("participantUpdated", watchParticipantUpdated(state)),
    call.on("trackPublished", watchTrackPublished(state)),
    call.on("trackUnpublished", watchTrackUnpublished(state)),
    watchAudioLevelChanged(dispatcher, state),
    watchDominantSpeakerChanged(dispatcher, state),
    call.on("callGrantsUpdated", watchCallGrantsUpdated(state)),
    call.on("pinsUpdated", watchPinsUpdated(state)),
    call.on("inboundStateNotification", watchInboundStateNotification(state)),
    handleRemoteSoftMute(call)
  ];
  return () => {
    eventHandlers.forEach((unsubscribe) => unsubscribe());
  };
};
var registerRingingCallEventHandlers = (call) => {
  const coordinatorRingEvents = {
    "call.accepted": watchCallAccepted(call),
    "call.rejected": watchCallRejected(call)
  };
  const eventHandlers = Object.keys(coordinatorRingEvents).map((event) => {
    const eventName = event;
    return call.on(eventName, coordinatorRingEvents[eventName]);
  });
  return () => {
    eventHandlers.forEach((unsubscribe) => unsubscribe());
  };
};
var DEFAULT_THRESHOLD = 0.35;
var ViewportTracker = class {
  constructor() {
    this.elementHandlerMap = /* @__PURE__ */ new Map();
    this.observer = null;
    this.queueSet = /* @__PURE__ */ new Set();
    this.setViewport = (viewportElement, options) => {
      const cleanup = () => {
        this.observer?.disconnect();
        this.observer = null;
        this.elementHandlerMap.clear();
      };
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          const handler = this.elementHandlerMap.get(entry.target);
          handler?.(entry);
        });
      }, {
        root: viewportElement,
        ...options,
        threshold: options?.threshold ?? DEFAULT_THRESHOLD
      });
      if (this.queueSet.size) {
        this.queueSet.forEach(([queueElement, queueHandler]) => {
          if (!viewportElement.contains(queueElement))
            return;
          this.observer.observe(queueElement);
          this.elementHandlerMap.set(queueElement, queueHandler);
        });
        this.queueSet.clear();
      }
      return cleanup;
    };
    this.observe = (element, handler) => {
      const queueItem = [element, handler];
      const cleanup = () => {
        this.elementHandlerMap.delete(element);
        this.observer?.unobserve(element);
        this.queueSet.delete(queueItem);
      };
      if (this.elementHandlerMap.has(element))
        return cleanup;
      if (!this.observer) {
        this.queueSet.add(queueItem);
        return cleanup;
      }
      if (this.observer.root.contains(element)) {
        this.elementHandlerMap.set(element, handler);
        this.observer.observe(element);
      }
      return cleanup;
    };
  }
};
var DEFAULT_VIEWPORT_VISIBILITY_STATE = {
  videoTrack: VisibilityState.UNKNOWN,
  screenShareTrack: VisibilityState.UNKNOWN
};
var globalOverrideKey = Symbol("globalOverrideKey");
var DynascaleManager = class {
  /**
   * Creates a new DynascaleManager instance.
   */
  constructor(callState, speaker) {
    this.viewportTracker = new ViewportTracker();
    this.logger = videoLoggerSystem.getLogger("DynascaleManager");
    this.pendingSubscriptionsUpdate = null;
    this.videoTrackSubscriptionOverridesSubject = new BehaviorSubject({});
    this.videoTrackSubscriptionOverrides$ = this.videoTrackSubscriptionOverridesSubject.asObservable();
    this.incomingVideoSettings$ = this.videoTrackSubscriptionOverrides$.pipe(map((overrides) => {
      const { [globalOverrideKey]: globalSettings, ...participants } = overrides;
      return {
        enabled: globalSettings?.enabled !== false,
        preferredResolution: globalSettings?.enabled ? globalSettings.dimension : void 0,
        participants: Object.fromEntries(Object.entries(participants).map(([sessionId, participantOverride]) => [
          sessionId,
          {
            enabled: participantOverride?.enabled !== false,
            preferredResolution: participantOverride?.enabled ? participantOverride.dimension : void 0
          }
        ])),
        isParticipantVideoEnabled: (sessionId) => overrides[sessionId]?.enabled ?? overrides[globalOverrideKey]?.enabled ?? true
      };
    }), shareReplay(1));
    this.dispose = async () => {
      if (this.pendingSubscriptionsUpdate) {
        clearTimeout(this.pendingSubscriptionsUpdate);
      }
      const context2 = this.getOrCreateAudioContext();
      if (context2 && context2.state !== "closed") {
        document.removeEventListener("click", this.resumeAudioContext);
        await context2.close();
        this.audioContext = void 0;
      }
    };
    this.setVideoTrackSubscriptionOverrides = (override, sessionIds) => {
      if (!sessionIds) {
        return setCurrentValue(this.videoTrackSubscriptionOverridesSubject, override ? { [globalOverrideKey]: override } : {});
      }
      return setCurrentValue(this.videoTrackSubscriptionOverridesSubject, (overrides) => ({
        ...overrides,
        ...Object.fromEntries(sessionIds.map((id) => [id, override]))
      }));
    };
    this.applyTrackSubscriptions = (debounceType = DebounceType.SLOW) => {
      if (this.pendingSubscriptionsUpdate) {
        clearTimeout(this.pendingSubscriptionsUpdate);
      }
      const updateSubscriptions = () => {
        this.pendingSubscriptionsUpdate = null;
        this.sfuClient?.updateSubscriptions(this.trackSubscriptions).catch((err) => {
          this.logger.debug(`Failed to update track subscriptions`, err);
        });
      };
      if (debounceType) {
        this.pendingSubscriptionsUpdate = setTimeout(updateSubscriptions, debounceType);
      } else {
        updateSubscriptions();
      }
    };
    this.trackElementVisibility = (element, sessionId, trackType) => {
      const cleanup = this.viewportTracker.observe(element, (entry) => {
        this.callState.updateParticipant(sessionId, (participant) => {
          const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;
          const isVisible = entry.isIntersecting || document.fullscreenElement === element ? VisibilityState.VISIBLE : VisibilityState.INVISIBLE;
          return {
            ...participant,
            viewportVisibilityState: {
              ...previousVisibilityState,
              [trackType]: isVisible
            }
          };
        });
      });
      return () => {
        cleanup();
        this.callState.updateParticipant(sessionId, (participant) => {
          const previousVisibilityState = participant.viewportVisibilityState ?? DEFAULT_VIEWPORT_VISIBILITY_STATE;
          return {
            ...participant,
            viewportVisibilityState: {
              ...previousVisibilityState,
              [trackType]: VisibilityState.UNKNOWN
            }
          };
        });
      };
    };
    this.setViewport = (element) => {
      return this.viewportTracker.setViewport(element);
    };
    this.bindVideoElement = (videoElement, sessionId, trackType) => {
      const boundParticipant = this.callState.findParticipantBySessionId(sessionId);
      if (!boundParticipant)
        return;
      const requestTrackWithDimensions = (debounceType, dimension) => {
        if (dimension && (dimension.width === 0 || dimension.height === 0)) {
          this.logger.debug(`Ignoring 0x0 dimension`, boundParticipant);
          dimension = void 0;
        }
        this.callState.updateParticipantTracks(trackType, {
          [sessionId]: { dimension }
        });
        this.applyTrackSubscriptions(debounceType);
      };
      const participant$ = this.callState.participants$.pipe(map((ps2) => ps2.find((p2) => p2.sessionId === sessionId)), takeWhile((participant) => !!participant), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));
      let viewportVisibilityState;
      const viewportVisibilityStateSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe(map((p2) => p2.viewportVisibilityState?.[trackType]), distinctUntilChanged()).subscribe((nextViewportVisibilityState) => {
        if (!viewportVisibilityState) {
          viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;
          return;
        }
        viewportVisibilityState = nextViewportVisibilityState ?? VisibilityState.UNKNOWN;
        if (nextViewportVisibilityState === VisibilityState.INVISIBLE) {
          return requestTrackWithDimensions(DebounceType.MEDIUM, void 0);
        }
        requestTrackWithDimensions(DebounceType.MEDIUM, {
          width: videoElement.clientWidth,
          height: videoElement.clientHeight
        });
      });
      let lastDimensions;
      const resizeObserver = boundParticipant.isLocalParticipant ? null : new ResizeObserver(() => {
        const currentDimensions = {
          width: videoElement.clientWidth,
          height: videoElement.clientHeight
        };
        if (!lastDimensions) {
          lastDimensions = currentDimensions;
          return;
        }
        if (lastDimensions.width === currentDimensions.width && lastDimensions.height === currentDimensions.height || viewportVisibilityState === VisibilityState.INVISIBLE) {
          return;
        }
        const relativeDelta = Math.max(currentDimensions.width / lastDimensions.width, currentDimensions.height / lastDimensions.height);
        const debounceType = relativeDelta > 1.2 ? DebounceType.IMMEDIATE : DebounceType.MEDIUM;
        requestTrackWithDimensions(debounceType, {
          width: videoElement.clientWidth,
          height: videoElement.clientHeight
        });
        lastDimensions = currentDimensions;
      });
      resizeObserver?.observe(videoElement);
      const publishedTracksSubscription = boundParticipant.isLocalParticipant ? null : participant$.pipe(distinctUntilKeyChanged("publishedTracks"), map((p2) => trackType === "videoTrack" ? hasVideo(p2) : hasScreenShare(p2)), distinctUntilChanged()).subscribe((isPublishing) => {
        if (isPublishing) {
          requestTrackWithDimensions(DebounceType.IMMEDIATE, {
            width: videoElement.clientWidth,
            height: videoElement.clientHeight
          });
        } else {
          requestTrackWithDimensions(DebounceType.FAST, void 0);
        }
      });
      videoElement.autoplay = true;
      videoElement.playsInline = true;
      videoElement.muted = true;
      const streamSubscription = participant$.pipe(distinctUntilKeyChanged(trackType === "videoTrack" ? "videoStream" : "screenShareStream")).subscribe((p2) => {
        const source = trackType === "videoTrack" ? p2.videoStream : p2.screenShareStream;
        if (videoElement.srcObject === source)
          return;
        videoElement.srcObject = source ?? null;
        if (isSafari() || isFirefox()) {
          setTimeout(() => {
            videoElement.srcObject = source ?? null;
            videoElement.play().catch((e2) => {
              this.logger.warn(`Failed to play stream`, e2);
            });
          }, 25);
        }
      });
      return () => {
        requestTrackWithDimensions(DebounceType.FAST, void 0);
        viewportVisibilityStateSubscription?.unsubscribe();
        publishedTracksSubscription?.unsubscribe();
        streamSubscription.unsubscribe();
        resizeObserver?.disconnect();
      };
    };
    this.bindAudioElement = (audioElement, sessionId, trackType) => {
      const participant = this.callState.findParticipantBySessionId(sessionId);
      if (!participant || participant.isLocalParticipant)
        return;
      const participant$ = this.callState.participants$.pipe(map((ps2) => ps2.find((p2) => p2.sessionId === sessionId)), takeWhile((p2) => !!p2), distinctUntilChanged(), shareReplay({ bufferSize: 1, refCount: true }));
      const updateSinkId = (deviceId, audioContext) => {
        if (!deviceId)
          return;
        if ("setSinkId" in audioElement) {
          audioElement.setSinkId(deviceId).catch((e2) => {
            this.logger.warn(`Can't to set AudioElement sinkId`, e2);
          });
        }
        if (audioContext && "setSinkId" in audioContext) {
          audioContext.setSinkId(deviceId).catch((e2) => {
            this.logger.warn(`Can't to set AudioContext sinkId`, e2);
          });
        }
      };
      let sourceNode = void 0;
      let gainNode = void 0;
      const updateMediaStreamSubscription = participant$.pipe(distinctUntilKeyChanged(trackType === "screenShareAudioTrack" ? "screenShareAudioStream" : "audioStream")).subscribe((p2) => {
        const source = trackType === "screenShareAudioTrack" ? p2.screenShareAudioStream : p2.audioStream;
        if (audioElement.srcObject === source)
          return;
        setTimeout(() => {
          audioElement.srcObject = source ?? null;
          if (!source)
            return;
          const audioContext = this.getOrCreateAudioContext();
          if (audioContext) {
            audioElement.muted = true;
            sourceNode?.disconnect();
            sourceNode = audioContext.createMediaStreamSource(source);
            gainNode ?? (gainNode = audioContext.createGain());
            gainNode.gain.value = p2.audioVolume ?? this.speaker.state.volume;
            sourceNode.connect(gainNode).connect(audioContext.destination);
            this.resumeAudioContext();
          } else {
            audioElement.muted = false;
            audioElement.play().catch((e2) => {
              this.logger.warn(`Failed to play audio stream`, e2);
            });
          }
          const { selectedDevice } = this.speaker.state;
          if (selectedDevice)
            updateSinkId(selectedDevice, audioContext);
        });
      });
      const sinkIdSubscription = !("setSinkId" in audioElement) ? null : this.speaker.state.selectedDevice$.subscribe((deviceId) => {
        const audioContext = this.getOrCreateAudioContext();
        updateSinkId(deviceId, audioContext);
      });
      const volumeSubscription = combineLatest([
        this.speaker.state.volume$,
        participant$.pipe(distinctUntilKeyChanged("audioVolume"))
      ]).subscribe(([volume, p2]) => {
        const participantVolume = p2.audioVolume ?? volume;
        audioElement.volume = participantVolume;
        if (gainNode)
          gainNode.gain.value = participantVolume;
      });
      audioElement.autoplay = true;
      return () => {
        sinkIdSubscription?.unsubscribe();
        volumeSubscription.unsubscribe();
        updateMediaStreamSubscription.unsubscribe();
        audioElement.srcObject = null;
        sourceNode?.disconnect();
        gainNode?.disconnect();
      };
    };
    this.getOrCreateAudioContext = () => {
      if (this.audioContext || !isSafari())
        return this.audioContext;
      const context2 = new AudioContext();
      if (context2.state === "suspended") {
        document.addEventListener("click", this.resumeAudioContext);
      }
      const audioSession = navigator.audioSession;
      if (audioSession) {
        audioSession.type = "play-and-record";
      }
      return this.audioContext = context2;
    };
    this.resumeAudioContext = () => {
      if (this.audioContext?.state === "suspended") {
        this.audioContext.resume().catch((err) => this.logger.warn(`Can't resume audio context`, err)).then(() => {
          document.removeEventListener("click", this.resumeAudioContext);
        });
      }
    };
    this.callState = callState;
    this.speaker = speaker;
  }
  setSfuClient(sfuClient) {
    this.sfuClient = sfuClient;
  }
  get trackSubscriptions() {
    const subscriptions = [];
    const participants = this.callState.getParticipantsSnapshot();
    const videoTrackSubscriptionOverrides = this.videoTrackSubscriptionOverridesSubject.getValue();
    for (const p2 of participants) {
      if (p2.isLocalParticipant)
        continue;
      if (p2.videoDimension && hasVideo(p2)) {
        const override = videoTrackSubscriptionOverrides[p2.sessionId] ?? videoTrackSubscriptionOverrides[globalOverrideKey];
        if (override?.enabled !== false) {
          subscriptions.push({
            userId: p2.userId,
            sessionId: p2.sessionId,
            trackType: TrackType.VIDEO,
            dimension: override?.dimension ?? p2.videoDimension
          });
        }
      }
      if (p2.screenShareDimension && hasScreenShare(p2)) {
        subscriptions.push({
          userId: p2.userId,
          sessionId: p2.sessionId,
          trackType: TrackType.SCREEN_SHARE,
          dimension: p2.screenShareDimension
        });
      }
      if (hasScreenShareAudio(p2)) {
        subscriptions.push({
          userId: p2.userId,
          sessionId: p2.sessionId,
          trackType: TrackType.SCREEN_SHARE_AUDIO
        });
      }
    }
    return subscriptions;
  }
  get videoTrackSubscriptionOverrides() {
    return getCurrentValue(this.videoTrackSubscriptionOverrides$);
  }
};
var PermissionsContext = class {
  constructor() {
    this.permissions = [];
    this.setPermissions = (permissions) => {
      this.permissions = permissions || [];
    };
    this.setCallSettings = (settings) => {
      this.settings = settings;
    };
    this.hasPermission = (permission) => {
      return this.permissions.includes(permission);
    };
    this.canPublish = (trackType) => {
      switch (trackType) {
        case TrackType.AUDIO:
          return this.hasPermission(OwnCapability.SEND_AUDIO);
        case TrackType.VIDEO:
          return this.hasPermission(OwnCapability.SEND_VIDEO);
        case TrackType.SCREEN_SHARE:
        case TrackType.SCREEN_SHARE_AUDIO:
          return this.hasPermission(OwnCapability.SCREENSHARE);
        case TrackType.UNSPECIFIED:
          return false;
        default:
          ensureExhausted(trackType, "Unknown track type");
      }
    };
    this.canRequest = (permission, settings = this.settings) => {
      if (!settings)
        return false;
      const { audio, video, screensharing } = settings;
      switch (permission) {
        case OwnCapability.SEND_AUDIO:
          return audio.access_request_enabled;
        case OwnCapability.SEND_VIDEO:
          return video.access_request_enabled;
        case OwnCapability.SCREENSHARE:
          return screensharing.access_request_enabled;
        default:
          return false;
      }
    };
  }
};
var CallType = class {
  /**
   * Constructs a new CallType.
   *
   * @param name the name of the call type.
   * @param options the options for the call type.
   */
  constructor(name2, options = {
    sortParticipantsBy: defaultSortPreset
  }) {
    this.name = name2;
    this.options = options;
  }
};
var CallTypesRegistry = class {
  /**
   * Constructs a new CallTypesRegistry.
   *
   * @param callTypes the initial call types to register.
   */
  constructor(callTypes) {
    this.register = (callType) => {
      this.callTypes[callType.name] = callType;
    };
    this.unregister = (name2) => {
      delete this.callTypes[name2];
    };
    this.get = (name2) => {
      if (!this.callTypes[name2]) {
        this.register(new CallType(name2));
      }
      return this.callTypes[name2];
    };
    this.callTypes = callTypes.reduce((acc, callType) => {
      acc[callType.name] = callType;
      return acc;
    }, {});
  }
};
var CallTypes = new CallTypesRegistry([
  new CallType("default", {
    sortParticipantsBy: defaultSortPreset
  }),
  new CallType("development", {
    sortParticipantsBy: defaultSortPreset
  }),
  new CallType("livestream", {
    sortParticipantsBy: livestreamOrAudioRoomSortPreset
  }),
  new CallType("audio_room", {
    sortParticipantsBy: livestreamOrAudioRoomSortPreset
  })
]);
var disposeOfMediaStream = (stream) => {
  if (!stream.active)
    return;
  stream.getTracks().forEach((track) => {
    track.stop();
  });
  if (typeof stream.release === "function") {
    stream.release();
  }
};
var BrowserPermission = class {
  constructor(permission) {
    this.permission = permission;
    this.disposeController = new AbortController();
    this.wasPrompted = false;
    this.listeners = /* @__PURE__ */ new Set();
    this.logger = videoLoggerSystem.getLogger("permissions");
    const signal = this.disposeController.signal;
    this.ready = (async () => {
      const assumeGranted = () => {
        if (isReactNative2()) {
          this.setState("granted");
        } else {
          this.setState("prompt");
        }
      };
      if (!canQueryPermissions()) {
        return assumeGranted();
      }
      try {
        const status = await navigator.permissions.query({
          name: permission.queryName
        });
        if (!signal.aborted) {
          this.setState(status.state);
          status.addEventListener("change", () => this.setState(status.state), {
            signal
          });
        }
      } catch (err) {
        this.logger.debug("Failed to query permission status", err);
        assumeGranted();
      }
    })();
  }
  dispose() {
    this.state = void 0;
    this.disposeController.abort();
  }
  async getState() {
    await this.ready;
    if (!this.state) {
      throw new Error("BrowserPermission instance possibly disposed");
    }
    return this.state;
  }
  async prompt({ forcePrompt = false, throwOnNotAllowed = false } = {}) {
    return await withoutConcurrency(`permission-prompt-${this.permission.queryName}`, async () => {
      if (await this.getState() !== "prompt" || this.wasPrompted && !forcePrompt) {
        const isGranted = this.state === "granted";
        if (!isGranted && throwOnNotAllowed) {
          throw new Error("Permission was not granted previously, and prompting again is not allowed");
        }
        return isGranted;
      }
      try {
        this.wasPrompted = true;
        this.setState("prompting");
        const stream = await navigator.mediaDevices.getUserMedia(this.permission.constraints);
        disposeOfMediaStream(stream);
        this.setState("granted");
        return true;
      } catch (e2) {
        if (e2 && typeof e2 === "object" && "name" in e2 && (e2.name === "NotAllowedError" || e2.name === "SecurityError")) {
          this.logger.info("Browser permission was not granted", {
            permission: this.permission
          });
          this.setState("denied");
          if (throwOnNotAllowed) {
            throw e2;
          }
          return false;
        }
        this.logger.error(`Failed to getUserMedia`, {
          error: e2,
          permission: this.permission
        });
        this.setState("prompt");
        throw e2;
      }
    });
  }
  listen(cb) {
    this.listeners.add(cb);
    if (this.state)
      cb(this.state);
    return () => this.listeners.delete(cb);
  }
  asObservable() {
    return this.getStateObservable().pipe(
      // In some browsers, the 'change' event doesn't reliably emit and hence,
      // permissionState stays in 'prompt' state forever.
      // Typically, this happens when a user grants one-time permission.
      // Instead of checking if a permission is granted, we check if it isn't denied
      map((state) => state !== "denied")
    );
  }
  asStateObservable() {
    return this.getStateObservable();
  }
  getIsPromptingObservable() {
    return this.getStateObservable().pipe(map((state) => state === "prompting"));
  }
  getStateObservable() {
    return fromEventPattern((handler) => this.listen(handler), (handler, unlisten) => unlisten());
  }
  setState(state) {
    if (this.state !== state) {
      this.state = state;
      this.listeners.forEach((listener) => listener(state));
    }
  }
};
function canQueryPermissions() {
  return !isReactNative2() && typeof navigator !== "undefined" && !!navigator.permissions?.query;
}
var getDevices = (permission, kind, tracer) => {
  return from((async () => {
    let devices = await navigator.mediaDevices.enumerateDevices();
    const shouldPromptForBrowserPermission = devices.some((device) => device.kind === kind && device.label === "");
    if (shouldPromptForBrowserPermission && await permission.prompt()) {
      devices = await navigator.mediaDevices.enumerateDevices();
    }
    tracer?.traceOnce("device-enumeration", "navigator.mediaDevices.enumerateDevices", devices);
    return devices.filter((device) => device.kind === kind && device.label !== "" && device.deviceId !== "default");
  })());
};
var checkIfAudioOutputChangeSupported = () => {
  if (typeof document === "undefined")
    return false;
  const element = document.createElement("audio");
  return "setSinkId" in element;
};
var audioDeviceConstraints = {
  audio: {
    autoGainControl: true,
    noiseSuppression: true,
    echoCancellation: true
  }
};
var videoDeviceConstraints = {
  video: {
    width: 1280,
    height: 720
  }
};
var getAudioBrowserPermission = lazy(() => new BrowserPermission({
  constraints: audioDeviceConstraints,
  queryName: "microphone"
}));
var getVideoBrowserPermission = lazy(() => new BrowserPermission({
  constraints: videoDeviceConstraints,
  queryName: "camera"
}));
var getDeviceChangeObserver = lazy((tracer) => {
  if (!navigator.mediaDevices.addEventListener)
    return from([]);
  return fromEvent(navigator.mediaDevices, "devicechange").pipe(tap(() => tracer?.resetTrace("device-enumeration")), map(() => void 0), debounceTime(500));
});
var getAudioDevices = lazy((tracer) => {
  return merge(getDeviceChangeObserver(tracer), getAudioBrowserPermission().asObservable()).pipe(startWith(void 0), concatMap(() => getDevices(getAudioBrowserPermission(), "audioinput", tracer)), shareReplay(1));
});
var getVideoDevices = lazy((tracer) => {
  return merge(getDeviceChangeObserver(tracer), getVideoBrowserPermission().asObservable()).pipe(startWith(void 0), concatMap(() => getDevices(getVideoBrowserPermission(), "videoinput", tracer)), shareReplay(1));
});
var getAudioOutputDevices = lazy((tracer) => {
  return merge(getDeviceChangeObserver(tracer), getAudioBrowserPermission().asObservable()).pipe(startWith(void 0), concatMap(() => getDevices(getAudioBrowserPermission(), "audiooutput", tracer)), shareReplay(1));
});
var getUserMediaExecId = 0;
var getStream = async (constraints, tracer) => {
  const tag = `navigator.mediaDevices.getUserMedia.${getUserMediaExecId++}.`;
  try {
    tracer?.trace(tag, constraints);
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    tracer?.trace(`${tag}OnSuccess`, dumpStream(stream));
    if (isFirefox()) {
      navigator.mediaDevices.dispatchEvent(new Event("devicechange"));
    }
    if (constraints.video) {
      const [videoTrack] = stream.getVideoTracks();
      if (videoTrack) {
        const { width, height } = videoTrack.getSettings();
        const target = constraints.video;
        if (width !== target.width || height !== target.height) {
          tracer?.trace(`${tag}Warn`, `Requested resolution ${target.width}x${target.height} but got ${width}x${height}`);
        }
      }
    }
    return stream;
  } catch (error) {
    tracer?.trace(`${tag}OnFailure`, error.name);
    throw error;
  }
};
function isNotFoundOrOverconstrainedError(error) {
  if (!error || typeof error !== "object") {
    return false;
  }
  if ("name" in error && typeof error.name === "string") {
    const name2 = error.name;
    if (["OverconstrainedError", "NotFoundError"].includes(name2)) {
      return true;
    }
  }
  if ("message" in error && typeof error.message === "string") {
    const message = error.message;
    if (message.startsWith("OverconstrainedError")) {
      return true;
    }
  }
  return false;
}
var getAudioStream = async (trackConstraints, tracer) => {
  const constraints = {
    audio: {
      ...audioDeviceConstraints.audio,
      ...trackConstraints
    }
  };
  try {
    await getAudioBrowserPermission().prompt({
      throwOnNotAllowed: true,
      forcePrompt: true
    });
    return await getStream(constraints, tracer);
  } catch (error) {
    if (isNotFoundOrOverconstrainedError(error) && trackConstraints?.deviceId) {
      const { deviceId, ...relaxedConstraints } = trackConstraints;
      videoLoggerSystem.getLogger("devices").warn("Failed to get audio stream, will try again with relaxed constraints", { error, constraints, relaxedConstraints });
      return getAudioStream(relaxedConstraints);
    }
    videoLoggerSystem.getLogger("devices").error("Failed to get audio stream", {
      error,
      constraints
    });
    throw error;
  }
};
var getVideoStream = async (trackConstraints, tracer) => {
  const constraints = {
    video: {
      ...videoDeviceConstraints.video,
      ...trackConstraints
    }
  };
  try {
    await getVideoBrowserPermission().prompt({
      throwOnNotAllowed: true,
      forcePrompt: true
    });
    return await getStream(constraints, tracer);
  } catch (error) {
    if (isNotFoundOrOverconstrainedError(error) && trackConstraints?.deviceId) {
      const { deviceId, ...relaxedConstraints } = trackConstraints;
      videoLoggerSystem.getLogger("devices").warn("Failed to get video stream, will try again with relaxed constraints", { error, constraints, relaxedConstraints });
      return getVideoStream(relaxedConstraints);
    }
    videoLoggerSystem.getLogger("devices").error("Failed to get video stream", {
      error,
      constraints
    });
    throw error;
  }
};
var getDisplayMediaExecId = 0;
var getScreenShareStream = async (options, tracer) => {
  const tag = `navigator.mediaDevices.getDisplayMedia.${getDisplayMediaExecId++}.`;
  try {
    const constraints = {
      // @ts-expect-error - not present in types yet
      systemAudio: "include",
      ...options,
      video: typeof options?.video === "boolean" ? options.video : {
        width: { max: 2560 },
        height: { max: 1440 },
        frameRate: { ideal: 30 },
        ...options?.video
      },
      audio: typeof options?.audio === "boolean" ? options.audio : {
        channelCount: { ideal: 2 },
        echoCancellation: false,
        autoGainControl: false,
        noiseSuppression: false,
        ...options?.audio
      }
    };
    tracer?.trace(tag, constraints);
    const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
    tracer?.trace(`${tag}OnSuccess`, dumpStream(stream));
    return stream;
  } catch (e2) {
    tracer?.trace(`${tag}OnFailure`, e2.name);
    videoLoggerSystem.getLogger("devices").error("Failed to get screen share stream", e2);
    throw e2;
  }
};
var deviceIds$ = typeof navigator !== "undefined" && typeof navigator.mediaDevices !== "undefined" ? getDeviceChangeObserver().pipe(startWith(void 0), concatMap(() => navigator.mediaDevices.enumerateDevices()), shareReplay(1)) : void 0;
function resolveDeviceId(deviceId, kind) {
  if (deviceId !== "default")
    return deviceId;
  const devices = deviceIds$ && getCurrentValue(deviceIds$);
  if (!devices)
    return deviceId;
  const defaultDeviceInfo = devices.find((d) => d.deviceId === deviceId);
  if (!defaultDeviceInfo)
    return deviceId;
  const groupId = defaultDeviceInfo.groupId;
  const candidates = devices.filter((d) => d.kind === kind && d.deviceId !== "default" && d.groupId === groupId);
  return candidates.length === 1 ? candidates[0].deviceId : deviceId;
}
var isMobile = () => /Mobi/i.test(navigator.userAgent);
var DeviceManager = class {
  constructor(call, state, trackType) {
    this.stopOnLeave = true;
    this.subscriptions = [];
    this.areSubscriptionsSetUp = false;
    this.isTrackStoppedDueToTrackEnd = false;
    this.filters = [];
    this.statusChangeConcurrencyTag = Symbol("statusChangeConcurrencyTag");
    this.filterRegistrationConcurrencyTag = Symbol("filterRegistrationConcurrencyTag");
    this.dispose = () => {
      this.subscriptions.forEach((s2) => s2());
      this.subscriptions = [];
      this.areSubscriptionsSetUp = false;
    };
    this.call = call;
    this.state = state;
    this.trackType = trackType;
    this.logger = videoLoggerSystem.getLogger(`${TrackType[trackType].toLowerCase()} manager`);
    this.setup();
  }
  setup() {
    if (this.areSubscriptionsSetUp) {
      return;
    }
    this.areSubscriptionsSetUp = true;
    if (deviceIds$ && !isReactNative2() && (this.trackType === TrackType.AUDIO || this.trackType === TrackType.VIDEO)) {
      this.handleDisconnectedOrReplacedDevices();
    }
  }
  /**
   * Lists the available audio/video devices
   *
   * Note: It prompts the user for a permission to use devices (if not already granted)
   *
   * @returns an Observable that will be updated if a device is connected or disconnected
   */
  listDevices() {
    return this.getDevices();
  }
  /**
   * Returns `true` when this device is in enabled state.
   */
  get enabled() {
    return this.state.status === "enabled";
  }
  /**
   * Starts stream.
   */
  async enable() {
    this.state.prevStatus = this.state.optimisticStatus;
    if (this.state.optimisticStatus === "enabled") {
      return;
    }
    this.state.setPendingStatus("enabled");
    await withCancellation(this.statusChangeConcurrencyTag, async (signal) => {
      try {
        await this.unmuteStream();
        this.state.setStatus("enabled");
      } finally {
        if (!signal.aborted) {
          this.state.setPendingStatus(this.state.status);
        }
      }
    });
  }
  async disable(forceStopOrOptions) {
    const forceStop = typeof forceStopOrOptions === "boolean" ? forceStopOrOptions : forceStopOrOptions?.forceStop ?? false;
    this.state.prevStatus = this.state.optimisticStatus;
    if (!forceStop && this.state.optimisticStatus === "disabled") {
      return;
    }
    this.state.setPendingStatus("disabled");
    await withCancellation(this.statusChangeConcurrencyTag, async (signal) => {
      try {
        const stopTracks = forceStop || this.state.disableMode === "stop-tracks";
        await this.muteStream(stopTracks);
        this.state.setStatus("disabled");
      } finally {
        if (!signal.aborted) {
          this.state.setPendingStatus(this.state.status);
        }
      }
    });
  }
  /**
   * Returns a promise that resolves when all pe
   */
  async statusChangeSettled() {
    await settled(this.statusChangeConcurrencyTag);
  }
  /**
   * If status was previously enabled, it will re-enable the device.
   */
  async resume() {
    if (this.state.prevStatus === "enabled" && this.state.status !== "enabled") {
      await this.enable();
    }
  }
  /**
   * If the current device status is disabled, it will enable the device,
   * else it will disable it.
   */
  async toggle() {
    if (this.state.optimisticStatus === "enabled") {
      return await this.disable();
    } else {
      return await this.enable();
    }
  }
  /**
   * Registers a filter that will be applied to the stream.
   *
   * The registered filter will get the existing stream, and it should return
   * a new stream with the applied filter.
   *
   * @param filter the filter to register.
   * @returns MediaStreamFilterRegistrationResult
   */
  registerFilter(filter2) {
    const entry = {
      start: filter2,
      stop: void 0
    };
    this.call.tracer.trace(`registerFilter.${TrackType[this.trackType]}`, null);
    const registered = withoutConcurrency(this.filterRegistrationConcurrencyTag, async () => {
      await settled(this.statusChangeConcurrencyTag);
      this.filters.push(entry);
      await this.applySettingsToStream();
    });
    return {
      registered,
      unregister: () => withoutConcurrency(this.filterRegistrationConcurrencyTag, async () => {
        await settled(this.statusChangeConcurrencyTag);
        entry.stop?.();
        this.filters = this.filters.filter((f) => f !== entry);
        await this.applySettingsToStream();
        this.call.tracer.trace(`unregisterFilter.${TrackType[this.trackType]}`, null);
      })
    };
  }
  /**
   * Will set the default constraints for the device.
   *
   * @param constraints the constraints to set.
   */
  setDefaultConstraints(constraints) {
    this.state.setDefaultConstraints(constraints);
  }
  /**
   * Selects a device.
   *
   * Note: This method is not supported in React Native
   * @param deviceId the device id to select.
   */
  async select(deviceId) {
    if (isReactNative2()) {
      throw new Error("This method is not supported in React Native.");
    }
    const prevDeviceId = this.state.selectedDevice;
    if (deviceId === prevDeviceId) {
      return;
    }
    try {
      this.state.setDevice(deviceId);
      await this.applySettingsToStream();
    } catch (error) {
      this.state.setDevice(prevDeviceId);
      throw error;
    }
  }
  async applySettingsToStream() {
    console.log("applySettingsToStream ");
    await withCancellation(this.statusChangeConcurrencyTag, async (signal) => {
      if (this.enabled) {
        try {
          await this.muteStream();
          this.state.setStatus("disabled");
          if (signal.aborted) {
            return;
          }
          await this.unmuteStream();
          this.state.setStatus("enabled");
        } finally {
          if (!signal.aborted) {
            this.state.setPendingStatus(this.state.status);
          }
        }
      }
    });
  }
  publishStream(stream, options) {
    return this.call.publish(stream, this.trackType, options);
  }
  stopPublishStream() {
    return this.call.stopPublish(this.trackType);
  }
  getTracks() {
    return this.state.mediaStream?.getTracks() ?? [];
  }
  async muteStream(stopTracks = true) {
    const mediaStream = this.state.mediaStream;
    if (!mediaStream)
      return;
    this.logger.debug(`${stopTracks ? "Stopping" : "Disabling"} stream`);
    if (this.call.state.callingState === CallingState.JOINED) {
      await this.stopPublishStream();
    }
    this.muteLocalStream(stopTracks);
    const allEnded = this.getTracks().every((t2) => t2.readyState === "ended");
    if (allEnded) {
      if (typeof mediaStream.release === "function") {
        mediaStream.release();
      }
      this.state.setMediaStream(void 0, void 0);
      this.filters.forEach((entry) => entry.stop?.());
    }
  }
  disableTracks() {
    this.getTracks().forEach((track) => {
      if (track.enabled)
        track.enabled = false;
    });
  }
  enableTracks() {
    this.getTracks().forEach((track) => {
      if (!track.enabled)
        track.enabled = true;
    });
  }
  stopTracks() {
    this.getTracks().forEach((track) => {
      if (track.readyState === "live")
        track.stop();
    });
  }
  muteLocalStream(stopTracks) {
    if (!this.state.mediaStream) {
      return;
    }
    if (stopTracks) {
      this.stopTracks();
    } else {
      this.disableTracks();
    }
  }
  async unmuteStream() {
    this.logger.debug("Starting stream");
    let stream;
    let rootStream;
    if (this.state.mediaStream && this.getTracks().every((t2) => t2.readyState === "live")) {
      stream = this.state.mediaStream;
      this.enableTracks();
    } else {
      const defaultConstraints = this.state.defaultConstraints;
      const constraints = {
        ...defaultConstraints,
        deviceId: this.state.selectedDevice ? { exact: this.state.selectedDevice } : void 0
      };
      const chainWith = (parentStream) => async (filterStream) => {
        if (!parentStream)
          return filterStream;
        const parent = await parentStream;
        filterStream.getTracks().forEach((track) => {
          const originalStop = track.stop;
          track.stop = function stop() {
            originalStop.call(track);
            parent.getTracks().forEach((parentTrack) => {
              if (parentTrack.kind === track.kind) {
                parentTrack.stop();
              }
            });
          };
        });
        parent.getTracks().forEach((parentTrack) => {
          const handleParentTrackEnded = () => {
            filterStream.getTracks().forEach((track) => {
              if (parentTrack.kind !== track.kind)
                return;
              track.stop();
              track.dispatchEvent(new Event("ended"));
            });
          };
          parentTrack.addEventListener("ended", handleParentTrackEnded);
          this.subscriptions.push(() => {
            parentTrack.removeEventListener("ended", handleParentTrackEnded);
          });
        });
        return filterStream;
      };
      rootStream = this.getStream(constraints);
      stream = await this.filters.reduce((parent, entry) => parent.then((inputStream) => {
        const { stop, output } = entry.start(inputStream);
        entry.stop = stop;
        return output;
      }).then(chainWith(parent), (error) => {
        this.logger.warn("Filter failed to start and will be ignored", error);
        return parent;
      }), rootStream);
    }
    if (this.call.state.callingState === CallingState.JOINED) {
      await this.publishStream(stream);
    }
    if (this.state.mediaStream !== stream) {
      this.state.setMediaStream(stream, await rootStream);
      const handleTrackEnded = async () => {
        await this.statusChangeSettled();
        if (this.enabled) {
          this.isTrackStoppedDueToTrackEnd = true;
          setTimeout(() => {
            this.isTrackStoppedDueToTrackEnd = false;
          }, 2e3);
          await this.disable();
        }
      };
      const createTrackMuteHandler = (muted) => () => {
        if (!isMobile() || this.trackType !== TrackType.VIDEO)
          return;
        this.call.notifyTrackMuteState(muted, this.trackType).catch((err) => {
          this.logger.warn("Error while notifying track mute state", err);
        });
      };
      stream.getTracks().forEach((track) => {
        const muteHandler = createTrackMuteHandler(true);
        const unmuteHandler = createTrackMuteHandler(false);
        track.addEventListener("mute", muteHandler);
        track.addEventListener("unmute", unmuteHandler);
        track.addEventListener("ended", handleTrackEnded);
        this.subscriptions.push(() => {
          track.removeEventListener("mute", muteHandler);
          track.removeEventListener("unmute", unmuteHandler);
          track.removeEventListener("ended", handleTrackEnded);
        });
      });
    }
  }
  get mediaDeviceKind() {
    if (this.trackType === TrackType.AUDIO) {
      return "audioinput";
    }
    if (this.trackType === TrackType.VIDEO) {
      return "videoinput";
    }
    return "";
  }
  handleDisconnectedOrReplacedDevices() {
    this.subscriptions.push(createSubscription(combineLatest([
      deviceIds$.pipe(pairwise()),
      this.state.selectedDevice$
    ]), async ([[prevDevices, currentDevices], deviceId]) => {
      try {
        if (!deviceId)
          return;
        await this.statusChangeSettled();
        let isDeviceDisconnected = false;
        let isDeviceReplaced = false;
        const currentDevice = this.findDevice(currentDevices, deviceId);
        const prevDevice = this.findDevice(prevDevices, deviceId);
        if (!currentDevice && prevDevice) {
          isDeviceDisconnected = true;
        } else if (currentDevice && prevDevice && currentDevice.deviceId === prevDevice.deviceId && currentDevice.groupId !== prevDevice.groupId) {
          isDeviceReplaced = true;
        }
        if (isDeviceDisconnected) {
          await this.disable();
          await this.select(void 0);
        }
        if (isDeviceReplaced) {
          if (this.isTrackStoppedDueToTrackEnd && this.state.status === "disabled") {
            await this.enable();
            this.isTrackStoppedDueToTrackEnd = false;
          } else {
            await this.applySettingsToStream();
          }
        }
      } catch (err) {
        this.logger.warn("Unexpected error while handling disconnected or replaced device", err);
      }
    }));
  }
  findDevice(devices, deviceId) {
    const kind = this.mediaDeviceKind;
    return devices.find((d) => d.deviceId === deviceId && d.kind === kind);
  }
};
var DeviceManagerState = class {
  /**
   * Constructs a new InputMediaDeviceManagerState instance.
   *
   * @param disableMode the disable mode to use.
   * @param permission the BrowserPermission to use for querying.
   * `undefined` means no permission is required.
   */
  constructor(disableMode, permission) {
    this.statusSubject = new BehaviorSubject(void 0);
    this.optimisticStatusSubject = new BehaviorSubject(void 0);
    this.mediaStreamSubject = new BehaviorSubject(void 0);
    this.selectedDeviceSubject = new BehaviorSubject(void 0);
    this.defaultConstraintsSubject = new BehaviorSubject(void 0);
    this.mediaStream$ = this.mediaStreamSubject.asObservable();
    this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe(distinctUntilChanged());
    this.status$ = this.statusSubject.asObservable().pipe(distinctUntilChanged());
    this.optimisticStatus$ = this.optimisticStatusSubject.asObservable().pipe(distinctUntilChanged());
    this.defaultConstraints$ = this.defaultConstraintsSubject.asObservable();
    this.disableMode = disableMode;
    this.hasBrowserPermission$ = permission ? permission.asObservable().pipe(shareReplay(1)) : of(true);
    this.browserPermissionState$ = permission ? permission.asStateObservable().pipe(shareReplay(1)) : of("prompt");
    this.isPromptingPermission$ = permission ? permission.getIsPromptingObservable().pipe(shareReplay(1)) : of(false);
  }
  /**
   * The device status
   */
  get status() {
    return getCurrentValue(this.status$);
  }
  /**
   * The requested device status. Useful for optimistic UIs
   */
  get optimisticStatus() {
    return getCurrentValue(this.optimisticStatus$);
  }
  /**
   * The currently selected device
   */
  get selectedDevice() {
    return getCurrentValue(this.selectedDevice$);
  }
  /**
   * The current media stream, or `undefined` if the device is currently disabled.
   */
  get mediaStream() {
    return getCurrentValue(this.mediaStream$);
  }
  /**
   * @internal
   * @param status
   */
  setStatus(status) {
    setCurrentValue(this.statusSubject, status);
  }
  /**
   * @internal
   * @param pendingStatus
   */
  setPendingStatus(pendingStatus) {
    setCurrentValue(this.optimisticStatusSubject, pendingStatus);
  }
  /**
   * Updates the `mediaStream` state variable.
   *
   * @internal
   * @param stream the stream to set.
   * @param rootStream the root stream, applicable when filters are used
   * as this is the stream that holds the actual deviceId information.
   */
  setMediaStream(stream, rootStream) {
    setCurrentValue(this.mediaStreamSubject, stream);
    if (rootStream) {
      this.setDevice(this.getDeviceIdFromStream(rootStream));
    }
  }
  /**
   * @internal
   * @param deviceId the device id to set.
   */
  setDevice(deviceId) {
    setCurrentValue(this.selectedDeviceSubject, deviceId);
  }
  /**
   * Gets the default constraints for the device.
   */
  get defaultConstraints() {
    return getCurrentValue(this.defaultConstraints$);
  }
  /**
   * Sets the default constraints for the device.
   *
   * @internal
   * @param constraints the constraints to set.
   */
  setDefaultConstraints(constraints) {
    setCurrentValue(this.defaultConstraintsSubject, constraints);
  }
};
var CameraManagerState = class extends DeviceManagerState {
  constructor() {
    super("stop-tracks", getVideoBrowserPermission());
    this.directionSubject = new BehaviorSubject(void 0);
    this.direction$ = this.directionSubject.asObservable().pipe(distinctUntilChanged());
  }
  /**
   * The preferred camera direction
   * front - means the camera facing the user
   * back - means the camera facing the environment
   */
  get direction() {
    return getCurrentValue(this.direction$);
  }
  /**
   * @internal
   */
  setDirection(direction) {
    setCurrentValue(this.directionSubject, direction);
  }
  /**
   * @internal
   */
  setMediaStream(stream, rootStream) {
    super.setMediaStream(stream, rootStream);
    if (stream) {
      const direction = isReactNative2() ? this.direction : stream.getVideoTracks()[0]?.getSettings().facingMode === "environment" ? "back" : "front";
      this.setDirection(direction);
    }
  }
  getDeviceIdFromStream(stream) {
    const [track] = stream.getVideoTracks();
    return track?.getSettings().deviceId;
  }
};
var CameraManager = class extends DeviceManager {
  /**
   * Constructs a new CameraManager.
   *
   * @param call the call instance.
   */
  constructor(call) {
    super(call, new CameraManagerState(), TrackType.VIDEO);
    this.targetResolution = {
      width: 1280,
      height: 720
    };
  }
  isDirectionSupportedByDevice() {
    return isReactNative2() || isMobile();
  }
  /**
   * Select the camera direction.
   *
   * @param direction the direction of the camera to select.
   */
  async selectDirection(direction) {
    if (!this.isDirectionSupportedByDevice()) {
      this.logger.warn("Setting direction is not supported on this device");
      return;
    }
    if (isReactNative2()) {
      const videoTrack = this.getTracks()[0];
      await videoTrack?.applyConstraints({
        facingMode: direction === "front" ? "user" : "environment"
      });
    }
    this.state.setDirection(direction);
    this.state.setDevice(void 0);
    if (isReactNative2()) {
      return;
    }
    this.getTracks().forEach((track) => track.stop());
    try {
      await this.unmuteStream();
    } catch (error) {
      if (error instanceof Error && error.name === "NotReadableError") {
        await this.muteStream();
        await this.unmuteStream();
      }
      throw error;
    }
  }
  /**
   * Flips the camera direction: if it's front it will change to back, if it's back, it will change to front.
   *
   * Note: if there is no available camera with the desired direction, this method will do nothing.
   * @returns
   */
  async flip() {
    const newDirection = this.state.direction === "front" ? "back" : "front";
    await this.selectDirection(newDirection);
  }
  /**
   * @internal
   */
  async selectTargetResolution(resolution) {
    this.targetResolution.height = resolution.height;
    this.targetResolution.width = resolution.width;
    if (this.state.optimisticStatus === "enabled") {
      try {
        await this.statusChangeSettled();
      } catch (error) {
        this.logger.warn("could not apply target resolution", error);
      }
    }
    if (this.enabled && this.state.mediaStream) {
      const [videoTrack] = this.state.mediaStream.getVideoTracks();
      if (!videoTrack)
        return;
      const { width, height } = videoTrack.getSettings();
      if (width !== this.targetResolution.width || height !== this.targetResolution.height) {
        await this.applySettingsToStream();
        this.logger.debug(`${width}x${height} target resolution applied to media stream`);
      }
    }
  }
  /**
   * Applies the video settings to the camera.
   *
   * @param settings the video settings to apply.
   * @param publish whether to publish the stream after applying the settings.
   */
  async apply(settings, publish2) {
    const hasPublishedVideo = !!this.call.state.localParticipant?.videoStream;
    const hasPermission = this.call.permissionsContext.hasPermission(OwnCapability.SEND_AUDIO);
    if (hasPublishedVideo || !hasPermission)
      return;
    await this.statusChangeSettled();
    const { target_resolution, camera_facing, camera_default_on, enabled } = settings;
    let { width, height } = target_resolution;
    if (width < height)
      [width, height] = [height, width];
    await this.selectTargetResolution({ width, height });
    if (!this.state.direction && !this.state.selectedDevice) {
      this.state.setDirection(camera_facing === "front" ? "front" : "back");
    }
    if (!publish2)
      return;
    const { mediaStream } = this.state;
    if (this.enabled && mediaStream) {
      await this.publishStream(mediaStream);
    } else if (this.state.status === void 0 && camera_default_on && enabled) {
      await this.enable();
    }
  }
  getDevices() {
    return getVideoDevices(this.call.tracer);
  }
  getStream(constraints) {
    constraints.width = this.targetResolution.width;
    constraints.height = this.targetResolution.height;
    if (!constraints.deviceId && this.state.direction && this.isDirectionSupportedByDevice()) {
      constraints.facingMode = this.state.direction === "front" ? "user" : "environment";
    }
    return getVideoStream(constraints, this.call.tracer);
  }
};
var AudioDeviceManager = class extends DeviceManager {
  /**
   * Sets the audio bitrate profile and stereo mode.
   */
  async setAudioBitrateProfile(profile) {
    if (!this.call.state.settings?.audio.hifi_audio_enabled) {
      throw new Error("High Fidelity audio is not enabled for this call");
    }
    this.doSetAudioBitrateProfile(profile);
    this.state.setAudioBitrateProfile(profile);
    if (this.enabled) {
      await this.applySettingsToStream();
    }
  }
  /**
   * Overrides the default `publishStream` method to inject the audio bitrate profile.
   */
  publishStream(stream, options) {
    return super.publishStream(stream, {
      audioBitrateProfile: this.state.audioBitrateProfile,
      ...options
    });
  }
};
var createAudioConstraints = (profile) => {
  const stereo = profile === AudioBitrateProfile.MUSIC_HIGH_QUALITY;
  return {
    echoCancellation: !stereo,
    noiseSuppression: !stereo,
    autoGainControl: !stereo,
    channelCount: { ideal: stereo ? 2 : 1 }
  };
};
var AudioDeviceManagerState = class extends DeviceManagerState {
  /**
   * Constructs a new AudioDeviceManagerState instance.
   */
  constructor(disableMode, permission, profile) {
    super(disableMode, permission);
    this.audioBitrateProfileSubject = new BehaviorSubject(profile);
    this.audioBitrateProfile$ = this.audioBitrateProfileSubject.asObservable().pipe(distinctUntilChanged());
  }
  /**
   * Returns the current audio bitrate profile.
   */
  get audioBitrateProfile() {
    return getCurrentValue(this.audioBitrateProfile$);
  }
  /**
   * Sets the audio bitrate profile and stereo mode.
   */
  setAudioBitrateProfile(profile) {
    setCurrentValue(this.audioBitrateProfileSubject, profile);
  }
};
var MicrophoneManagerState = class extends AudioDeviceManagerState {
  constructor(disableMode) {
    super(disableMode, getAudioBrowserPermission(), AudioBitrateProfile.VOICE_STANDARD_UNSPECIFIED);
    this.speakingWhileMutedSubject = new BehaviorSubject(false);
    this.speakingWhileMuted$ = this.speakingWhileMutedSubject.asObservable().pipe(distinctUntilChanged());
  }
  /**
   * `true` if the user's microphone is muted but they're speaking.
   */
  get speakingWhileMuted() {
    return getCurrentValue(this.speakingWhileMuted$);
  }
  /**
   * @internal
   */
  setSpeakingWhileMuted(isSpeaking) {
    setCurrentValue(this.speakingWhileMutedSubject, isSpeaking);
  }
  getDeviceIdFromStream(stream) {
    const [track] = stream.getAudioTracks();
    const unresolvedDeviceId = track?.getSettings().deviceId;
    return resolveDeviceId(unresolvedDeviceId, "audioinput");
  }
};
var DETECTION_FREQUENCY_IN_MS = 500;
var AUDIO_LEVEL_THRESHOLD = 150;
var FFT_SIZE = 128;
var createSoundDetector = (audioStream, onSoundDetectedStateChanged, options = {}) => {
  const { detectionFrequencyInMs = DETECTION_FREQUENCY_IN_MS, audioLevelThreshold = AUDIO_LEVEL_THRESHOLD, fftSize = FFT_SIZE, destroyStreamOnStop = true } = options;
  const audioContext = new AudioContext();
  const analyser = audioContext.createAnalyser();
  analyser.fftSize = fftSize;
  const microphone = audioContext.createMediaStreamSource(audioStream);
  microphone.connect(analyser);
  const intervalId = setInterval(() => {
    const data = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(data);
    const isSoundDetected = data.some((value) => value >= audioLevelThreshold);
    const averagedDataValue = data.reduce((pv, cv) => pv + cv, 0) / data.length;
    const percentage = averagedDataValue > audioLevelThreshold ? 100 : Math.round(averagedDataValue / audioLevelThreshold * 100);
    if (audioStream.getAudioTracks()[0]?.enabled) {
      onSoundDetectedStateChanged({ isSoundDetected, audioLevel: percentage });
    } else {
      onSoundDetectedStateChanged({ isSoundDetected: false, audioLevel: 0 });
    }
  }, detectionFrequencyInMs);
  return async function stop() {
    clearInterval(intervalId);
    microphone.disconnect();
    analyser.disconnect();
    if (audioContext.state !== "closed") {
      await audioContext.close();
    }
    if (destroyStreamOnStop) {
      audioStream.getTracks().forEach((track) => {
        track.stop();
        audioStream.removeTrack(track);
      });
    }
  };
};
var RNSpeechDetector = class {
  constructor(externalAudioStream) {
    this.pc1 = new RTCPeerConnection({});
    this.pc2 = new RTCPeerConnection({});
    this.externalAudioStream = externalAudioStream;
  }
  /**
   * Starts the speech detection.
   */
  async start(onSoundDetectedStateChanged) {
    try {
      let audioStream;
      if (this.externalAudioStream != null) {
        audioStream = this.externalAudioStream;
      } else {
        audioStream = await navigator.mediaDevices.getUserMedia({
          audio: true
        });
        this.audioStream = audioStream;
      }
      this.pc1.addEventListener("icecandidate", async (e2) => {
        await this.pc2.addIceCandidate(e2.candidate);
      });
      this.pc2.addEventListener("icecandidate", async (e2) => {
        await this.pc1.addIceCandidate(e2.candidate);
      });
      this.pc2.addEventListener("track", (e2) => {
        e2.streams[0].getTracks().forEach((track) => {
          track._setVolume(0);
        });
      });
      audioStream.getTracks().forEach((track) => this.pc1.addTrack(track, audioStream));
      const offer = await this.pc1.createOffer({});
      await this.pc2.setRemoteDescription(offer);
      await this.pc1.setLocalDescription(offer);
      const answer = await this.pc2.createAnswer();
      await this.pc1.setRemoteDescription(answer);
      await this.pc2.setLocalDescription(answer);
      const unsub = this.onSpeakingDetectedStateChange(onSoundDetectedStateChanged);
      return () => {
        unsub();
        this.stop();
      };
    } catch (error) {
      const logger = videoLoggerSystem.getLogger("RNSpeechDetector");
      logger.error("error handling permissions: ", error);
      return () => {
      };
    }
  }
  /**
   * Stops the speech detection and releases all allocated resources.
   */
  stop() {
    this.pc1.close();
    this.pc2.close();
    if (this.externalAudioStream != null) {
      this.externalAudioStream = void 0;
    } else {
      this.cleanupAudioStream();
    }
  }
  /**
   * Public method that detects the audio levels and returns the status.
   */
  onSpeakingDetectedStateChange(onSoundDetectedStateChanged) {
    const initialBaselineNoiseLevel = 0.13;
    let baselineNoiseLevel = initialBaselineNoiseLevel;
    let speechDetected = false;
    let speechTimer;
    let silenceTimer;
    const audioLevelHistory = [];
    const historyLength = 10;
    const silenceThreshold = 1.1;
    const resetThreshold = 0.9;
    const speechTimeout = 500;
    const silenceTimeout = 5e3;
    const checkAudioLevel = async () => {
      try {
        const stats = await this.pc1.getStats();
        const report = flatten(stats);
        const audioMediaSourceStats = report.find((stat) => stat.type === "media-source" && stat.kind === "audio");
        if (audioMediaSourceStats) {
          const { audioLevel } = audioMediaSourceStats;
          if (audioLevel) {
            audioLevelHistory.push(audioLevel);
            if (audioLevelHistory.length > historyLength) {
              audioLevelHistory.shift();
            }
            const avgAudioLevel = audioLevelHistory.reduce((a2, b2) => a2 + b2, 0) / audioLevelHistory.length;
            if (avgAudioLevel < baselineNoiseLevel * silenceThreshold) {
              if (!silenceTimer) {
                silenceTimer = setTimeout(() => {
                  baselineNoiseLevel = Math.min(avgAudioLevel * resetThreshold, initialBaselineNoiseLevel);
                }, silenceTimeout);
              }
            } else {
              clearTimeout(silenceTimer);
              silenceTimer = void 0;
            }
            if (avgAudioLevel > baselineNoiseLevel * 1.5) {
              if (!speechDetected) {
                speechDetected = true;
                onSoundDetectedStateChanged({
                  isSoundDetected: true,
                  audioLevel
                });
              }
              clearTimeout(speechTimer);
              speechTimer = setTimeout(() => {
                speechDetected = false;
                onSoundDetectedStateChanged({
                  isSoundDetected: false,
                  audioLevel: 0
                });
              }, speechTimeout);
            }
          }
        }
      } catch (error) {
        const logger = videoLoggerSystem.getLogger("RNSpeechDetector");
        logger.error("error checking audio level from stats", error);
      }
    };
    const intervalId = setInterval(checkAudioLevel, 100);
    return () => {
      clearInterval(intervalId);
      clearTimeout(speechTimer);
      clearTimeout(silenceTimer);
    };
  }
  cleanupAudioStream() {
    if (!this.audioStream) {
      return;
    }
    this.audioStream.getTracks().forEach((track) => track.stop());
    if (
      // @ts-expect-error release() is present in react-native-webrtc
      typeof this.audioStream.release === "function"
    ) {
      this.audioStream.release();
    }
  }
};
var MicrophoneManager = class extends AudioDeviceManager {
  constructor(call, disableMode = "stop-tracks") {
    super(call, new MicrophoneManagerState(disableMode), TrackType.AUDIO);
    this.speakingWhileMutedNotificationEnabled = true;
    this.soundDetectorConcurrencyTag = Symbol("soundDetectorConcurrencyTag");
  }
  setup() {
    super.setup();
    this.subscriptions.push(createSafeAsyncSubscription(combineLatest([
      this.call.state.callingState$,
      this.call.state.ownCapabilities$,
      this.state.selectedDevice$,
      this.state.status$
    ]), async ([callingState, ownCapabilities, deviceId, status]) => {
      try {
        if (callingState === CallingState.LEFT) {
          await this.stopSpeakingWhileMutedDetection();
        }
        if (callingState !== CallingState.JOINED)
          return;
        if (!this.speakingWhileMutedNotificationEnabled)
          return;
        if (ownCapabilities.includes(OwnCapability.SEND_AUDIO)) {
          if (status === "disabled") {
            await this.startSpeakingWhileMutedDetection(deviceId);
          } else {
            await this.stopSpeakingWhileMutedDetection();
          }
        } else {
          await this.stopSpeakingWhileMutedDetection();
        }
      } catch (err) {
        this.logger.warn("Could not enable speaking while muted", err);
      }
    }));
    this.subscriptions.push(createSubscription(this.call.state.callingState$, (callingState) => {
      if (!this.noiseCancellationRegistration || !this.noiseCancellation)
        return;
      const autoOn = this.call.state.settings?.audio.noise_cancellation?.mode === NoiseCancellationSettingsModeEnum.AUTO_ON;
      if (autoOn && callingState === CallingState.JOINED) {
        this.noiseCancellationRegistration.then(() => {
          if (this.noiseCancellation?.canAutoEnable) {
            return this.noiseCancellation.canAutoEnable();
          }
          return true;
        }).then((canAutoEnable) => {
          if (canAutoEnable) {
            this.noiseCancellation?.enable().catch((err) => {
              this.logger.warn("Failed to enable noise cancellation", err);
            });
          }
        }).catch((err) => {
          this.logger.warn(`Failed to enable noise cancellation`, err);
          return this.call.notifyNoiseCancellationStopped();
        });
      } else if (callingState === CallingState.LEFT) {
        this.noiseCancellationRegistration.then(() => this.noiseCancellation?.disable()).catch((err) => {
          this.logger.warn(`Failed to disable noise cancellation`, err);
        });
      }
    }));
  }
  /**
   * Enables noise cancellation for the microphone.
   *
   * @param noiseCancellation - a noise cancellation instance to use.
   */
  async enableNoiseCancellation(noiseCancellation) {
    const { ownCapabilities, settings } = this.call.state;
    const hasNoiseCancellationCapability = ownCapabilities.includes(OwnCapability.ENABLE_NOISE_CANCELLATION);
    if (!hasNoiseCancellationCapability) {
      throw new Error("Noise cancellation is not available.");
    }
    const noiseCancellationSettings = settings?.audio.noise_cancellation;
    if (!noiseCancellationSettings || noiseCancellationSettings.mode === NoiseCancellationSettingsModeEnum.DISABLED) {
      throw new Error("Noise cancellation is disabled for this call type.");
    }
    try {
      this.noiseCancellation = noiseCancellation;
      this.noiseCancellationChangeUnsubscribe = this.noiseCancellation.on("change", (enabled) => {
        this.call.tracer.trace("noiseCancellation.enabled", enabled);
        if (enabled) {
          this.call.notifyNoiseCancellationStarting().catch((err) => {
            this.logger.warn(`notifyNoiseCancellationStart failed`, err);
          });
        } else {
          this.call.notifyNoiseCancellationStopped().catch((err) => {
            this.logger.warn(`notifyNoiseCancellationStop failed`, err);
          });
        }
      });
      if (isReactNative2()) {
        this.noiseCancellationRegistration = Promise.resolve();
      } else {
        const registrationResult = this.registerFilter(noiseCancellation.toFilter());
        this.noiseCancellationRegistration = registrationResult.registered;
        this.unregisterNoiseCancellation = registrationResult.unregister;
        await this.noiseCancellationRegistration;
      }
      if (noiseCancellationSettings.mode === NoiseCancellationSettingsModeEnum.AUTO_ON && this.call.state.callingState === CallingState.JOINED) {
        let canAutoEnable = true;
        if (noiseCancellation.canAutoEnable) {
          canAutoEnable = await noiseCancellation.canAutoEnable();
        }
        if (canAutoEnable) {
          noiseCancellation.enable().catch((err) => {
            this.logger.warn("Failed to enable noise cancellation", err);
          });
        }
      }
    } catch (e2) {
      this.logger.warn("Failed to enable noise cancellation", e2);
      await this.disableNoiseCancellation().catch((err) => {
        this.logger.warn("Failed to disable noise cancellation", err);
      });
      throw e2;
    }
  }
  /**
   * Disables noise cancellation for the microphone.
   */
  async disableNoiseCancellation() {
    await (this.unregisterNoiseCancellation?.() ?? Promise.resolve()).then(() => this.noiseCancellation?.disable()).then(() => this.noiseCancellationChangeUnsubscribe?.()).catch((err) => {
      this.logger.warn("Failed to unregister noise cancellation", err);
    });
    this.call.tracer.trace("noiseCancellation.disabled", true);
    await this.call.notifyNoiseCancellationStopped();
  }
  /**
   * Enables speaking while muted notification.
   */
  async enableSpeakingWhileMutedNotification() {
    this.speakingWhileMutedNotificationEnabled = true;
    if (this.state.status === "disabled") {
      await this.startSpeakingWhileMutedDetection(this.state.selectedDevice);
    }
  }
  /**
   * Disables speaking while muted notification.
   */
  async disableSpeakingWhileMutedNotification() {
    this.speakingWhileMutedNotificationEnabled = false;
    await this.stopSpeakingWhileMutedDetection();
  }
  /**
   * Applies the audio settings to the microphone.
   * @param settings the audio settings to apply.
   * @param publish whether to publish the stream after applying the settings.
   */
  async apply(settings, publish2) {
    if (!publish2)
      return;
    const hasPublishedAudio = !!this.call.state.localParticipant?.audioStream;
    const hasPermission = this.call.permissionsContext.hasPermission(OwnCapability.SEND_AUDIO);
    if (hasPublishedAudio || !hasPermission)
      return;
    await this.statusChangeSettled();
    const { mediaStream } = this.state;
    if (this.enabled && mediaStream) {
      await this.publishStream(mediaStream);
    } else if (this.state.status === void 0 && settings.mic_default_on) {
      await this.enable();
    }
  }
  getDevices() {
    return getAudioDevices(this.call.tracer);
  }
  getStream(constraints) {
    return getAudioStream(constraints, this.call.tracer);
  }
  doSetAudioBitrateProfile(profile) {
    this.setDefaultConstraints({
      ...this.state.defaultConstraints,
      ...createAudioConstraints(profile)
    });
    if (this.noiseCancellation) {
      const disableAudioProcessing = profile === AudioBitrateProfile.MUSIC_HIGH_QUALITY;
      if (disableAudioProcessing) {
        this.noiseCancellation.disable().catch((err) => {
          this.logger.warn("Failed to disable noise cancellation for music mode", err);
        });
      } else {
        this.noiseCancellation.enable().catch((err) => {
          this.logger.warn("Failed to enable noise cancellation", err);
        });
      }
    }
  }
  async startSpeakingWhileMutedDetection(deviceId) {
    await withoutConcurrency(this.soundDetectorConcurrencyTag, async () => {
      await this.stopSpeakingWhileMutedDetection();
      if (isReactNative2()) {
        this.rnSpeechDetector = new RNSpeechDetector();
        const unsubscribe = await this.rnSpeechDetector.start((event) => {
          this.state.setSpeakingWhileMuted(event.isSoundDetected);
        });
        this.soundDetectorCleanup = () => {
          unsubscribe();
          this.rnSpeechDetector = void 0;
        };
      } else {
        const stream = await this.getStream({
          deviceId: { exact: deviceId }
        });
        this.soundDetectorCleanup = createSoundDetector(stream, (event) => {
          this.state.setSpeakingWhileMuted(event.isSoundDetected);
        });
      }
    });
  }
  async stopSpeakingWhileMutedDetection() {
    await withoutConcurrency(this.soundDetectorConcurrencyTag, async () => {
      if (!this.soundDetectorCleanup)
        return;
      const soundDetectorCleanup = this.soundDetectorCleanup;
      this.soundDetectorCleanup = void 0;
      this.state.setSpeakingWhileMuted(false);
      await soundDetectorCleanup();
    });
  }
};
var ScreenShareState = class extends AudioDeviceManagerState {
  /**
   * Constructs a new ScreenShareState instance.
   */
  constructor() {
    super("stop-tracks", void 0, AudioBitrateProfile.MUSIC_HIGH_QUALITY);
    this.audioEnabledSubject = new BehaviorSubject(true);
    this.settingsSubject = new BehaviorSubject(void 0);
    this.audioEnabled$ = this.audioEnabledSubject.asObservable().pipe(distinctUntilChanged());
    this.settings$ = this.settingsSubject.asObservable();
    this.getDeviceIdFromStream = (stream) => {
      const [track] = stream.getTracks();
      return track?.getSettings().deviceId;
    };
  }
  /**
   * The current screen share audio status.
   */
  get audioEnabled() {
    return getCurrentValue(this.audioEnabled$);
  }
  /**
   * Set the current screen share audio status.
   */
  setAudioEnabled(isEnabled) {
    setCurrentValue(this.audioEnabledSubject, isEnabled);
  }
  /**
   * The current screen share settings.
   */
  get settings() {
    return getCurrentValue(this.settings$);
  }
  /**
   * Set the current screen share settings.
   *
   * @param settings the screen share settings to set.
   */
  setSettings(settings) {
    setCurrentValue(this.settingsSubject, settings);
  }
};
var ScreenShareManager = class extends AudioDeviceManager {
  constructor(call) {
    super(call, new ScreenShareState(), TrackType.SCREEN_SHARE);
  }
  setup() {
    super.setup();
    this.subscriptions.push(createSubscription(this.call.state.settings$, (settings) => {
      const maybeTargetResolution = settings?.screensharing.target_resolution;
      if (maybeTargetResolution) {
        this.setDefaultConstraints({
          ...this.state.defaultConstraints,
          video: {
            width: maybeTargetResolution.width,
            height: maybeTargetResolution.height
          }
        });
      }
    }));
  }
  /**
   * Will enable screen share audio options on supported platforms.
   *
   * Note: for ongoing screen share, audio won't be enabled until you
   * re-publish the screen share stream.
   */
  enableScreenShareAudio() {
    this.state.setAudioEnabled(true);
  }
  /**
   * Will disable screen share audio options on supported platforms.
   */
  async disableScreenShareAudio() {
    this.state.setAudioEnabled(false);
    if (this.call.publisher?.isPublishing(TrackType.SCREEN_SHARE_AUDIO)) {
      await this.call.stopPublish(TrackType.SCREEN_SHARE_AUDIO);
    }
  }
  /**
   * Returns the current screen share settings.
   */
  getSettings() {
    return this.state.settings;
  }
  /**
   * Sets the current screen share settings.
   *
   * @param settings the settings to set.
   */
  setSettings(settings) {
    this.state.setSettings(settings);
  }
  getDevices() {
    return of([]);
  }
  async getStream(constraints) {
    if (!this.state.audioEnabled) {
      constraints.audio = false;
    }
    const stream = await getScreenShareStream(constraints, this.call.tracer);
    const [track] = stream.getVideoTracks();
    const { contentHint } = this.state.settings || {};
    if (typeof contentHint !== "undefined" && track && "contentHint" in track) {
      this.call.tracer.trace("navigator.mediaDevices.getDisplayMedia.contentHint", contentHint);
      track.contentHint = contentHint;
    }
    return stream;
  }
  doSetAudioBitrateProfile(profile) {
    const { defaultConstraints } = this.state;
    const baseAudioConstraints = typeof defaultConstraints?.audio !== "boolean" ? defaultConstraints?.audio : null;
    this.setDefaultConstraints({
      ...defaultConstraints,
      audio: {
        ...baseAudioConstraints,
        ...createAudioConstraints(profile)
      }
    });
  }
  async stopPublishStream() {
    return this.call.stopPublish(TrackType.SCREEN_SHARE, TrackType.SCREEN_SHARE_AUDIO);
  }
  /**
   * Overrides the default `select` method to throw an error.
   */
  async select() {
    throw new Error("Not supported");
  }
};
var SpeakerState = class {
  constructor(tracer) {
    this.tracer = tracer;
    this.selectedDeviceSubject = new BehaviorSubject("");
    this.volumeSubject = new BehaviorSubject(1);
    this.isDeviceSelectionSupported = checkIfAudioOutputChangeSupported();
    this.selectedDevice$ = this.selectedDeviceSubject.asObservable().pipe(distinctUntilChanged());
    this.volume$ = this.volumeSubject.asObservable().pipe(distinctUntilChanged());
  }
  /**
   * The currently selected device
   *
   * Note: this feature is not supported in React Native
   */
  get selectedDevice() {
    return getCurrentValue(this.selectedDevice$);
  }
  /**
   * The currently selected volume
   *
   * Note: this feature is not supported in React Native
   */
  get volume() {
    return getCurrentValue(this.volume$);
  }
  /**
   * @internal
   * @param deviceId
   */
  setDevice(deviceId) {
    setCurrentValue(this.selectedDeviceSubject, deviceId);
    this.tracer.trace("navigator.mediaDevices.setSinkId", deviceId);
  }
  /**
   * @internal
   * @param volume
   */
  setVolume(volume) {
    setCurrentValue(this.volumeSubject, volume);
  }
};
var SpeakerManager = class {
  constructor(call) {
    this.subscriptions = [];
    this.areSubscriptionsSetUp = false;
    this.dispose = () => {
      this.subscriptions.forEach((s2) => s2.unsubscribe());
      this.subscriptions = [];
      this.areSubscriptionsSetUp = false;
    };
    this.call = call;
    this.state = new SpeakerState(call.tracer);
    this.setup();
  }
  setup() {
    if (this.areSubscriptionsSetUp) {
      return;
    }
    this.areSubscriptionsSetUp = true;
    if (deviceIds$ && !isReactNative2()) {
      this.subscriptions.push(combineLatest([deviceIds$, this.state.selectedDevice$]).subscribe(([devices, deviceId]) => {
        if (!deviceId) {
          return;
        }
        const device = devices.find((d) => d.deviceId === deviceId && d.kind === "audiooutput");
        if (!device) {
          this.select("");
        }
      }));
    }
  }
  /**
   * Lists the available audio output devices
   *
   * Note: It prompts the user for a permission to use devices (if not already granted)
   * Note: This method is not supported in React Native
   *
   * @returns an Observable that will be updated if a device is connected or disconnected
   */
  listDevices() {
    if (isReactNative2()) {
      throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
    }
    return getAudioOutputDevices(this.call.tracer);
  }
  /**
   * Select a device.
   *
   * Note: This method is not supported in React Native
   *
   * @param deviceId empty string means the system default
   */
  select(deviceId) {
    if (isReactNative2()) {
      throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
    }
    this.state.setDevice(deviceId);
  }
  /**
   * Set the volume of the audio elements
   * @param volume a number between 0 and 1.
   *
   * Note: This method is not supported in React Native
   */
  setVolume(volume) {
    if (isReactNative2()) {
      throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
    }
    if (volume && (volume < 0 || volume > 1)) {
      throw new Error("Volume must be between 0 and 1");
    }
    this.state.setVolume(volume);
  }
  /**
   * Set the volume of a participant.
   *
   * Note: This method is not supported in React Native.
   *
   * @param sessionId the participant's session id.
   * @param volume a number between 0 and 1. Set it to `undefined` to use the default volume.
   */
  setParticipantVolume(sessionId, volume) {
    if (volume && (volume < 0 || volume > 1)) {
      throw new Error("Volume must be between 0 and 1, or undefined");
    }
    this.call.state.updateParticipant(sessionId, (p2) => {
      if (isReactNative2() && p2.audioStream) {
        for (const track of p2.audioStream.getAudioTracks()) {
          track?._setVolume(volume);
        }
      }
      return { audioVolume: volume };
    });
  }
};
var Call = class {
  /**
   * Constructs a new `Call` instance.
   *
   * NOTE: Don't call the constructor directly, instead
   * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)
   * method to construct a `Call` instance.
   */
  constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing = false, watching = false }) {
    this.state = new CallState();
    this.permissionsContext = new PermissionsContext();
    this.tracer = new Tracer(null);
    this.dispatcher = new Dispatcher();
    this.statsReportingIntervalInMs = 2e3;
    this.sfuClientTag = 0;
    this.reconnectConcurrencyTag = Symbol("reconnectConcurrencyTag");
    this.reconnectAttempts = 0;
    this.reconnectStrategy = WebsocketReconnectStrategy.UNSPECIFIED;
    this.reconnectReason = "";
    this.fastReconnectDeadlineSeconds = 0;
    this.disconnectionTimeoutSeconds = 0;
    this.lastOfflineTimestamp = 0;
    this.trackPublishOrder = [];
    this.hasJoinedOnce = false;
    this.deviceSettingsAppliedOnce = false;
    this.initialized = false;
    this.joinLeaveConcurrencyTag = Symbol("joinLeaveConcurrencyTag");
    this.leaveCallHooks = /* @__PURE__ */ new Set();
    this.streamClientEventHandlers = /* @__PURE__ */ new Map();
    this.clientCapabilities = /* @__PURE__ */ new Set([
      ClientCapability.SUBSCRIBER_VIDEO_PAUSE
    ]);
    this.setup = async () => {
      await withoutConcurrency(this.joinLeaveConcurrencyTag, async () => {
        if (this.initialized)
          return;
        this.leaveCallHooks.add(this.on("all", (event) => {
          this.state.updateFromEvent(event);
        }));
        this.leaveCallHooks.add(this.on("changePublishOptions", (event) => {
          this.currentPublishOptions = event.publishOptions;
        }));
        this.leaveCallHooks.add(registerEventHandlers(this, this.dispatcher));
        this.registerEffects();
        this.registerReconnectHandlers();
        this.camera.setup();
        this.microphone.setup();
        this.screenShare.setup();
        this.speaker.setup();
        if (this.state.callingState === CallingState.LEFT) {
          this.state.setCallingState(CallingState.IDLE);
        }
        this.initialized = true;
      });
    };
    this.registerEffects = () => {
      this.leaveCallHooks.add(
        // handles updating the permissions context when the settings change.
        createSubscription(this.state.settings$, (settings) => {
          if (!settings)
            return;
          this.permissionsContext.setCallSettings(settings);
        })
      );
      this.leaveCallHooks.add(
        // handle the case when the user permissions are modified.
        createSafeAsyncSubscription(this.state.ownCapabilities$, this.handleOwnCapabilitiesUpdated)
      );
      this.leaveCallHooks.add(
        // handles the case when the user is blocked by the call owner.
        createSubscription(this.state.blockedUserIds$, async (blockedUserIds) => {
          if (!blockedUserIds || blockedUserIds.length === 0)
            return;
          const currentUserId = this.currentUserId;
          if (currentUserId && blockedUserIds.includes(currentUserId)) {
            this.logger.info("Leaving call because of being blocked");
            await this.leave({ message: "user blocked" }).catch((err) => {
              this.logger.error("Error leaving call after being blocked", err);
            });
          }
        })
      );
      if (this.ringing) {
        this.handleRingingCall();
      } else {
        this.leaveCallHooks.add(
          // "ringing" mode effects and event handlers
          createSubscription(this.ringingSubject, (isRinging) => {
            if (!isRinging)
              return;
            this.handleRingingCall();
          })
        );
      }
      this.leaveCallHooks.add(
        // cancel auto-drop when call is accepted or rejected
        createSubscription(this.state.session$, (session) => {
          if (!this.ringing)
            return;
          const receiverId = this.clientStore.connectedUser?.id;
          if (!receiverId)
            return;
          const isAcceptedByMe = Boolean(session?.accepted_by[receiverId]);
          const isRejectedByMe = Boolean(session?.rejected_by[receiverId]);
          if (isAcceptedByMe || isRejectedByMe) {
            this.cancelAutoDrop();
          }
          const isAcceptedElsewhere = isAcceptedByMe && this.state.callingState === CallingState.RINGING;
          if ((isAcceptedElsewhere || isRejectedByMe) && !hasPending(this.joinLeaveConcurrencyTag)) {
            this.leave().catch(() => {
              this.logger.error("Could not leave a call that was accepted or rejected elsewhere");
            });
          }
        })
      );
    };
    this.handleRingingCall = () => {
      const callSession = this.state.session;
      const receiver_id = this.clientStore.connectedUser?.id;
      const ended_at = callSession?.ended_at;
      const created_by_id = this.state.createdBy?.id;
      const rejected_by = callSession?.rejected_by;
      const accepted_by = callSession?.accepted_by;
      let leaveCallIdle = false;
      if (ended_at) {
        leaveCallIdle = true;
      } else if (created_by_id && rejected_by) {
        if (rejected_by[created_by_id]) {
          leaveCallIdle = true;
        }
      } else if (receiver_id && rejected_by) {
        if (rejected_by[receiver_id]) {
          leaveCallIdle = true;
        }
      } else if (receiver_id && accepted_by) {
        if (accepted_by[receiver_id]) {
          leaveCallIdle = true;
        }
      }
      if (leaveCallIdle) {
        if (this.state.callingState !== CallingState.IDLE) {
          this.state.setCallingState(CallingState.IDLE);
        }
      } else {
        if (this.state.callingState === CallingState.IDLE) {
          this.state.setCallingState(CallingState.RINGING);
        }
        this.scheduleAutoDrop();
        this.leaveCallHooks.add(registerRingingCallEventHandlers(this));
      }
    };
    this.handleOwnCapabilitiesUpdated = async (ownCapabilities2) => {
      this.permissionsContext.setPermissions(ownCapabilities2);
      if (!this.publisher)
        return;
      const permissionToTrackType = {
        [OwnCapability.SEND_AUDIO]: TrackType.AUDIO,
        [OwnCapability.SEND_VIDEO]: TrackType.VIDEO,
        [OwnCapability.SCREENSHARE]: TrackType.SCREEN_SHARE
      };
      for (const [permission, trackType] of Object.entries(permissionToTrackType)) {
        const hasPermission = this.permissionsContext.hasPermission(permission);
        if (hasPermission)
          continue;
        try {
          switch (trackType) {
            case TrackType.AUDIO:
              if (this.microphone.enabled)
                await this.microphone.disable();
              break;
            case TrackType.VIDEO:
              if (this.camera.enabled)
                await this.camera.disable();
              break;
            case TrackType.SCREEN_SHARE:
              if (this.screenShare.enabled)
                await this.screenShare.disable();
              break;
          }
        } catch (err) {
          this.logger.error(`Can't disable mic/camera/screenshare after revoked permissions`, err);
        }
      }
    };
    this.on = (eventName, fn2) => {
      if (isSfuEvent(eventName)) {
        return this.dispatcher.on(eventName, fn2);
      }
      const offHandler = this.streamClient.on(eventName, (e2) => {
        const event = e2;
        if (event.call_cid && event.call_cid === this.cid) {
          fn2(event);
        }
      });
      this.streamClientEventHandlers.set(fn2, offHandler);
      return () => {
        this.off(eventName, fn2);
      };
    };
    this.off = (eventName, fn2) => {
      if (isSfuEvent(eventName)) {
        return this.dispatcher.off(eventName, fn2);
      }
      const registeredOffHandler = this.streamClientEventHandlers.get(fn2);
      if (registeredOffHandler) {
        registeredOffHandler();
      }
    };
    this.leave = async ({ reject, reason, message } = {}) => {
      if (this.state.callingState === CallingState.LEFT) {
        throw new Error("Cannot leave call that has already been left.");
      }
      await withoutConcurrency(this.joinLeaveConcurrencyTag, async () => {
        const callingState = this.state.callingState;
        if (callingState === CallingState.LEFT) {
          return;
        }
        if (callingState === CallingState.JOINING) {
          const waitUntilCallJoined = () => {
            return new Promise((resolve) => {
              this.state.callingState$.pipe(takeWhile((state) => state !== CallingState.JOINED, true)).subscribe(() => resolve());
            });
          };
          await waitUntilCallJoined();
        }
        if (callingState === CallingState.RINGING && reject !== false) {
          if (reject) {
            await this.reject(reason ?? "decline");
          } else {
            const hasOtherParticipants = this.state.remoteParticipants.length > 0;
            if (this.isCreatedByMe && !hasOtherParticipants) {
              await this.reject("cancel");
            }
          }
        }
        this.statsReporter?.stop();
        this.statsReporter = void 0;
        this.sfuStatsReporter?.flush();
        this.sfuStatsReporter?.stop();
        this.sfuStatsReporter = void 0;
        this.subscriber?.dispose();
        this.subscriber = void 0;
        this.publisher?.dispose();
        this.publisher = void 0;
        await this.sfuClient?.leaveAndClose(message ?? reason ?? "user is leaving the call");
        this.sfuClient = void 0;
        this.dynascaleManager.setSfuClient(void 0);
        await this.dynascaleManager.dispose();
        this.state.setCallingState(CallingState.LEFT);
        this.state.setParticipants([]);
        this.state.dispose();
        this.leaveCallHooks.forEach((hook) => hook());
        this.initialized = false;
        this.hasJoinedOnce = false;
        this.unifiedSessionId = void 0;
        this.ringingSubject.next(false);
        this.cancelAutoDrop();
        this.clientStore.unregisterCall(this);
        this.camera.dispose();
        this.microphone.dispose();
        this.screenShare.dispose();
        this.speaker.dispose();
        this.deviceSettingsAppliedOnce = false;
        const stopOnLeavePromises = [];
        if (this.camera.stopOnLeave) {
          stopOnLeavePromises.push(this.camera.disable(true));
        }
        if (this.microphone.stopOnLeave) {
          stopOnLeavePromises.push(this.microphone.disable(true));
        }
        if (this.screenShare.stopOnLeave) {
          stopOnLeavePromises.push(this.screenShare.disable(true));
        }
        await Promise.all(stopOnLeavePromises);
      });
    };
    this.updateFromRingingEvent = async (event) => {
      await this.setup();
      const { created_by, settings } = event.call;
      const creator = this.state.members.find((m2) => m2.user.id === created_by.id);
      if (!creator) {
        this.state.setMembers(event.members);
      } else {
        this.state.setMembers([creator, ...event.members]);
      }
      this.state.updateFromCallResponse(event.call);
      this.watching = true;
      this.ringingSubject.next(true);
      const calls = this.clientStore.calls.filter((c2) => c2.cid !== this.cid);
      this.clientStore.setCalls([this, ...calls]);
      await this.applyDeviceConfig(settings, false);
    };
    this.get = async (params) => {
      await this.setup();
      const response = await this.streamClient.get(this.streamClientBasePath, params);
      this.state.updateFromCallResponse(response.call);
      this.state.setMembers(response.members);
      this.state.setOwnCapabilities(response.own_capabilities);
      if (params?.ring) {
        this.ringingSubject.next(true);
      }
      if (this.streamClient._hasConnectionID()) {
        this.watching = true;
        this.clientStore.registerCall(this);
      }
      await this.applyDeviceConfig(response.call.settings, false);
      return response;
    };
    this.getOrCreate = async (data) => {
      await this.setup();
      const response = await this.streamClient.post(this.streamClientBasePath, data);
      this.state.updateFromCallResponse(response.call);
      this.state.setMembers(response.members);
      this.state.setOwnCapabilities(response.own_capabilities);
      if (data?.ring) {
        this.ringingSubject.next(true);
      }
      if (this.streamClient._hasConnectionID()) {
        this.watching = true;
        this.clientStore.registerCall(this);
      }
      await this.applyDeviceConfig(response.call.settings, false);
      return response;
    };
    this.create = async (data) => {
      return this.getOrCreate(data);
    };
    this.delete = async (data = {}) => {
      return this.streamClient.post(`${this.streamClientBasePath}/delete`, data);
    };
    this.ring = async (data = {}) => {
      return this.streamClient.post(`${this.streamClientBasePath}/ring`, data);
    };
    this.notify = async () => {
      return await this.get({ notify: true });
    };
    this.accept = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/accept`);
    };
    this.reject = async (reason = "decline") => {
      return this.streamClient.post(`${this.streamClientBasePath}/reject`, { reason });
    };
    this.join = async ({ maxJoinRetries = 3, ...data } = {}) => {
      await this.setup();
      const callingState = this.state.callingState;
      if ([CallingState.JOINED, CallingState.JOINING].includes(callingState)) {
        throw new Error(`Illegal State: call.join() shall be called only once`);
      }
      const sfuJoinFailures = /* @__PURE__ */ new Map();
      const joinData = data;
      maxJoinRetries = Math.max(maxJoinRetries, 1);
      for (let attempt = 0; attempt < maxJoinRetries; attempt++) {
        try {
          this.logger.trace(`Joining call (${attempt})`, this.cid);
          await this.doJoin(data);
          delete joinData.migrating_from;
          break;
        } catch (err) {
          this.logger.warn(`Failed to join call (${attempt})`, this.cid);
          if (err instanceof ErrorFromResponse && err.unrecoverable) {
            throw err;
          }
          const sfuId = this.credentials?.server.edge_name || "";
          const failures = (sfuJoinFailures.get(sfuId) || 0) + 1;
          sfuJoinFailures.set(sfuId, failures);
          if (failures >= 2) {
            joinData.migrating_from = sfuId;
          }
          if (attempt === maxJoinRetries - 1) {
            throw err;
          }
        }
        await sleep(retryInterval(attempt));
      }
    };
    this.doJoin = async (data) => {
      const connectStartTime = Date.now();
      const callingState = this.state.callingState;
      this.joinCallData = data;
      this.logger.debug("Starting join flow");
      this.state.setCallingState(CallingState.JOINING);
      const performingMigration = this.reconnectStrategy === WebsocketReconnectStrategy.MIGRATE;
      const performingRejoin = this.reconnectStrategy === WebsocketReconnectStrategy.REJOIN;
      const performingFastReconnect = this.reconnectStrategy === WebsocketReconnectStrategy.FAST;
      let statsOptions = this.sfuStatsReporter?.options;
      if (!this.credentials || !statsOptions || performingRejoin || performingMigration) {
        try {
          const joinResponse = await this.doJoinRequest(data);
          this.credentials = joinResponse.credentials;
          statsOptions = joinResponse.stats_options;
        } catch (error) {
          const avoidRestoreState = this.state.callingState === CallingState.OFFLINE;
          if (!avoidRestoreState) {
            this.state.setCallingState(callingState);
          }
          throw error;
        }
      }
      const previousSfuClient = this.sfuClient;
      const previousSessionId = previousSfuClient?.sessionId;
      const isWsHealthy = !!previousSfuClient?.isHealthy;
      const sfuClient = performingRejoin || performingMigration || !isWsHealthy ? new StreamSfuClient({
        tag: String(this.sfuClientTag++),
        cid: this.cid,
        dispatcher: this.dispatcher,
        credentials: this.credentials,
        streamClient: this.streamClient,
        enableTracing: statsOptions.enable_rtc_stats,
        // a new session_id is necessary for the REJOIN strategy.
        // we use the previous session_id if available
        sessionId: performingRejoin ? void 0 : previousSessionId,
        onSignalClose: (reason) => this.handleSfuSignalClose(sfuClient, reason)
      }) : previousSfuClient;
      this.sfuClient = sfuClient;
      this.unifiedSessionId ?? (this.unifiedSessionId = sfuClient.sessionId);
      this.dynascaleManager.setSfuClient(sfuClient);
      const clientDetails = await getClientDetails();
      if (previousSfuClient !== sfuClient) {
        const { dangerouslyForceCodec, fmtpLine, subscriberFmtpLine } = this.clientPublishOptions || {};
        const [subscriberSdp, publisherSdp] = await Promise.all([
          getGenericSdp("recvonly", dangerouslyForceCodec, subscriberFmtpLine),
          getGenericSdp("sendonly", dangerouslyForceCodec, fmtpLine)
        ]);
        const isReconnecting = this.reconnectStrategy !== WebsocketReconnectStrategy.UNSPECIFIED;
        const reconnectDetails = isReconnecting ? this.getReconnectDetails(data?.migrating_from, previousSessionId) : void 0;
        const preferredPublishOptions = !isReconnecting ? this.getPreferredPublishOptions() : this.currentPublishOptions || [];
        const preferredSubscribeOptions = !isReconnecting ? this.getPreferredSubscribeOptions() : [];
        try {
          const { callState, fastReconnectDeadlineSeconds, publishOptions } = await sfuClient.join({
            unifiedSessionId: this.unifiedSessionId,
            subscriberSdp,
            publisherSdp,
            clientDetails,
            fastReconnect: performingFastReconnect,
            reconnectDetails,
            preferredPublishOptions,
            preferredSubscribeOptions,
            capabilities: Array.from(this.clientCapabilities),
            source: ParticipantSource.WEBRTC_UNSPECIFIED
          });
          this.currentPublishOptions = publishOptions;
          this.fastReconnectDeadlineSeconds = fastReconnectDeadlineSeconds;
          if (callState) {
            this.state.updateFromSfuCallState(callState, sfuClient.sessionId, reconnectDetails);
          }
        } catch (error) {
          this.logger.warn("Join SFU request failed", error);
          sfuClient.close(StreamSfuClient.JOIN_FAILED, "Join request failed, connection considered unhealthy");
          this.state.setCallingState(callingState);
          throw error;
        }
      }
      if (!performingMigration) {
        this.state.setCallingState(CallingState.JOINED);
      }
      this.hasJoinedOnce = true;
      if (performingFastReconnect) {
        await this.restoreICE(sfuClient, { includeSubscriber: false });
      } else {
        const connectionConfig = toRtcConfiguration(this.credentials.ice_servers);
        this.initPublisherAndSubscriber({
          sfuClient,
          connectionConfig,
          clientDetails,
          statsOptions,
          publishOptions: this.currentPublishOptions || [],
          closePreviousInstances: !performingMigration,
          unifiedSessionId: this.unifiedSessionId
        });
      }
      if (!performingRejoin && !performingFastReconnect && !performingMigration) {
        this.sfuStatsReporter?.sendConnectionTime((Date.now() - connectStartTime) / 1e3);
      }
      if (performingRejoin && isWsHealthy) {
        const strategy = WebsocketReconnectStrategy[this.reconnectStrategy];
        await previousSfuClient?.leaveAndClose(`Closing previous WS after reconnect with strategy: ${strategy}`);
      } else if (!isWsHealthy) {
        previousSfuClient?.close(StreamSfuClient.DISPOSE_OLD_SOCKET, "Closing unhealthy WS after reconnect");
      }
      if (!this.deviceSettingsAppliedOnce && this.state.settings) {
        await this.applyDeviceConfig(this.state.settings, true);
        this.deviceSettingsAppliedOnce = true;
      }
      delete this.joinCallData?.ring;
      delete this.joinCallData?.notify;
      this.reconnectStrategy = WebsocketReconnectStrategy.UNSPECIFIED;
      this.reconnectReason = "";
      this.logger.info(`Joined call ${this.cid}`);
    };
    this.getReconnectDetails = (migratingFromSfuId, previousSessionId) => {
      const strategy = this.reconnectStrategy;
      const performingRejoin = strategy === WebsocketReconnectStrategy.REJOIN;
      const announcedTracks = this.publisher?.getAnnouncedTracksForReconnect() || [];
      return {
        strategy,
        announcedTracks,
        subscriptions: this.dynascaleManager.trackSubscriptions,
        reconnectAttempt: this.reconnectAttempts,
        fromSfuId: migratingFromSfuId || "",
        previousSessionId: performingRejoin ? previousSessionId || "" : "",
        reason: this.reconnectReason
      };
    };
    this.getPreferredPublishOptions = () => {
      const { preferredCodec, fmtpLine, preferredBitrate, maxSimulcastLayers } = this.clientPublishOptions || {};
      if (!preferredCodec && !preferredBitrate && !maxSimulcastLayers)
        return [];
      const codec = preferredCodec ? Codec.create({ name: preferredCodec.split("/").pop(), fmtp: fmtpLine }) : void 0;
      const preferredPublishOptions = [
        PublishOption.create({
          trackType: TrackType.VIDEO,
          codec,
          bitrate: preferredBitrate,
          maxSpatialLayers: maxSimulcastLayers
        })
      ];
      const screenShareSettings = this.screenShare.getSettings();
      if (screenShareSettings) {
        preferredPublishOptions.push(PublishOption.create({
          trackType: TrackType.SCREEN_SHARE,
          fps: screenShareSettings.maxFramerate,
          bitrate: screenShareSettings.maxBitrate
        }));
      }
      return preferredPublishOptions;
    };
    this.getPreferredSubscribeOptions = () => {
      const { subscriberCodec, subscriberFmtpLine } = this.clientPublishOptions || {};
      if (!subscriberCodec || !subscriberFmtpLine)
        return [];
      return [
        SubscribeOption.create({
          trackType: TrackType.VIDEO,
          codecs: [
            { name: subscriberCodec.split("/").pop(), fmtp: subscriberFmtpLine }
          ]
        })
      ];
    };
    this.restoreICE = async (nextSfuClient, opts = {}) => {
      const { includeSubscriber = true, includePublisher = true } = opts;
      if (this.subscriber) {
        this.subscriber.setSfuClient(nextSfuClient);
        if (includeSubscriber) {
          await this.subscriber.restartIce();
        }
      }
      if (this.publisher) {
        this.publisher.setSfuClient(nextSfuClient);
        if (includePublisher && this.publisher.isPublishing()) {
          await this.publisher.restartIce();
        }
      }
    };
    this.initPublisherAndSubscriber = (opts) => {
      const { sfuClient, connectionConfig, clientDetails, statsOptions, publishOptions, closePreviousInstances, unifiedSessionId } = opts;
      const { enable_rtc_stats: enableTracing } = statsOptions;
      if (closePreviousInstances && this.subscriber) {
        this.subscriber.dispose();
      }
      const basePeerConnectionOptions = {
        sfuClient,
        dispatcher: this.dispatcher,
        state: this.state,
        connectionConfig,
        tag: sfuClient.tag,
        enableTracing,
        clientPublishOptions: this.clientPublishOptions,
        onReconnectionNeeded: (kind, reason, peerType) => {
          this.reconnect(kind, reason).catch((err) => {
            const message = `[Reconnect] Error reconnecting, after a ${PeerType[peerType]} error: ${reason}`;
            this.logger.warn(message, err);
          });
        }
      };
      this.subscriber = new Subscriber2(basePeerConnectionOptions);
      const isAnonymous = this.streamClient.user?.type === "anonymous";
      if (!isAnonymous) {
        if (closePreviousInstances && this.publisher) {
          this.publisher.dispose();
        }
        this.publisher = new Publisher(basePeerConnectionOptions, publishOptions);
      }
      this.statsReporter?.stop();
      if (this.statsReportingIntervalInMs > 0) {
        this.statsReporter = createStatsReporter({
          subscriber: this.subscriber,
          publisher: this.publisher,
          state: this.state,
          datacenter: sfuClient.edgeName,
          pollingIntervalInMs: this.statsReportingIntervalInMs
        });
      }
      this.tracer.setEnabled(enableTracing);
      this.sfuStatsReporter?.flush();
      this.sfuStatsReporter?.stop();
      if (statsOptions?.reporting_interval_ms > 0) {
        this.sfuStatsReporter = new SfuStatsReporter(sfuClient, {
          clientDetails,
          options: statsOptions,
          subscriber: this.subscriber,
          publisher: this.publisher,
          microphone: this.microphone,
          camera: this.camera,
          state: this.state,
          tracer: this.tracer,
          unifiedSessionId
        });
        this.sfuStatsReporter.start();
      }
    };
    this.doJoinRequest = async (data) => {
      const location = await this.streamClient.getLocationHint();
      const request = { ...data, location };
      const joinResponse = await this.streamClient.post(`${this.streamClientBasePath}/join`, request);
      this.state.updateFromCallResponse(joinResponse.call);
      this.state.setMembers(joinResponse.members);
      this.state.setOwnCapabilities(joinResponse.own_capabilities);
      if (data?.ring) {
        this.ringingSubject.next(true);
      }
      const isReconnecting = this.reconnectStrategy !== WebsocketReconnectStrategy.UNSPECIFIED;
      if (!isReconnecting && this.ringing && !this.isCreatedByMe) {
        await this.accept();
      }
      if (this.streamClient._hasConnectionID()) {
        this.watching = true;
        this.clientStore.registerCall(this);
      }
      return joinResponse;
    };
    this.handleSfuSignalClose = (sfuClient, reason) => {
      this.logger.debug("[Reconnect] SFU signal connection closed");
      const { callingState } = this.state;
      if (
        // SFU WS closed before we finished current join,
        // no need to schedule reconnecting
        callingState === CallingState.JOINING || // we are already in the process of reconnecting,
        // no need to schedule another one
        callingState === CallingState.RECONNECTING || // SFU WS closed as a result of unsuccessful join,
        // and no further retries need to be made
        callingState === CallingState.IDLE || callingState === CallingState.LEFT
      )
        return;
      if (sfuClient.isLeaving || sfuClient.isClosingClean)
        return;
      const strategy = this.publisher?.isHealthy() && this.subscriber?.isHealthy() ? WebsocketReconnectStrategy.FAST : WebsocketReconnectStrategy.REJOIN;
      this.reconnect(strategy, reason).catch((err) => {
        this.logger.warn("[Reconnect] Error reconnecting", err);
      });
    };
    this.reconnect = async (strategy, reason) => {
      if (this.state.callingState === CallingState.RECONNECTING || this.state.callingState === CallingState.MIGRATING || this.state.callingState === CallingState.RECONNECTING_FAILED)
        return;
      return withoutConcurrency(this.reconnectConcurrencyTag, async () => {
        const reconnectStartTime = Date.now();
        this.reconnectStrategy = strategy;
        this.reconnectReason = reason;
        const markAsReconnectingFailed = async () => {
          try {
            await this.get();
          } finally {
            this.state.setCallingState(CallingState.RECONNECTING_FAILED);
          }
        };
        let attempt = 0;
        do {
          const reconnectingTime = Date.now() - reconnectStartTime;
          const shouldGiveUpReconnecting = this.disconnectionTimeoutSeconds > 0 && reconnectingTime / 1e3 > this.disconnectionTimeoutSeconds;
          if (shouldGiveUpReconnecting) {
            this.logger.warn("[Reconnect] Stopping reconnection attempts after reaching disconnection timeout");
            await markAsReconnectingFailed();
            return;
          }
          if (this.reconnectStrategy !== WebsocketReconnectStrategy.FAST) {
            this.reconnectAttempts++;
          }
          const currentStrategy = WebsocketReconnectStrategy[this.reconnectStrategy];
          try {
            await this.networkAvailableTask?.promise;
            this.logger.info(`[Reconnect] Reconnecting with strategy ${WebsocketReconnectStrategy[this.reconnectStrategy]}`);
            switch (this.reconnectStrategy) {
              case WebsocketReconnectStrategy.UNSPECIFIED:
              case WebsocketReconnectStrategy.DISCONNECT:
                this.logger.debug(`[Reconnect] No-op strategy ${currentStrategy}`);
                break;
              case WebsocketReconnectStrategy.FAST:
                await this.reconnectFast();
                break;
              case WebsocketReconnectStrategy.REJOIN:
                await this.reconnectRejoin();
                break;
              case WebsocketReconnectStrategy.MIGRATE:
                await this.reconnectMigrate();
                break;
              default:
                ensureExhausted(this.reconnectStrategy, "Unknown reconnection strategy");
                break;
            }
            break;
          } catch (error) {
            if (this.state.callingState === CallingState.OFFLINE) {
              this.logger.debug(`[Reconnect] Can't reconnect while offline, stopping reconnection attempts`);
              break;
            }
            if (error instanceof ErrorFromResponse && error.unrecoverable) {
              this.logger.warn(`[Reconnect] Can't reconnect due to coordinator unrecoverable error`, error);
              await markAsReconnectingFailed();
              return;
            }
            await sleep(500);
            const wasMigrating = this.reconnectStrategy === WebsocketReconnectStrategy.MIGRATE;
            const mustPerformRejoin = (Date.now() - reconnectStartTime) / 1e3 > this.fastReconnectDeadlineSeconds;
            const shouldRejoin = mustPerformRejoin || // if we are past the fast reconnect deadline
            wasMigrating || // if we were migrating, but the migration failed
            attempt >= 3 || // after 3 failed attempts
            !(this.publisher?.isHealthy() ?? true) || // if the publisher is not healthy
            !(this.subscriber?.isHealthy() ?? true);
            attempt++;
            const nextStrategy = shouldRejoin ? WebsocketReconnectStrategy.REJOIN : WebsocketReconnectStrategy.FAST;
            this.reconnectStrategy = nextStrategy;
            this.logger.info(`[Reconnect] ${currentStrategy} (${this.reconnectAttempts}) failed. Attempting with ${WebsocketReconnectStrategy[nextStrategy]}`, error);
          }
        } while (this.state.callingState !== CallingState.JOINED && this.state.callingState !== CallingState.RECONNECTING_FAILED && this.state.callingState !== CallingState.LEFT);
        this.logger.info("[Reconnect] Reconnection flow finished");
      });
    };
    this.reconnectFast = async () => {
      const reconnectStartTime = Date.now();
      this.reconnectStrategy = WebsocketReconnectStrategy.FAST;
      this.state.setCallingState(CallingState.RECONNECTING);
      await this.doJoin(this.joinCallData);
      await this.get();
      this.sfuStatsReporter?.sendReconnectionTime(WebsocketReconnectStrategy.FAST, (Date.now() - reconnectStartTime) / 1e3);
    };
    this.reconnectRejoin = async () => {
      const reconnectStartTime = Date.now();
      this.reconnectStrategy = WebsocketReconnectStrategy.REJOIN;
      this.state.setCallingState(CallingState.RECONNECTING);
      await this.doJoin(this.joinCallData);
      await this.restorePublishedTracks();
      this.restoreSubscribedTracks();
      this.sfuStatsReporter?.sendReconnectionTime(WebsocketReconnectStrategy.REJOIN, (Date.now() - reconnectStartTime) / 1e3);
    };
    this.reconnectMigrate = async () => {
      const reconnectStartTime = Date.now();
      const currentSfuClient = this.sfuClient;
      if (!currentSfuClient) {
        throw new Error("Cannot migrate without an active SFU client");
      }
      this.reconnectStrategy = WebsocketReconnectStrategy.MIGRATE;
      this.state.setCallingState(CallingState.MIGRATING);
      const currentSubscriber = this.subscriber;
      const currentPublisher = this.publisher;
      currentSubscriber?.detachEventHandlers();
      currentPublisher?.detachEventHandlers();
      const migrationTask = makeSafePromise(currentSfuClient.enterMigration());
      try {
        const currentSfu = currentSfuClient.edgeName;
        await this.doJoin({ ...this.joinCallData, migrating_from: currentSfu });
      } finally {
        delete this.joinCallData?.migrating_from;
      }
      await this.restorePublishedTracks();
      this.restoreSubscribedTracks();
      try {
        await migrationTask();
        this.state.setCallingState(CallingState.JOINED);
      } finally {
        currentSubscriber?.dispose();
        currentPublisher?.dispose();
        currentSfuClient.close(StreamSfuClient.NORMAL_CLOSURE, "Migrating away");
      }
      this.sfuStatsReporter?.sendReconnectionTime(WebsocketReconnectStrategy.MIGRATE, (Date.now() - reconnectStartTime) / 1e3);
    };
    this.registerReconnectHandlers = () => {
      const unregisterGoAway = this.on("goAway", () => {
        this.reconnect(WebsocketReconnectStrategy.MIGRATE, "goAway").catch((err) => this.logger.warn("[Reconnect] Error reconnecting", err));
      });
      const unregisterOnError = this.on("error", (e2) => {
        const { reconnectStrategy: strategy, error } = e2;
        if (strategy === WebsocketReconnectStrategy.UNSPECIFIED)
          return;
        if (strategy === WebsocketReconnectStrategy.DISCONNECT) {
          this.leave({ message: "SFU instructed to disconnect" }).catch((err) => {
            this.logger.warn(`Can't leave call after disconnect request`, err);
          });
        } else {
          this.reconnect(strategy, error?.message || "SFU Error").catch((err) => {
            this.logger.warn("[Reconnect] Error reconnecting", err);
          });
        }
      });
      const unregisterNetworkChanged = this.streamClient.on("network.changed", (e2) => {
        this.tracer.trace("network.changed", e2);
        if (!e2.online) {
          this.logger.debug("[Reconnect] Going offline");
          if (!this.hasJoinedOnce)
            return;
          this.lastOfflineTimestamp = Date.now();
          const networkAvailableTask = promiseWithResolvers();
          networkAvailableTask.promise.then(() => {
            let strategy = WebsocketReconnectStrategy.FAST;
            if (this.lastOfflineTimestamp) {
              const offline = (Date.now() - this.lastOfflineTimestamp) / 1e3;
              if (offline > this.fastReconnectDeadlineSeconds) {
                strategy = WebsocketReconnectStrategy.REJOIN;
              }
            }
            this.reconnect(strategy, "Going online").catch((err) => {
              this.logger.warn("[Reconnect] Error reconnecting after going online", err);
            });
          });
          this.networkAvailableTask = networkAvailableTask;
          this.sfuStatsReporter?.stop();
          this.state.setCallingState(CallingState.OFFLINE);
        } else {
          this.logger.debug("[Reconnect] Going online");
          this.sfuClient?.close(StreamSfuClient.DISPOSE_OLD_SOCKET, "Closing WS to reconnect after going online");
          this.networkAvailableTask?.resolve();
          this.networkAvailableTask = void 0;
          this.sfuStatsReporter?.start();
        }
      });
      this.leaveCallHooks.add(unregisterGoAway).add(unregisterOnError).add(unregisterNetworkChanged);
    };
    this.restorePublishedTracks = async () => {
      for (const trackType of this.trackPublishOrder) {
        let mediaStream;
        switch (trackType) {
          case TrackType.AUDIO:
            mediaStream = this.microphone.state.mediaStream;
            break;
          case TrackType.VIDEO:
            mediaStream = this.camera.state.mediaStream;
            break;
          case TrackType.SCREEN_SHARE:
            mediaStream = this.screenShare.state.mediaStream;
            break;
          // screen share audio can't exist without a screen share, so we handle it there
          case TrackType.SCREEN_SHARE_AUDIO:
          case TrackType.UNSPECIFIED:
            break;
          default:
            ensureExhausted(trackType, "Unknown track type");
            break;
        }
        if (mediaStream)
          await this.publish(mediaStream, trackType);
      }
    };
    this.restoreSubscribedTracks = () => {
      const { remoteParticipants } = this.state;
      if (remoteParticipants.length <= 0)
        return;
      this.dynascaleManager.applyTrackSubscriptions(void 0);
    };
    this.publishVideoStream = async (videoStream) => {
      await this.publish(videoStream, TrackType.VIDEO);
    };
    this.publishAudioStream = async (audioStream) => {
      await this.publish(audioStream, TrackType.AUDIO);
    };
    this.publishScreenShareStream = async (screenShareStream) => {
      await this.publish(screenShareStream, TrackType.SCREEN_SHARE);
    };
    this.publish = async (mediaStream, trackType, options) => {
      if (!this.sfuClient)
        throw new Error(`Call is not joined yet`);
      await this.sfuClient.joinTask;
      if (!this.permissionsContext.canPublish(trackType)) {
        throw new Error(`No permission to publish ${TrackType[trackType]}`);
      }
      if (!this.publisher)
        throw new Error("Publisher is not initialized");
      const [track] = isAudioTrackType(trackType) ? mediaStream.getAudioTracks() : mediaStream.getVideoTracks();
      if (!track) {
        throw new Error(`There is no ${TrackType[trackType]} track in the stream`);
      }
      if (track.readyState === "ended") {
        throw new Error(`Can't publish ended tracks.`);
      }
      pushToIfMissing(this.trackPublishOrder, trackType);
      await this.publisher.publish(track, trackType, options);
      const trackTypes = [trackType];
      if (trackType === TrackType.SCREEN_SHARE) {
        const [audioTrack] = mediaStream.getAudioTracks();
        if (audioTrack) {
          const screenShareAudio = TrackType.SCREEN_SHARE_AUDIO;
          pushToIfMissing(this.trackPublishOrder, screenShareAudio);
          await this.publisher.publish(audioTrack, screenShareAudio, options);
          trackTypes.push(screenShareAudio);
        }
      }
      if (track.kind === "video") {
        this.sfuStatsReporter?.scheduleOne(3e3);
      }
      await this.updateLocalStreamState(mediaStream, ...trackTypes);
    };
    this.stopPublish = async (...trackTypes) => {
      if (!this.sfuClient || !this.publisher)
        return;
      this.publisher.stopTracks(...trackTypes);
      await this.updateLocalStreamState(void 0, ...trackTypes);
    };
    this.updateLocalStreamState = async (mediaStream, ...trackTypes) => {
      if (!this.sfuClient || !this.sfuClient.sessionId)
        return;
      await this.notifyTrackMuteState(!mediaStream, ...trackTypes);
      const { sessionId } = this.sfuClient;
      for (const trackType of trackTypes) {
        const streamStateProp = trackTypeToParticipantStreamKey(trackType);
        if (!streamStateProp)
          continue;
        this.state.updateParticipant(sessionId, (p2) => ({
          publishedTracks: mediaStream ? pushToIfMissing([...p2.publishedTracks], trackType) : p2.publishedTracks.filter((t2) => t2 !== trackType),
          [streamStateProp]: mediaStream
        }));
      }
    };
    this.updatePublishOptions = (options) => {
      this.logger.warn("[call.updatePublishOptions]: You are manually overriding the publish options for this call. This is not recommended, and it can cause call stability/compatibility issues. Use with caution.");
      if (this.state.callingState === CallingState.JOINED) {
        this.logger.warn("Updating publish options after joining the call does not have an effect");
      }
      this.clientPublishOptions = { ...this.clientPublishOptions, ...options };
    };
    this.notifyNoiseCancellationStarting = async () => {
      return this.sfuClient?.startNoiseCancellation().catch((err) => {
        this.logger.warn("Failed to notify start of noise cancellation", err);
      });
    };
    this.notifyNoiseCancellationStopped = async () => {
      return this.sfuClient?.stopNoiseCancellation().catch((err) => {
        this.logger.warn("Failed to notify stop of noise cancellation", err);
      });
    };
    this.notifyTrackMuteState = async (muted, ...trackTypes) => {
      const key = `muteState.${this.cid}.${trackTypes.join("-")}`;
      await withoutConcurrency(key, async () => {
        if (!this.sfuClient)
          return;
        await this.sfuClient.updateMuteStates(trackTypes.map((trackType) => ({ trackType, muted })));
      });
    };
    this.startReportingStatsFor = (sessionId) => {
      return this.statsReporter?.startReportingStatsFor(sessionId);
    };
    this.stopReportingStatsFor = (sessionId) => {
      return this.statsReporter?.stopReportingStatsFor(sessionId);
    };
    this.setStatsReportingIntervalInMs = (intervalInMs) => {
      this.statsReportingIntervalInMs = intervalInMs;
    };
    this.resetReaction = (sessionId) => {
      this.state.updateParticipant(sessionId, {
        reaction: void 0
      });
    };
    this.setSortParticipantsBy = (criteria) => {
      return this.state.setSortParticipantsBy(criteria);
    };
    this.sendReaction = async (reaction) => {
      return this.streamClient.post(`${this.streamClientBasePath}/reaction`, reaction);
    };
    this.blockUser = async (userId) => {
      return this.streamClient.post(`${this.streamClientBasePath}/block`, {
        user_id: userId
      });
    };
    this.unblockUser = async (userId) => {
      return this.streamClient.post(`${this.streamClientBasePath}/unblock`, {
        user_id: userId
      });
    };
    this.kickUser = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/kick`, data);
    };
    this.muteSelf = (type2) => {
      const myUserId = this.currentUserId;
      if (myUserId) {
        return this.muteUser(myUserId, type2);
      }
    };
    this.muteOthers = (type2) => {
      const trackType = muteTypeToTrackType(type2);
      if (!trackType)
        return;
      const userIdsToMute = [];
      for (const participant of this.state.remoteParticipants) {
        if (participant.publishedTracks.includes(trackType)) {
          userIdsToMute.push(participant.userId);
        }
      }
      if (userIdsToMute.length > 0) {
        return this.muteUser(userIdsToMute, type2);
      }
    };
    this.muteUser = (userId, type2) => {
      return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {
        user_ids: Array.isArray(userId) ? userId : [userId],
        [type2]: true
      });
    };
    this.muteAllUsers = (type2) => {
      return this.streamClient.post(`${this.streamClientBasePath}/mute_users`, {
        mute_all_users: true,
        [type2]: true
      });
    };
    this.startRecording = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_recording`, request ? request : {});
    };
    this.stopRecording = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_recording`, {});
    };
    this.startTranscription = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_transcription`, request);
    };
    this.stopTranscription = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_transcription`);
    };
    this.startClosedCaptions = async (options) => {
      const trx = this.state.setCaptioning(true);
      try {
        return await this.streamClient.post(`${this.streamClientBasePath}/start_closed_captions`, options);
      } catch (err) {
        trx.rollback();
        throw err;
      }
    };
    this.stopClosedCaptions = async (options) => {
      const trx = this.state.setCaptioning(false);
      try {
        return await this.streamClient.post(`${this.streamClientBasePath}/stop_closed_captions`, options);
      } catch (err) {
        trx.rollback();
        throw err;
      }
    };
    this.updateClosedCaptionSettings = (config2) => {
      this.state.updateClosedCaptionSettings(config2);
    };
    this.requestPermissions = async (data) => {
      const { permissions } = data;
      const canRequestPermissions = permissions.every((permission) => this.permissionsContext.canRequest(permission));
      if (!canRequestPermissions) {
        throw new Error(`You are not allowed to request permissions: ${permissions.join(", ")}`);
      }
      return this.streamClient.post(`${this.streamClientBasePath}/request_permission`, data);
    };
    this.grantPermissions = async (userId, permissions) => {
      return this.updateUserPermissions({
        user_id: userId,
        grant_permissions: permissions
      });
    };
    this.revokePermissions = async (userId, permissions) => {
      return this.updateUserPermissions({
        user_id: userId,
        revoke_permissions: permissions
      });
    };
    this.updateUserPermissions = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/user_permissions`, data);
    };
    this.goLive = async (data = {}, params) => {
      return this.streamClient.post(`${this.streamClientBasePath}/go_live`, data, params);
    };
    this.stopLive = async (data = {}) => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_live`, data);
    };
    this.startHLS = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_broadcasting`, {});
    };
    this.stopHLS = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_broadcasting`, {});
    };
    this.startRTMPBroadcasts = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/rtmp_broadcasts`, data);
    };
    this.stopAllRTMPBroadcasts = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/rtmp_broadcasts/stop`);
    };
    this.stopRTMPBroadcast = async (name2) => {
      return this.streamClient.post(`${this.streamClientBasePath}/rtmp_broadcasts/${name2}/stop`);
    };
    this.startFrameRecording = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/start_frame_recording`, data);
    };
    this.stopFrameRecording = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/stop_frame_recording`);
    };
    this.update = async (updates) => {
      const response = await this.streamClient.patch(`${this.streamClientBasePath}`, updates);
      const { call, members: members2, own_capabilities } = response;
      this.state.updateFromCallResponse(call);
      this.state.setMembers(members2);
      this.state.setOwnCapabilities(own_capabilities);
      return response;
    };
    this.endCall = async () => {
      return this.streamClient.post(`${this.streamClientBasePath}/mark_ended`);
    };
    this.pin = (sessionId) => {
      this.state.updateParticipant(sessionId, {
        pin: {
          isLocalPin: true,
          pinnedAt: Date.now()
        }
      });
    };
    this.unpin = (sessionId) => {
      this.state.updateParticipant(sessionId, {
        pin: void 0
      });
    };
    this.pinForEveryone = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/pin`, request);
    };
    this.unpinForEveryone = async (request) => {
      return this.streamClient.post(`${this.streamClientBasePath}/unpin`, request);
    };
    this.queryMembers = (request) => {
      return this.streamClient.post("/call/members", {
        ...request || {},
        id: this.id,
        type: this.type
      });
    };
    this.updateCallMembers = async (data) => {
      return this.streamClient.post(`${this.streamClientBasePath}/members`, data);
    };
    this.scheduleAutoDrop = () => {
      this.cancelAutoDrop();
      const settings = this.state.settings;
      if (!settings)
        return;
      if (this.state.callingState !== CallingState.RINGING)
        return;
      const timeoutInMs = this.isCreatedByMe ? settings.ring.auto_cancel_timeout_ms : settings.ring.incoming_call_timeout_ms;
      if (timeoutInMs <= 0)
        return;
      this.dropTimeout = setTimeout(() => {
        if (this.state.callingState !== CallingState.RINGING)
          return;
        this.leave({
          reject: true,
          reason: "timeout",
          message: `ringing timeout - ${this.isCreatedByMe ? "no one accepted" : `user didn't interact with incoming call screen`}`
        }).catch((err) => {
          this.logger.error("Failed to drop call", err);
        });
      }, timeoutInMs);
    };
    this.cancelAutoDrop = () => {
      clearTimeout(this.dropTimeout);
      this.dropTimeout = void 0;
    };
    this.queryRecordings = async (callSessionId) => {
      let endpoint = this.streamClientBasePath;
      if (callSessionId) {
        endpoint = `${endpoint}/${callSessionId}`;
      }
      return this.streamClient.get(`${endpoint}/recordings`);
    };
    this.queryTranscriptions = async () => {
      return this.streamClient.get(`${this.streamClientBasePath}/transcriptions`);
    };
    this.getCallStats = async (callSessionID) => {
      const endpoint = `${this.streamClientBasePath}/stats/${callSessionID}`;
      return this.streamClient.get(endpoint);
    };
    this.getCallReport = async (callSessionID = "") => {
      const endpoint = `${this.streamClientBasePath}/report`;
      const params = callSessionID !== "" ? { session_id: callSessionID } : {};
      return this.streamClient.get(endpoint, params);
    };
    this.getCallParticipantsStats = async (opts) => {
      const { sessionId = this.state.session?.id, userId = this.currentUserId, userSessionId = this.unifiedSessionId, kind = "details" } = opts;
      if (!sessionId)
        return;
      const base = `${this.streamClient.baseURL}/call_stats/${this.type}/${this.id}/${sessionId}`;
      if (!userId || !userSessionId) {
        return this.streamClient.get(`${base}/participants`);
      }
      if (kind === "details") {
        return this.streamClient.get(`${base}/participant/${userId}/${userSessionId}/details`);
      }
      return this.streamClient.get(`${base}/participants/${userId}/${userSessionId}/timeline`);
    };
    this.submitFeedback = async (rating, { reason, custom } = {}) => {
      const { sdkName, sdkVersion, ...platform } = getSdkSignature(await getClientDetails());
      return this.streamClient.post(`${this.streamClientBasePath}/feedback`, {
        rating,
        reason,
        user_session_id: this.sfuClient?.sessionId,
        sdk: sdkName,
        sdk_version: sdkVersion,
        custom: {
          ...custom,
          "x-stream-platform-data": platform
        }
      });
    };
    this.sendCustomEvent = async (payload) => {
      return this.streamClient.post(`${this.streamClientBasePath}/event`, { custom: payload });
    };
    this.applyDeviceConfig = async (settings, publish2) => {
      await this.camera.apply(settings.video, publish2).catch((err) => {
        this.logger.warn("Camera init failed", err);
      });
      await this.microphone.apply(settings.audio, publish2).catch((err) => {
        this.logger.warn("Mic init failed", err);
      });
    };
    this.trackElementVisibility = (element, sessionId, trackType) => {
      return this.dynascaleManager.trackElementVisibility(element, sessionId, trackType);
    };
    this.setViewport = (element) => {
      return this.dynascaleManager.setViewport(element);
    };
    this.bindVideoElement = (videoElement, sessionId, trackType) => {
      const unbind = this.dynascaleManager.bindVideoElement(videoElement, sessionId, trackType);
      if (!unbind)
        return;
      this.leaveCallHooks.add(unbind);
      return () => {
        this.leaveCallHooks.delete(unbind);
        unbind();
      };
    };
    this.bindAudioElement = (audioElement, sessionId, trackType = "audioTrack") => {
      const unbind = this.dynascaleManager.bindAudioElement(audioElement, sessionId, trackType);
      if (!unbind)
        return;
      this.leaveCallHooks.add(unbind);
      return () => {
        this.leaveCallHooks.delete(unbind);
        unbind();
      };
    };
    this.bindCallThumbnailElement = (imageElement, opts = {}) => {
      const handleError = () => {
        imageElement.src = opts.fallbackImageSource || "https://getstream.io/random_svg/?name=x&id=x";
      };
      const unsubscribe = createSubscription(this.state.thumbnails$, (thumbnails) => {
        if (!thumbnails)
          return;
        imageElement.addEventListener("error", handleError);
        const thumbnailUrl = new URL(thumbnails.image_url);
        thumbnailUrl.searchParams.set("w", String(imageElement.clientWidth));
        thumbnailUrl.searchParams.set("h", String(imageElement.clientHeight));
        imageElement.src = thumbnailUrl.toString();
      });
      return () => {
        unsubscribe();
        imageElement.removeEventListener("error", handleError);
      };
    };
    this.setPreferredIncomingVideoResolution = (resolution, sessionIds) => {
      this.dynascaleManager.setVideoTrackSubscriptionOverrides(resolution ? {
        enabled: true,
        dimension: resolution
      } : void 0, sessionIds);
      this.dynascaleManager.applyTrackSubscriptions();
    };
    this.setIncomingVideoEnabled = (enabled) => {
      this.dynascaleManager.setVideoTrackSubscriptionOverrides(enabled ? void 0 : { enabled: false });
      this.dynascaleManager.applyTrackSubscriptions();
    };
    this.setDisconnectionTimeout = (timeoutSeconds) => {
      this.disconnectionTimeoutSeconds = timeoutSeconds;
    };
    this.enableClientCapabilities = (...capabilities) => {
      for (const capability of capabilities) {
        this.clientCapabilities.add(capability);
      }
    };
    this.disableClientCapabilities = (...capabilities) => {
      for (const capability of capabilities) {
        this.clientCapabilities.delete(capability);
      }
    };
    this.type = type;
    this.id = id;
    this.cid = `${type}:${id}`;
    this.ringingSubject = new BehaviorSubject(ringing);
    this.watching = watching;
    this.streamClient = streamClient;
    this.clientStore = clientStore;
    this.streamClientBasePath = `/call/${this.type}/${this.id}`;
    this.logger = videoLoggerSystem.getLogger("Call");
    const callTypeConfig = CallTypes.get(type);
    const participantSorter = sortParticipantsBy || callTypeConfig.options.sortParticipantsBy;
    if (participantSorter) {
      this.state.setSortParticipantsBy(participantSorter);
    }
    this.state.setMembers(members || []);
    this.state.setOwnCapabilities(ownCapabilities || []);
    this.state.setCallingState(ringing ? CallingState.RINGING : CallingState.IDLE);
    this.camera = new CameraManager(this);
    this.microphone = new MicrophoneManager(this);
    this.speaker = new SpeakerManager(this);
    this.screenShare = new ScreenShareManager(this);
    this.dynascaleManager = new DynascaleManager(this.state, this.speaker);
  }
  /**
   * A flag indicating whether the call is "ringing" type of call.
   */
  get ringing() {
    return getCurrentValue(this.ringingSubject);
  }
  /**
   * Retrieves the current user ID.
   */
  get currentUserId() {
    return this.clientStore.connectedUser?.id;
  }
  /**
   * A flag indicating whether the call was created by the current user.
   */
  get isCreatedByMe() {
    return this.state.createdBy?.id === this.currentUserId;
  }
};
var https = null;
var APIErrorCodes = {
  [-1]: "InternalSystemError",
  2: "AccessKeyError",
  3: "AuthenticationFailedError",
  4: "InputError",
  5: "AuthenticationError",
  6: "DuplicateUsernameError",
  9: "RateLimitError",
  16: "DoesNotExistError",
  17: "NotAllowedError",
  18: "EventNotSupportedError",
  19: "ChannelFeatureNotSupportedError",
  20: "MessageTooLongError",
  21: "MultipleNestingLevelError",
  22: "PayloadTooBigError",
  23: "RequestTimeoutError",
  24: "MaxHeaderSizeExceededError",
  40: "AuthErrorTokenExpired",
  41: "AuthErrorTokenNotValidYet",
  42: "AuthErrorTokenUsedBeforeIssuedAt",
  43: "AuthErrorTokenSignatureInvalid",
  44: "CustomCommandEndpointMissingError",
  45: "CustomCommandEndpointCallError",
  46: "ConnectionIDNotFoundError",
  60: "CoolDownError",
  69: "ErrWrongRegion",
  70: "ErrQueryChannelPermissions",
  71: "ErrTooManyConnections",
  73: "MessageModerationFailedError",
  99: "AppSuspendedError"
};
var StableWSConnection = class {
  constructor(client) {
    this._log = (msg, extra = {}, level = "info") => {
      this.client.logger[level](`connection:${msg}`, extra);
    };
    this.setClient = (client2) => {
      this.client = client2;
    };
    this._buildUrl = () => {
      const params = new URLSearchParams();
      params.set("api_key", this.client.key);
      params.set("stream-auth-type", this.client.getAuthType());
      params.set("X-Stream-Client", this.client.getUserAgent());
      return `${this.client.wsBaseURL}/connect?${params.toString()}`;
    };
    this.onlineStatusChanged = (event) => {
      if (event.type === "offline") {
        this._log("onlineStatusChanged() - Status changing to offline");
        this._setHealth(false, true);
      } else if (event.type === "online") {
        this._log(`onlineStatusChanged() - Status changing to online. isHealthy: ${this.isHealthy}`);
        if (!this.isHealthy) {
          this._reconnect({ interval: 10 });
        }
      }
    };
    this.onopen = (wsID) => {
      if (this.wsID !== wsID)
        return;
      const user = this.client.user;
      if (!user) {
        this.client.logger.error(`User not set, can't connect to WS`);
        return;
      }
      const token = this.client._getToken();
      if (!token) {
        this.client.logger.error(`Token not set, can't connect authenticate`);
        return;
      }
      const authMessage = JSON.stringify({
        token,
        user_details: {
          id: user.id,
          name: user.name,
          image: user.image,
          custom: user.custom
        }
      });
      this._log(`onopen() - Sending auth message ${authMessage}`, {}, "trace");
      this.ws?.send(authMessage);
      this._log("onopen() - onopen callback", { wsID });
    };
    this.onmessage = (wsID, event) => {
      if (this.wsID !== wsID)
        return;
      const data = typeof event.data === "string" ? JSON.parse(event.data) : null;
      if (!this.isConnectionOpenResolved && data && data.type === "connection.error") {
        this.isConnectionOpenResolved = true;
        if (data.error) {
          this.rejectConnectionOpen?.(this._errorFromWSEvent(data, false));
          return;
        }
      }
      this.lastEvent = /* @__PURE__ */ new Date();
      if (data && (data.type === "health.check" || data.type === "connection.ok")) {
        this.scheduleNextPing();
      }
      if (data && data.type === "connection.ok") {
        this.resolveConnectionOpen?.(data);
        this._setHealth(true);
      }
      if (data && data.type === "connection.error" && data.error) {
        const { code } = data.error;
        this.isHealthy = false;
        this.isConnecting = false;
        this.consecutiveFailures += 1;
        if (code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {
          clearTimeout(this.connectionCheckTimeoutRef);
          this._log("connect() - WS failure due to expired token, so going to try to reload token and reconnect");
          this._reconnect({ refreshToken: true });
        }
      }
      if (data) {
        data.received_at = /* @__PURE__ */ new Date();
        this.client.dispatchEvent(data);
      }
      this.scheduleConnectionCheck();
    };
    this.onclose = (wsID, event) => {
      if (this.wsID !== wsID)
        return;
      this._log("onclose() - onclose callback - " + event.code, { event, wsID });
      if (event.code === KnownCodes.WS_CLOSED_SUCCESS) {
        const error = new Error(`WS connection reject with error ${event.reason}`);
        error.reason = event.reason;
        error.code = event.code;
        error.wasClean = event.wasClean;
        error.target = event.target;
        this.rejectConnectionOpen?.(error);
        this._log(`onclose() - WS connection reject with error ${event.reason}`, {
          event
        });
      } else {
        this.consecutiveFailures += 1;
        this.totalFailures += 1;
        this._setHealth(false);
        this.isConnecting = false;
        this.rejectConnectionOpen?.(this._errorFromWSEvent(event));
        this._log(`onclose() - WS connection closed. Calling reconnect ...`, {
          event
        });
        this._reconnect();
      }
    };
    this.onerror = (wsID, event) => {
      if (this.wsID !== wsID)
        return;
      this.consecutiveFailures += 1;
      this.totalFailures += 1;
      this._setHealth(false);
      this.isConnecting = false;
      this._log(`onerror() - WS connection resulted into error`, { event });
      this._reconnect();
    };
    this._setHealth = (healthy, dispatchImmediately = false) => {
      if (healthy === this.isHealthy)
        return;
      this.isHealthy = healthy;
      if (this.isHealthy || dispatchImmediately) {
        this.client.dispatchEvent({
          type: "connection.changed",
          online: this.isHealthy
        });
        return;
      }
      setTimeout(() => {
        if (this.isHealthy)
          return;
        this.client.dispatchEvent({
          type: "connection.changed",
          online: this.isHealthy
        });
      }, 5e3);
    };
    this._errorFromWSEvent = (event, isWSFailure = true) => {
      let code;
      let statusCode;
      let message;
      if (isCloseEvent(event)) {
        code = event.code;
        message = event.reason;
        statusCode = 0;
      } else {
        const { error: error2 } = event;
        code = error2.code;
        message = error2.message;
        statusCode = error2.StatusCode;
      }
      const msg = `WS failed with code: ${code}: ${APIErrorCodes[code] || code} and reason: ${message}`;
      this._log(msg, { event }, "warn");
      const error = new Error(msg);
      error.code = code;
      error.StatusCode = statusCode;
      error.isWSFailure = isWSFailure;
      return error;
    };
    this._setupConnectionPromise = () => {
      this.isConnectionOpenResolved = false;
      this.connectionOpenSafe = makeSafePromise(new Promise((resolve, reject) => {
        this.resolveConnectionOpen = resolve;
        this.rejectConnectionOpen = reject;
      }));
    };
    this.scheduleNextPing = () => {
      const timers = getTimers();
      if (this.healthCheckTimeoutRef) {
        timers.clearTimeout(this.healthCheckTimeoutRef);
      }
      this.healthCheckTimeoutRef = timers.setTimeout(() => {
        const data = [{ type: "health.check", client_id: this.client.clientID }];
        try {
          this.ws?.send(JSON.stringify(data));
        } catch {
        }
      }, this.pingInterval);
    };
    this.scheduleConnectionCheck = () => {
      clearTimeout(this.connectionCheckTimeoutRef);
      this.connectionCheckTimeoutRef = setTimeout(() => {
        const now = /* @__PURE__ */ new Date();
        if (this.lastEvent && now.getTime() - this.lastEvent.getTime() > this.connectionCheckTimeout) {
          this._log("scheduleConnectionCheck - going to reconnect");
          this._setHealth(false);
          this._reconnect();
        }
      }, this.connectionCheckTimeout);
    };
    this.client = client;
    this.consecutiveFailures = 0;
    this.totalFailures = 0;
    this.isConnecting = false;
    this.isDisconnected = false;
    this.isConnectionOpenResolved = false;
    this.isHealthy = false;
    this.wsID = 1;
    this.lastEvent = null;
    this.pingInterval = 25 * 1e3;
    this.connectionCheckTimeout = this.pingInterval + 10 * 1e3;
    addConnectionEventListeners(this.onlineStatusChanged);
  }
  /**
   * connect - Connect to the WS URL
   * the default 15s timeout allows between 2~3 tries
   * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received
   */
  async connect(timeout2 = 15e3) {
    if (this.isConnecting) {
      throw Error(`You've called connect twice, can only attempt 1 connection at the time`);
    }
    this.isDisconnected = false;
    try {
      const healthCheck = await this._connect();
      this.consecutiveFailures = 0;
      this._log(`connect() - Established ws connection with healthcheck: ${healthCheck}`);
    } catch (error) {
      this.isHealthy = false;
      this.consecutiveFailures += 1;
      if (
        // @ts-expect-error type issue
        error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()
      ) {
        this._log("connect() - WS failure due to expired token, so going to try to reload token and reconnect");
        this._reconnect({ refreshToken: true });
      } else {
        if (!error.isWSFailure) {
          throw new Error(JSON.stringify({
            // @ts-expect-error type issue
            code: error.code,
            // @ts-expect-error type issue
            StatusCode: error.StatusCode,
            // @ts-expect-error type issue
            message: error.message,
            // @ts-expect-error type issue
            isWSFailure: error.isWSFailure
          }));
        }
      }
    }
    return await this._waitForHealthy(timeout2);
  }
  /**
   * _waitForHealthy polls the promise connection to see if its resolved until it times out
   * the default 15s timeout allows between 2~3 tries
   * @param timeout duration(ms)
   */
  async _waitForHealthy(timeout2 = 15e3) {
    return Promise.race([
      (async () => {
        const interval2 = 50;
        for (let i2 = 0; i2 <= timeout2; i2 += interval2) {
          try {
            return await this.connectionOpen;
          } catch (error) {
            if (i2 === timeout2) {
              throw new Error(JSON.stringify({
                code: error.code,
                StatusCode: error.StatusCode,
                message: error.message,
                isWSFailure: error.isWSFailure
              }));
            }
            await sleep(interval2);
          }
        }
      })(),
      (async () => {
        await sleep(timeout2);
        this.isConnecting = false;
        throw new Error(JSON.stringify({
          code: "",
          StatusCode: "",
          message: "initial WS connection could not be established",
          isWSFailure: true
        }));
      })()
    ]);
  }
  /**
   * disconnect - Disconnect the connection and doesn't recover...
   *
   */
  disconnect(timeout2) {
    this._log(`disconnect() - Closing the websocket connection for wsID ${this.wsID}`);
    this.wsID += 1;
    this.isConnecting = false;
    this.isDisconnected = true;
    if (this.healthCheckTimeoutRef) {
      getTimers().clearInterval(this.healthCheckTimeoutRef);
    }
    if (this.connectionCheckTimeoutRef) {
      clearInterval(this.connectionCheckTimeoutRef);
    }
    removeConnectionEventListeners(this.onlineStatusChanged);
    this.isHealthy = false;
    let isClosedPromise;
    const { ws: ws2 } = this;
    if (ws2 && ws2.close && ws2.readyState === ws2.OPEN) {
      isClosedPromise = new Promise((resolve) => {
        const onclose = (event) => {
          this._log(`disconnect() - resolving isClosedPromise ${event ? "with" : "without"} close frame`, { event });
          resolve();
        };
        ws2.onclose = onclose;
        setTimeout(onclose, timeout2 != null ? timeout2 : 1e3);
      });
      this._log(`disconnect() - Manually closed connection by calling client.disconnect()`);
      ws2.close(KnownCodes.WS_CLOSED_SUCCESS, "Manually closed connection by calling client.disconnect()");
    } else {
      this._log(`disconnect() - ws connection doesn't exist or it is already closed.`);
      isClosedPromise = Promise.resolve();
    }
    delete this.ws;
    return isClosedPromise;
  }
  /**
   * _connect - Connect to the WS endpoint
   *
   * @return {ConnectAPIResponse<ConnectedEvent>} Promise that completes once the first health check message is received
   */
  async _connect() {
    if (this.isConnecting)
      return;
    this.isConnecting = true;
    let isTokenReady = false;
    try {
      this._log(`_connect() - waiting for token`);
      await this.client.tokenManager.tokenReady();
      isTokenReady = true;
    } catch {
    }
    try {
      if (!isTokenReady) {
        this._log(`_connect() - tokenProvider failed before, so going to retry`);
        await this.client.tokenManager.loadToken();
      }
      if (!this.client.isConnectionIsPromisePending) {
        this.client._setupConnectionIdPromise();
      }
      this._setupConnectionPromise();
      const wsURL = this._buildUrl();
      this._log(`_connect() - Connecting to ${wsURL}`);
      const WS = this.client.options.WebSocketImpl ?? WebSocket;
      this.ws = new WS(wsURL);
      this.ws.onopen = this.onopen.bind(this, this.wsID);
      this.ws.onclose = this.onclose.bind(this, this.wsID);
      this.ws.onerror = this.onerror.bind(this, this.wsID);
      this.ws.onmessage = this.onmessage.bind(this, this.wsID);
      const response = await this.connectionOpen;
      this.isConnecting = false;
      if (response) {
        this.connectionID = response.connection_id;
        this.client.resolveConnectionId?.(this.connectionID);
        return response;
      }
    } catch (err) {
      this.client._setupConnectionIdPromise();
      this.isConnecting = false;
      this._log(`_connect() - Error - `, err);
      this.client.rejectConnectionId?.(err);
      throw err;
    }
  }
  /**
   * _reconnect - Retry the connection to WS endpoint
   *
   * @param {{ interval?: number; refreshToken?: boolean }} options Following options are available
   *
   * - `interval`	{int}			number of ms that function should wait before reconnecting
   * - `refreshToken` {boolean}	reload/refresh user token be refreshed before attempting reconnection.
   */
  async _reconnect(options = {}) {
    this._log("_reconnect() - Initiating the reconnect");
    if (this.isConnecting || this.isHealthy) {
      this._log("_reconnect() - Abort (1) since already connecting or healthy");
      return;
    }
    let interval2 = options.interval;
    if (!interval2) {
      interval2 = retryInterval(this.consecutiveFailures);
    }
    await sleep(interval2);
    if (this.isConnecting || this.isHealthy) {
      this._log("_reconnect() - Abort (2) since already connecting or healthy");
      return;
    }
    if (this.isDisconnected) {
      this._log("_reconnect() - Abort (3) since disconnect() is called");
      return;
    }
    this._log("_reconnect() - Destroying current WS connection");
    this._destroyCurrentWSConnection();
    if (options.refreshToken) {
      await this.client.tokenManager.loadToken();
    }
    try {
      await this._connect();
      this._log("_reconnect() - Waiting for recoverCallBack");
      this._log("_reconnect() - Finished recoverCallBack");
      this.consecutiveFailures = 0;
    } catch (error) {
      this.isHealthy = false;
      this.consecutiveFailures += 1;
      if (error.code === KnownCodes.TOKEN_EXPIRED && !this.client.tokenManager.isStatic()) {
        this._log("_reconnect() - WS failure due to expired token, so going to try to reload token and reconnect");
        return this._reconnect({ refreshToken: true });
      }
      if (error.isWSFailure) {
        this._log("_reconnect() - WS failure, so going to try to reconnect");
        this._reconnect();
      }
    }
    this._log("_reconnect() - == END ==");
  }
  /**
   * _destroyCurrentWSConnection - Removes the current WS connection
   *
   */
  _destroyCurrentWSConnection() {
    this.wsID += 1;
    try {
      this?.ws?.close();
    } catch {
    }
  }
  get connectionOpen() {
    return this.connectionOpenSafe?.();
  }
};
function getUserFromToken(token) {
  const fragments = token.split(".");
  if (fragments.length !== 3) {
    return "";
  }
  const b64Payload = fragments[1];
  const payload = decodeBase64(b64Payload);
  const data = JSON.parse(payload);
  return data.user_id;
}
var decodeBase64 = (s2) => {
  const e2 = {}, w2 = String.fromCharCode, L2 = s2.length;
  let i2, b2 = 0, c2, x2, l = 0, a2, r2 = "";
  const A2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (i2 = 0; i2 < 64; i2++) {
    e2[A2.charAt(i2)] = i2;
  }
  for (x2 = 0; x2 < L2; x2++) {
    c2 = e2[s2.charAt(x2)];
    b2 = (b2 << 6) + c2;
    l += 6;
    while (l >= 8) {
      if ((a2 = b2 >>> (l -= 8) & 255) || x2 < L2 - 2)
        r2 += w2(a2);
    }
  }
  return r2;
};
var TokenManager = class {
  constructor(secret) {
    this.loadTokenPromise = null;
    this.type = "static";
    this.setTokenOrProvider = async (tokenOrProvider, user, isAnonymous) => {
      this.user = user;
      this.isAnonymous = isAnonymous;
      this.validateToken(tokenOrProvider);
      if (isFunction2(tokenOrProvider)) {
        this.tokenProvider = tokenOrProvider;
        this.type = "provider";
      }
      if (typeof tokenOrProvider === "string") {
        this.token = tokenOrProvider;
        this.type = "static";
      }
      await this.loadToken();
    };
    this.reset = () => {
      this.token = void 0;
      this.tokenProvider = void 0;
      this.type = "static";
      this.user = void 0;
      this.loadTokenPromise = null;
    };
    this.validateToken = (tokenOrProvider) => {
      if (this.user && this.isAnonymous && !tokenOrProvider)
        return;
      if (!this.secret && !tokenOrProvider) {
        throw new Error("User token can not be empty");
      }
      if (typeof tokenOrProvider !== "string" && !isFunction2(tokenOrProvider)) {
        throw new Error("User token should either be a string or a function");
      }
      if (typeof tokenOrProvider === "string") {
        if (this.isAnonymous && tokenOrProvider === "")
          return;
        const tokenUserId = getUserFromToken(tokenOrProvider);
        if (tokenOrProvider != null && (tokenUserId == null || tokenUserId === "" || !this.isAnonymous && tokenUserId !== this.user.id)) {
          throw new Error("userToken does not have a user_id or is not matching with user.id");
        }
      }
    };
    this.tokenReady = () => this.loadTokenPromise;
    this.loadToken = () => {
      this.loadTokenPromise = new Promise(async (resolve, reject) => {
        if (this.type === "static") {
          return resolve(this.token);
        }
        if (this.tokenProvider && typeof this.tokenProvider !== "string") {
          try {
            const token = await this.tokenProvider();
            this.validateToken(token);
            this.token = token;
          } catch (e2) {
            return reject(new Error(`Call to tokenProvider failed with message: ${e2}`, {
              cause: e2
            }));
          }
          resolve(this.token);
        }
      });
      return this.loadTokenPromise;
    };
    this.getToken = () => {
      if (this.token) {
        return this.token;
      }
      if (this.user && !this.token) {
        return this.token;
      }
      throw new Error(`User token is not set. Either client.connectUser wasn't called or client.disconnect was called`);
    };
    this.isStatic = () => this.type === "static";
    this.secret = secret;
  }
};
var getLocationHint = async (hintUrl = `https://hint.stream-io-video.com/`, timeout2 = 2e3, maxAttempts = 3) => {
  const logger = videoLoggerSystem.getLogger("location-hint");
  let attempt = 0;
  let locationHint = "ERR";
  do {
    const abortController = new AbortController();
    const timeoutId = setTimeout(() => abortController.abort(), timeout2);
    try {
      const response = await fetch(hintUrl, {
        method: "HEAD",
        signal: abortController.signal
      });
      const awsPop = response.headers.get("x-amz-cf-pop") || "ERR";
      logger.debug(`Location header: ${awsPop}`);
      locationHint = awsPop.substring(0, 3);
    } catch (e2) {
      logger.warn(`Failed to get location hint from ${hintUrl}`, e2);
      locationHint = "ERR";
    } finally {
      clearTimeout(timeoutId);
    }
  } while (locationHint === "ERR" && ++attempt < maxAttempts);
  return locationHint;
};
var StreamClient = class {
  /**
   * Initialize a client.
   *
   * @param {string} key - the api key
   * @param {StreamClientOptions} [options] - additional options, here you can pass custom options to axios instance
   * @param {string} [options.secret] - the api secret
   * @param {boolean} [options.browser] - enforce the client to be in browser mode
   * @param {boolean} [options.warmUp] - default to false, if true, client will open a connection as soon as possible to speed up following requests
   * @param {Logger} [options.Logger] - custom logger
   * @param {number} [options.timeout] - default to 3000
   * @param {httpsAgent} [options.httpsAgent] - custom httpsAgent, in node it's default to https.agent()
   */
  constructor(key, options) {
    this.listeners = {};
    this.getAuthType = () => {
      return this.anonymous ? "anonymous" : "jwt";
    };
    this.setBaseURL = (baseURL) => {
      this.baseURL = baseURL;
      this.wsBaseURL = this.baseURL.replace("http", "ws").replace(":3030", ":8800");
    };
    this.getLocationHint = async (hintUrl, timeout2) => {
      const hint = await this.locationHint;
      if (!hint || hint === "ERR") {
        this.locationHint = getLocationHint(hintUrl ?? this.options.locationHintUrl, timeout2 ?? this.options.locationHintTimeout);
        return this.locationHint;
      }
      return hint;
    };
    this._getConnectionID = () => this.wsConnection?.connectionID;
    this._hasConnectionID = () => Boolean(this._getConnectionID());
    this.connectUser = async (user, tokenOrProvider) => {
      if (!user.id) {
        throw new Error('The "id" field on the user is missing');
      }
      if (this.userID === user.id && this.connectUserTask) {
        this.logger.warn("Consecutive calls to connectUser is detected, ideally you should only call this function once in your app.");
        return this.connectUserTask;
      }
      if (this.userID) {
        throw new Error("Use client.disconnect() before trying to connect as a different user. connectUser was called twice.");
      }
      if ((this.secret || this.node) && !this.options.allowServerSideConnect) {
        this.logger.warn("Please do not use connectUser server side. Use our @stream-io/node-sdk instead: https://getstream.io/video/docs/api/");
      }
      this.userID = user.id;
      this.anonymous = false;
      await this.tokenManager.setTokenOrProvider(tokenOrProvider, user, false);
      this._setUser(user);
      this.connectUserTask = this.openConnection();
      try {
        addConnectionEventListeners(this.updateNetworkConnectionStatus);
        return await this.connectUserTask;
      } catch (err) {
        if (this.persistUserOnConnectionFailure) {
          await this.closeConnection();
        } else {
          await this.disconnectUser();
        }
        throw err;
      }
    };
    this._setUser = (user) => {
      this.user = user;
      this.userID = user.id;
      this._user = { ...user };
    };
    this.closeConnection = async (timeout2) => {
      await this.wsConnection?.disconnect(timeout2);
    };
    this.openConnection = async () => {
      if (!this.userID) {
        throw Error("UserWithId is not set on client, use client.connectUser or client.connectAnonymousUser instead");
      }
      const wsPromise = this.wsPromiseSafe?.();
      if (this.wsConnection?.isConnecting && wsPromise) {
        this.logger.info("client:openConnection() - connection already in progress");
        return await wsPromise;
      }
      if (this.wsConnection?.isHealthy && this._hasConnectionID()) {
        this.logger.info("client:openConnection() - openConnection called twice, healthy connection already exists");
        return;
      }
      this._setupConnectionIdPromise();
      this.clientID = `${this.userID}--${generateUUIDv4()}`;
      const newWsPromise = this.connect();
      this.wsPromiseSafe = makeSafePromise(newWsPromise);
      return await newWsPromise;
    };
    this.disconnectUser = async (timeout2) => {
      this.logger.info("client:disconnect() - Disconnecting the client");
      delete this.user;
      delete this._user;
      delete this.userID;
      this.anonymous = false;
      await this.closeConnection(timeout2);
      removeConnectionEventListeners(this.updateNetworkConnectionStatus);
      this.tokenManager.reset();
      this.connectionIdPromiseSafe = void 0;
      this.rejectConnectionId = void 0;
      this.resolveConnectionId = void 0;
    };
    this.connectGuestUser = async (user) => {
      this.guestUserCreatePromise = this.doAxiosRequest("post", "/guest", { user }, { publicEndpoint: true });
      const response = await this.guestUserCreatePromise;
      this.guestUserCreatePromise.finally(() => this.guestUserCreatePromise = void 0);
      return this.connectUser(response.user, response.access_token);
    };
    this.connectAnonymousUser = async (user, tokenOrProvider) => {
      addConnectionEventListeners(this.updateNetworkConnectionStatus);
      this._setupConnectionIdPromise();
      this.anonymous = true;
      await this.tokenManager.setTokenOrProvider(tokenOrProvider, user, true);
      this._setUser(user);
      this.resolveConnectionId?.();
    };
    this.on = (eventName, callback) => {
      if (!this.listeners[eventName]) {
        this.listeners[eventName] = [];
      }
      this.logger.debug(`Adding listener for ${eventName} event`);
      this.listeners[eventName]?.push(callback);
      return () => {
        this.off(eventName, callback);
      };
    };
    this.off = (eventName, callback) => {
      if (!this.listeners[eventName]) {
        this.listeners[eventName] = [];
      }
      this.logger.debug(`Removing listener for ${eventName} event`);
      this.listeners[eventName] = this.listeners[eventName]?.filter((value) => value !== callback);
    };
    this._setupConnectionIdPromise = () => {
      this.connectionIdPromiseSafe = makeSafePromise(new Promise((resolve, reject) => {
        this.resolveConnectionId = resolve;
        this.rejectConnectionId = reject;
      }));
    };
    this._logApiRequest = (type, url, data, config2) => {
      if (this.logger.getLogLevel() !== "trace")
        return;
      this.logger.trace(`client: ${type} - Request - ${url}`, {
        payload: data,
        config: config2
      });
    };
    this._logApiResponse = (type, url, response) => {
      if (this.logger.getLogLevel() !== "trace")
        return;
      this.logger.trace(`client:${type} - Response - url: ${url} > status ${response.status}`, {
        response
      });
    };
    this.doAxiosRequest = async (type, url, data, options2 = {}) => {
      if (!options2.publicEndpoint) {
        await Promise.all([
          this.tokenManager.tokenReady(),
          this.guestUserCreatePromise
        ]);
        try {
          await this.connectionIdPromise;
        } catch {
          await this.wsConnection?._waitForHealthy();
          await this.connectionIdPromise;
        }
      }
      const requestConfig = this._enrichAxiosOptions(options2);
      try {
        let response;
        this._logApiRequest(type, url, data, requestConfig);
        switch (type) {
          case "get":
            response = await this.axiosInstance.get(url, requestConfig);
            break;
          case "delete":
            response = await this.axiosInstance.delete(url, requestConfig);
            break;
          case "post":
            response = await this.axiosInstance.post(url, data, requestConfig);
            break;
          case "put":
            response = await this.axiosInstance.put(url, data, requestConfig);
            break;
          case "patch":
            response = await this.axiosInstance.patch(url, data, requestConfig);
            break;
          case "options":
            response = await this.axiosInstance.options(url, requestConfig);
            break;
          default:
            throw new Error("Invalid request type");
        }
        this._logApiResponse(type, url, response);
        this.consecutiveFailures = 0;
        return response.data;
      } catch (e2) {
        e2.client_request_id = requestConfig.headers?.["x-client-request-id"];
        this.consecutiveFailures += 1;
        const { response } = e2;
        if (!response || !isErrorResponse(response)) {
          this.logger.error(`client:${type} url: ${url}`, e2);
          throw e2;
        }
        const { data: responseData, status } = response;
        const isTokenExpired = responseData.code === KnownCodes.TOKEN_EXPIRED;
        if (isTokenExpired && !this.tokenManager.isStatic()) {
          this.logger.warn(`client:${type}: url: ${url}`, response);
          if (this.consecutiveFailures > 1) {
            await sleep(retryInterval(this.consecutiveFailures));
          }
          await this.tokenManager.loadToken();
          return await this.doAxiosRequest(type, url, data, options2);
        } else {
          this.logger.error(`client:${type} url: ${url}`, response);
          throw new ErrorFromResponse({
            message: `Stream error code ${responseData.code}: ${responseData.message}`,
            code: responseData.code ?? null,
            unrecoverable: responseData.unrecoverable ?? null,
            response,
            status
          });
        }
      }
    };
    this.get = (url, params) => {
      return this.doAxiosRequest("get", url, null, {
        params
      });
    };
    this.put = (url, data, params) => {
      return this.doAxiosRequest("put", url, data, { params });
    };
    this.post = (url, data, params) => {
      return this.doAxiosRequest("post", url, data, { params });
    };
    this.patch = (url, data, params) => {
      return this.doAxiosRequest("patch", url, data, { params });
    };
    this.delete = (url, params) => {
      return this.doAxiosRequest("delete", url, null, {
        params
      });
    };
    this.dispatchEvent = (event) => {
      this.logger.debug(`Dispatching event: ${event.type}`, event);
      if (!this.listeners)
        return;
      for (const listener of this.listeners.all || []) {
        listener(event);
      }
      for (const listener of this.listeners[event.type] || []) {
        listener(event);
      }
    };
    this.connect = async () => {
      if (!this.userID || !this._user) {
        throw Error("Call connectUser or connectAnonymousUser before starting the connection");
      }
      if (!this.wsBaseURL)
        throw Error("Websocket base url not set");
      if (!this.clientID)
        throw Error("clientID is not set");
      this.wsConnection = new StableWSConnection(this);
      this.logger.info("StreamClient.connect: this.wsConnection.connect()");
      return await this.wsConnection.connect(this.defaultWSTimeout);
    };
    this.getUserAgent = () => {
      if (!this.cachedUserAgent) {
        const { clientAppIdentifier = {} } = this.options;
        const { sdkName = "js", sdkVersion = "1.37.3", ...extras } = clientAppIdentifier;
        this.cachedUserAgent = [
          `stream-video-${sdkName}-v${sdkVersion}`,
          ...Object.entries(extras).map(([key2, value]) => `${key2}=${value}`),
          `client_bundle=${"browser-esm"}`
        ].join("|");
      }
      return this.cachedUserAgent;
    };
    this._enrichAxiosOptions = (options2 = {
      params: {},
      headers: {},
      config: {}
    }) => {
      const token = options2.publicEndpoint && !this.user ? void 0 : this._getToken();
      const authorization = token ? { Authorization: token } : void 0;
      if (!options2.headers?.["x-client-request-id"]) {
        options2.headers = {
          ...options2.headers,
          "x-client-request-id": generateUUIDv4()
        };
      }
      const { params: axiosConfigParams, headers: axiosConfigHeaders, ...axiosRequestConfig } = this.options.axiosRequestConfig || {};
      return {
        params: {
          user_id: this.userID,
          connection_id: this._getConnectionID(),
          api_key: this.key,
          ...options2.params,
          ...axiosConfigParams
        },
        headers: {
          ...authorization,
          "stream-auth-type": options2.publicEndpoint && !this.user ? "anonymous" : this.getAuthType(),
          "X-Stream-Client": this.getUserAgent(),
          ...options2.headers,
          ...axiosConfigHeaders
        },
        ...options2.config,
        ...axiosRequestConfig
      };
    };
    this._getToken = () => {
      if (!this.tokenManager)
        return null;
      return this.tokenManager.getToken();
    };
    this.updateNetworkConnectionStatus = (event) => {
      if (event.type === "offline") {
        this.logger.debug("device went offline");
        this.dispatchEvent({ type: "network.changed", online: false });
      } else if (event.type === "online") {
        this.logger.debug("device went online");
        this.dispatchEvent({ type: "network.changed", online: true });
      }
    };
    this.key = key;
    this.secret = options?.secret;
    const inputOptions = options ? options : {
      browser: typeof window !== "undefined"
    };
    this.browser = inputOptions.browser || typeof window !== "undefined";
    this.node = !this.browser;
    if (this.browser) {
      this.locationHint = getLocationHint(options?.locationHintUrl, options?.locationHintTimeout, options?.locationHintMaxAttempts);
    }
    this.options = {
      timeout: 5e3,
      withCredentials: false,
      // making sure cookies are not sent
      ...inputOptions
    };
    if (this.node && !this.options.httpsAgent) {
      this.options.httpsAgent = new https.Agent({
        keepAlive: true,
        keepAliveMsecs: 3e3
      });
    }
    this.setBaseURL(this.options.baseURL || "https://video.stream-io-api.com/video");
    this.axiosInstance = axios_default.create({
      ...this.options,
      baseURL: this.baseURL
    });
    this.wsConnection = null;
    this.wsPromiseSafe = null;
    this.connectUserTask = null;
    this.anonymous = false;
    this.persistUserOnConnectionFailure = this.options?.persistUserOnConnectionFailure;
    this.tokenManager = new TokenManager(this.secret);
    this.consecutiveFailures = 0;
    this.defaultWSTimeout = this.options.defaultWsTimeout ?? 15e3;
    this.logger = videoLoggerSystem.getLogger("coordinator");
  }
  get connectionIdPromise() {
    return this.connectionIdPromiseSafe?.();
  }
  get isConnectionIsPromisePending() {
    return this.connectionIdPromiseSafe?.checkPending() ?? false;
  }
  get wsPromise() {
    return this.wsPromiseSafe?.();
  }
};
var getInstanceKey = (apiKey, user) => {
  return `${apiKey}/${user.id}`;
};
var getCallInitConcurrencyTag = (cid) => `call.init-${cid}`;
var getClientAppIdentifier = (options) => {
  const appId = options?.clientAppIdentifier || {};
  const sdkInfo2 = getSdkInfo();
  if (sdkInfo2) {
    appId.sdkName = SdkType[sdkInfo2.type].toLowerCase();
    appId.sdkVersion = `${sdkInfo2.major}.${sdkInfo2.minor}.${sdkInfo2.patch}`;
  }
  return appId;
};
var createCoordinatorClient = (apiKey, options) => {
  const clientAppIdentifier = getClientAppIdentifier(options);
  return new StreamClient(apiKey, {
    persistUserOnConnectionFailure: true,
    ...options,
    clientAppIdentifier
  });
};
var createTokenOrProvider = (options) => {
  const { token, tokenProvider } = options;
  if (token && tokenProvider) {
    let initialTokenUsed = false;
    return async function wrappedTokenProvider() {
      if (!initialTokenUsed) {
        initialTokenUsed = true;
        return token;
      }
      return tokenProvider();
    };
  }
  return token || tokenProvider;
};
var StreamVideoClient = class _StreamVideoClient {
  constructor(apiKeyOrArgs, opts) {
    this.effectsRegistered = false;
    this.eventHandlersToUnregister = [];
    this.connectionConcurrencyTag = Symbol("connectionConcurrencyTag");
    this.rejectCallWhenBusy = false;
    this.registerClientInstance = (apiKey2, user) => {
      const instanceKey = getInstanceKey(apiKey2, user);
      if (_StreamVideoClient._instances.has(instanceKey)) {
        this.logger.warn(`A StreamVideoClient already exists for ${user.id}; Prefer using getOrCreateInstance method`);
      }
      _StreamVideoClient._instances.set(instanceKey, this);
    };
    this.registerEffects = () => {
      if (this.effectsRegistered)
        return;
      this.eventHandlersToUnregister.push(this.on("call.created", (event) => this.initCallFromEvent(event)), this.on("call.ring", (event) => this.initCallFromEvent(event)), this.on("connection.changed", (event) => {
        if (!event.online)
          return;
        const callsToReWatch = this.writeableStateStore.calls.filter((call) => call.watching).map((call) => call.cid);
        if (callsToReWatch.length <= 0)
          return;
        this.logger.info(`Rewatching calls ${callsToReWatch.join(", ")}`);
        this.queryCalls({
          watch: true,
          filter_conditions: { cid: { $in: callsToReWatch } },
          sort: [{ field: "cid", direction: 1 }]
        }).catch((err) => {
          this.logger.error("Failed to re-watch calls", err);
        });
      }));
      this.effectsRegistered = true;
    };
    this.initCallFromEvent = async (e2) => {
      try {
        const concurrencyTag = getCallInitConcurrencyTag(e2.call_cid);
        await withoutConcurrency(concurrencyTag, async () => {
          const ringing = e2.type === "call.ring";
          let call = this.writeableStateStore.findCall(e2.call.type, e2.call.id);
          if (call) {
            if (ringing) {
              if (this.shouldRejectCall(call.cid)) {
                this.logger.info(`Leaving call with busy reject reason ${call.cid} because user is busy`);
                await call.leave();
                await call.reject("busy");
              } else {
                await call.updateFromRingingEvent(e2);
              }
            } else {
              call.state.updateFromCallResponse(e2.call);
            }
            return;
          }
          call = new Call({
            streamClient: this.streamClient,
            type: e2.call.type,
            id: e2.call.id,
            members: e2.members,
            clientStore: this.writeableStateStore,
            ringing
          });
          if (ringing) {
            if (this.shouldRejectCall(call.cid)) {
              this.logger.info(`Rejecting call ${call.cid} because user is busy`);
              await call.reject("busy");
            } else {
              await call.updateFromRingingEvent(e2);
              await call.get();
            }
          } else {
            call.state.updateFromCallResponse(e2.call);
            this.writeableStateStore.registerCall(call);
            this.logger.info(`New call created and registered: ${call.cid}`);
          }
        });
      } catch (err) {
        this.logger.error(`Failed to init call from event ${e2.type}`, err);
      }
    };
    this.connectUser = async (user, tokenOrProvider) => {
      if (user.type === "anonymous") {
        user.id = "!anon";
        return this.connectAnonymousUser(user, tokenOrProvider);
      }
      const connectUserResponse = await withoutConcurrency(this.connectionConcurrencyTag, async () => {
        const client = this.streamClient;
        const { onConnectUserError, persistUserOnConnectionFailure } = client.options;
        let { maxConnectUserRetries = 5 } = client.options;
        maxConnectUserRetries = Math.max(maxConnectUserRetries, 1);
        const errorQueue = [];
        for (let attempt = 0; attempt < maxConnectUserRetries; attempt++) {
          try {
            this.logger.trace(`Connecting user (${attempt})`, user);
            return user.type === "guest" ? await client.connectGuestUser(user) : await client.connectUser(user, tokenOrProvider);
          } catch (err) {
            this.logger.warn(`Failed to connect a user (${attempt})`, err);
            errorQueue.push(err);
            if (attempt === maxConnectUserRetries - 1) {
              onConnectUserError?.(err, errorQueue);
              throw err;
            }
            if (persistUserOnConnectionFailure) {
              await client.disconnectUser();
            }
            await sleep(retryInterval(attempt));
          }
        }
      });
      if (connectUserResponse?.me) {
        this.writeableStateStore.setConnectedUser(connectUserResponse.me);
      }
      this.registerEffects();
      return connectUserResponse;
    };
    this.disconnectUser = async (timeout2) => {
      await withoutConcurrency(this.connectionConcurrencyTag, async () => {
        const { user, key } = this.streamClient;
        if (!user)
          return;
        await this.streamClient.disconnectUser(timeout2);
        if (user.id) {
          _StreamVideoClient._instances.delete(getInstanceKey(key, user));
        }
        this.eventHandlersToUnregister.forEach((unregister) => unregister());
        this.eventHandlersToUnregister = [];
        this.effectsRegistered = false;
        this.writeableStateStore.setConnectedUser(void 0);
      });
    };
    this.on = (eventName, callback) => {
      return this.streamClient.on(eventName, callback);
    };
    this.off = (eventName, callback) => {
      return this.streamClient.off(eventName, callback);
    };
    this.call = (type, id, options = {}) => {
      const call = options.reuseInstance ? this.writeableStateStore.findCall(type, id) : void 0;
      return call ?? new Call({
        streamClient: this.streamClient,
        id,
        type,
        clientStore: this.writeableStateStore
      });
    };
    this.createGuestUser = async (data) => {
      return this.streamClient.doAxiosRequest("post", "/guest", data, { publicEndpoint: true });
    };
    this.queryCalls = async (data = {}) => {
      const response = await this.streamClient.post("/calls", data);
      const calls = [];
      for (const c2 of response.calls) {
        const call = new Call({
          streamClient: this.streamClient,
          id: c2.call.id,
          type: c2.call.type,
          members: c2.members,
          ownCapabilities: c2.own_capabilities,
          watching: data.watch,
          clientStore: this.writeableStateStore
        });
        call.state.updateFromCallResponse(c2.call);
        await call.applyDeviceConfig(c2.call.settings, false);
        if (data.watch) {
          await call.setup();
          this.writeableStateStore.registerCall(call);
        }
        calls.push(call);
      }
      return {
        ...response,
        calls
      };
    };
    this.queryCallStats = async (data = {}) => {
      return this.streamClient.post(`/call/stats`, data);
    };
    this.queryAggregateCallStats = async (data = {}) => {
      return this.streamClient.post(`/stats`, data);
    };
    this.edges = async () => {
      return this.streamClient.get(`/edges`);
    };
    this.addDevice = async (id, push_provider, push_provider_name, userID, voip_token) => {
      return await this.streamClient.post("/devices", {
        id,
        push_provider,
        voip_token,
        ...userID != null ? { user_id: userID } : {},
        ...push_provider_name != null ? { push_provider_name } : {}
      });
    };
    this.addVoipDevice = async (id, push_provider, push_provider_name, userID) => {
      return await this.addDevice(id, push_provider, push_provider_name, userID, true);
    };
    this.getDevices = async (userID) => {
      return await this.streamClient.get("/devices", userID ? { user_id: userID } : {});
    };
    this.removeDevice = async (id, userID) => {
      return await this.streamClient.delete("/devices", {
        id,
        ...userID ? { user_id: userID } : {}
      });
    };
    this.onRingingCall = async (call_cid) => {
      return withoutConcurrency(getCallInitConcurrencyTag(call_cid), async () => {
        let call = this.state.calls.find((c2) => c2.cid === call_cid && c2.ringing);
        if (!call) {
          const [callType, callId] = call_cid.split(":");
          call = new Call({
            streamClient: this.streamClient,
            type: callType,
            id: callId,
            clientStore: this.writeableStateStore,
            ringing: true
          });
          await call.get();
        }
        return call;
      });
    };
    this.connectAnonymousUser = async (user, tokenOrProvider) => {
      return withoutConcurrency(this.connectionConcurrencyTag, () => this.streamClient.connectAnonymousUser(user, tokenOrProvider));
    };
    this.shouldRejectCall = (currentCallId) => {
      if (!this.rejectCallWhenBusy)
        return false;
      return this.state.calls.some((c2) => c2.cid !== currentCallId && c2.ringing && !c2.isCreatedByMe && c2.state.callingState !== CallingState.IDLE && c2.state.callingState !== CallingState.LEFT && c2.state.callingState !== CallingState.RECONNECTING_FAILED);
    };
    const apiKey = typeof apiKeyOrArgs === "string" ? apiKeyOrArgs : apiKeyOrArgs.apiKey;
    const clientOptions = typeof apiKeyOrArgs === "string" ? opts : apiKeyOrArgs.options;
    if (clientOptions?.enableTimerWorker)
      enableTimerWorker();
    const rootLogger = clientOptions?.logger || logToConsole2;
    videoLoggerSystem.configureLoggers({
      default: { sink: rootLogger, level: clientOptions?.logLevel || "warn" },
      ...clientOptions?.logOptions
    });
    this.logger = videoLoggerSystem.getLogger("client");
    this.rejectCallWhenBusy = clientOptions?.rejectCallWhenBusy ?? false;
    this.streamClient = createCoordinatorClient(apiKey, clientOptions);
    this.writeableStateStore = new StreamVideoWriteableStateStore();
    this.readOnlyStateStore = new StreamVideoReadOnlyStateStore(this.writeableStateStore);
    if (typeof apiKeyOrArgs !== "string" && apiKeyOrArgs.user) {
      const user = apiKeyOrArgs.user;
      if (user.type === "anonymous")
        user.id = "!anon";
      if (user.id)
        this.registerClientInstance(apiKey, user);
      const tokenOrProvider = createTokenOrProvider(apiKeyOrArgs);
      this.connectUser(user, tokenOrProvider).catch((err) => {
        this.logger.error("Failed to connect", err);
      });
    }
  }
  /**
   * Gets or creates a StreamVideoClient instance based on the given options.
   */
  static getOrCreateInstance(args) {
    const { apiKey, user, token, tokenProvider } = args;
    if (!user.id && user.type !== "anonymous") {
      throw new Error("user.id is required for a non-anonymous user");
    }
    if (!token && !tokenProvider && user.type !== "anonymous" && user.type !== "guest") {
      throw new Error("tokenProvider or token is required for a authenticated users");
    }
    return _StreamVideoClient._instances.get(getInstanceKey(apiKey, user)) || new _StreamVideoClient(args);
  }
  /**
   * Return the reactive state store, use this if you want to be notified about changes to the client state
   */
  get state() {
    return this.readOnlyStateStore;
  }
};
StreamVideoClient._instances = /* @__PURE__ */ new Map();

// node_modules/@stream-io/video-react-bindings/dist/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var import_shim = __toESM(require_shim());
var StreamCallContext = (0, import_react.createContext)(void 0);
var StreamCallProvider = (props) => {
  const { call, children } = props;
  return (0, import_jsx_runtime.jsx)(StreamCallContext.Provider, { value: call, children });
};
var useCall = () => {
  return (0, import_react.useContext)(StreamCallContext);
};
var mapToRegistry = (translationsMap, namespace) => Object.entries(translationsMap).reduce((acc, [lng, translations2]) => {
  acc[lng] = { [namespace]: translations2 };
  return acc;
}, {});
var defaultTranslationFunction = (key) => key;
var StreamI18n = class {
  constructor({ debug = false, currentLanguage = "en", fallbackLanguage, translationsOverrides = { en: {} } } = {}) {
    this.t = defaultTranslationFunction;
    this.init = async () => {
      this.t = await this.i18nInstance.init();
      return this.t;
    };
    this.changeLanguage = async (language) => {
      this.t = await this.i18nInstance.changeLanguage(language);
      return this.t;
    };
    const ns2 = "stream-video";
    this.i18nInstance = instance.createInstance({
      debug,
      defaultNS: ns2,
      fallbackLng: fallbackLanguage,
      interpolation: { escapeValue: false },
      keySeparator: false,
      lng: currentLanguage,
      nsSeparator: false,
      parseMissingKeyHandler: defaultTranslationFunction,
      resources: mapToRegistry(translationsOverrides, ns2)
    });
  }
  get currentLanguage() {
    return this.i18nInstance.language;
  }
  get isInitialized() {
    return this.i18nInstance.isInitialized;
  }
};
var StreamI18nContext = (0, import_react.createContext)({
  t: defaultTranslationFunction
});
var StreamI18nProvider = ({ children, ...createI18nParams }) => {
  const api = useCreateI18n(createI18nParams);
  return (0, import_jsx_runtime.jsx)(StreamI18nContext.Provider, { value: api, children });
};
var useCreateI18n = ({ i18nInstance, language, fallbackLanguage, translationsOverrides }) => {
  const [i18n] = (0, import_react.useState)(() => i18nInstance || new StreamI18n({
    currentLanguage: language,
    fallbackLanguage,
    translationsOverrides
  }));
  const [t2, setTranslationFn] = (0, import_react.useState)(() => i18n.t);
  (0, import_react.useEffect)(() => {
    if (!i18n.isInitialized) {
      i18n.init().then(() => setTranslationFn(() => i18n.t));
    } else if (i18n.currentLanguage !== language) {
      i18n.changeLanguage(language).then(() => setTranslationFn(() => i18n.t));
    }
  }, [i18n, language]);
  return (0, import_react.useMemo)(() => ({ i18n, t: t2 }), [i18n, t2]);
};
var useI18n = () => (0, import_react.useContext)(StreamI18nContext);
var StreamVideoContext = (0, import_react.createContext)(void 0);
var StreamVideoProvider = ({ children, client, i18nInstance, language, translationsOverrides }) => {
  return (0, import_jsx_runtime.jsx)(StreamVideoContext.Provider, { value: client, children: (0, import_jsx_runtime.jsx)(StreamI18nProvider, { i18nInstance, language, translationsOverrides, children }) });
};
var useStreamVideoClient = () => {
  return (0, import_react.useContext)(StreamVideoContext);
};
var isReactNative3 = () => {
  if (typeof navigator === "undefined")
    return false;
  return navigator.product?.toLowerCase() === "reactnative";
};
var useObservableValue = (observable$, defaultValue) => {
  const getSnapshot = (0, import_react.useCallback)(() => {
    try {
      return rxUtils.getCurrentValue(observable$);
    } catch (error) {
      if (typeof defaultValue === "undefined")
        throw error;
      return defaultValue;
    }
  }, [defaultValue, observable$]);
  const subscribe = (0, import_react.useCallback)((onStoreChange) => {
    const unsubscribe = rxUtils.createSubscription(observable$, onStoreChange, (error) => {
      console.log("An error occurred while reading an observable", error);
      if (defaultValue)
        onStoreChange(defaultValue);
    });
    return unsubscribe;
  }, [defaultValue, observable$]);
  return (0, import_shim.useSyncExternalStore)(subscribe, getSnapshot);
};
var EMPTY_DEVICES_ARRAY = Object.freeze([]);
var useCallState = () => {
  const call = useCall();
  if (!call) {
    const message = 'You are using useCallState() outside a Call context. Please wrap your component in <StreamCall /> and provide a "call" instance.';
    console.warn(message);
    return new CallState();
  }
  return call.state;
};
var useIsCallRecordingInProgress = () => {
  const { recording$ } = useCallState();
  return useObservableValue(recording$);
};
var useIsCallHLSBroadcastingInProgress = () => {
  const { egress$ } = useCallState();
  const egress = useObservableValue(egress$);
  if (!egress)
    return false;
  return egress.broadcasting;
};
var useIsCallLive = () => {
  const { backstage$ } = useCallState();
  const isBackstageOn = useObservableValue(backstage$);
  return !isBackstageOn;
};
var useCallBlockedUserIds = () => {
  const { blockedUserIds$ } = useCallState();
  return useObservableValue(blockedUserIds$);
};
var useCallCreatedAt = () => {
  const { createdAt$ } = useCallState();
  return useObservableValue(createdAt$);
};
var useCallEndedAt = () => {
  const { endedAt$ } = useCallState();
  return useObservableValue(endedAt$);
};
var useCallStartsAt = () => {
  const { startsAt$ } = useCallState();
  return useObservableValue(startsAt$);
};
var useCallUpdatedAt = () => {
  const { updatedAt$ } = useCallState();
  return useObservableValue(updatedAt$);
};
var useCallCreatedBy = () => {
  const { createdBy$ } = useCallState();
  return useObservableValue(createdBy$);
};
var useCallCustomData = () => {
  const { custom$ } = useCallState();
  return useObservableValue(custom$);
};
var useCallEgress = () => {
  const { egress$ } = useCallState();
  return useObservableValue(egress$);
};
var useCallIngress = () => {
  const { ingress$ } = useCallState();
  return useObservableValue(ingress$);
};
var useCallSession = () => {
  const { session$ } = useCallState();
  return useObservableValue(session$);
};
var useCallSettings = () => {
  const { settings$ } = useCallState();
  return useObservableValue(settings$);
};
var useIsCallTranscribingInProgress = () => {
  const { transcribing$ } = useCallState();
  return useObservableValue(transcribing$);
};
var useCallEndedBy = () => {
  const { endedBy$ } = useCallState();
  return useObservableValue(endedBy$);
};
var useHasOngoingScreenShare = () => {
  const { hasOngoingScreenShare$ } = useCallState();
  return useObservableValue(hasOngoingScreenShare$);
};
var useCallStatsReport = () => {
  const { callStatsReport$ } = useCallState();
  return useObservableValue(callStatsReport$);
};
var useDominantSpeaker = () => {
  const { dominantSpeaker$ } = useCallState();
  return useObservableValue(dominantSpeaker$);
};
var useCallMembers = () => {
  const { members$ } = useCallState();
  return useObservableValue(members$);
};
var useCallCallingState = () => {
  const { callingState$ } = useCallState();
  return useObservableValue(callingState$);
};
var useCallStartedAt = () => {
  const { startedAt$ } = useCallState();
  return useObservableValue(startedAt$);
};
var useParticipants = ({ sortBy } = {}) => {
  const { participants$ } = useCallState();
  const participants = useObservableValue(participants$);
  return (0, import_react.useMemo)(() => {
    if (sortBy) {
      return [...participants].sort(sortBy);
    }
    return participants;
  }, [participants, sortBy]);
};
var useRawParticipants = () => {
  const { rawParticipants$ } = useCallState();
  return useObservableValue(rawParticipants$);
};
var useLocalParticipant = () => {
  const { localParticipant$ } = useCallState();
  return useObservableValue(localParticipant$);
};
var useRemoteParticipants = () => {
  const { remoteParticipants$ } = useCallState();
  return useObservableValue(remoteParticipants$);
};
var usePinnedParticipants = () => {
  const { pinnedParticipants$ } = useCallState();
  return useObservableValue(pinnedParticipants$);
};
var useParticipantCount = () => {
  const { participantCount$ } = useCallState();
  return useObservableValue(participantCount$);
};
var useAnonymousParticipantCount = () => {
  const { anonymousParticipantCount$ } = useCallState();
  return useObservableValue(anonymousParticipantCount$);
};
var useCallThumbnail = () => {
  const { thumbnails$ } = useCallState();
  return useObservableValue(thumbnails$);
};
var useOwnCapabilities = () => {
  const { ownCapabilities$ } = useCallState();
  return useObservableValue(ownCapabilities$);
};
var useHasPermissions = (...permissions) => {
  const capabilities = useOwnCapabilities();
  return permissions.every((permission) => capabilities?.includes(permission));
};
var useCameraState = ({ optimisticUpdates = true } = {}) => {
  const call = useCall();
  const { camera } = call;
  const { state } = camera;
  const direction = useObservableValue(state.direction$);
  const mediaStream = useObservableValue(state.mediaStream$);
  const selectedDevice = useObservableValue(state.selectedDevice$);
  const { getDevices: getDevices2 } = useLazyDeviceList(camera);
  const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);
  const isPromptingPermission = useObservableValue(state.isPromptingPermission$);
  return {
    camera,
    direction,
    mediaStream,
    get devices() {
      return getDevices2();
    },
    hasBrowserPermission,
    isPromptingPermission,
    selectedDevice,
    ...getComputedStatus(useObservableValue(state.status$), useObservableValue(state.optimisticStatus$), { optimisticUpdates })
  };
};
var useMicrophoneState = ({ optimisticUpdates = true } = {}) => {
  const call = useCall();
  const { microphone } = call;
  const { state } = microphone;
  const mediaStream = useObservableValue(state.mediaStream$);
  const selectedDevice = useObservableValue(state.selectedDevice$);
  const { getDevices: getDevices2 } = useLazyDeviceList(microphone);
  const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);
  const isPromptingPermission = useObservableValue(state.isPromptingPermission$);
  const isSpeakingWhileMuted = useObservableValue(state.speakingWhileMuted$);
  const audioBitrateProfile = useObservableValue(state.audioBitrateProfile$);
  return {
    microphone,
    mediaStream,
    get devices() {
      return getDevices2();
    },
    selectedDevice,
    hasBrowserPermission,
    isPromptingPermission,
    isSpeakingWhileMuted,
    audioBitrateProfile,
    ...getComputedStatus(useObservableValue(state.status$), useObservableValue(state.optimisticStatus$), { optimisticUpdates })
  };
};
var useSpeakerState = () => {
  if (isReactNative3()) {
    throw new Error("This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details");
  }
  const call = useCall();
  const { speaker } = call;
  const { getDevices: getDevices2 } = useLazyDeviceList(speaker);
  const selectedDevice = useObservableValue(speaker.state.selectedDevice$);
  return {
    speaker,
    get devices() {
      return getDevices2();
    },
    selectedDevice,
    isDeviceSelectionSupported: speaker.state.isDeviceSelectionSupported
  };
};
var useScreenShareState = ({ optimisticUpdates = true } = {}) => {
  const call = useCall();
  const { screenShare } = call;
  const { state } = screenShare;
  return {
    screenShare,
    mediaStream: useObservableValue(state.mediaStream$),
    audioBitrateProfile: useObservableValue(state.audioBitrateProfile$),
    ...getComputedStatus(useObservableValue(state.status$), useObservableValue(state.optimisticStatus$), { optimisticUpdates })
  };
};
var useIncomingVideoSettings = () => {
  const call = useCall();
  return useObservableValue(call.dynascaleManager.incomingVideoSettings$);
};
var useCallClosedCaptions = () => {
  const { closedCaptions$ } = useCallState();
  return useObservableValue(closedCaptions$);
};
var useIsCallCaptioningInProgress = () => {
  const { captioning$ } = useCallState();
  return useObservableValue(captioning$);
};
function getComputedStatus(status, pendingStatus, options) {
  const optimisticStatus = pendingStatus ?? status;
  return {
    status,
    optimisticStatus,
    isEnabled: status === "enabled",
    isMute: status !== "enabled",
    optimisticIsMute: optimisticStatus !== "enabled",
    isTogglePending: optimisticStatus !== status,
    /**
     * If optimistic updates are enabled (`options.optimisticUpdates`), we
     * consider the optimistic status to determine whether the device is muted or not.
     * Otherwise, we rely on the actual status.
     */
    optionsAwareIsMute: options.optimisticUpdates ? optimisticStatus !== "enabled" : status !== "enabled"
  };
}
function useLazyDeviceList(manager) {
  const placeholderDevices$ = (0, import_react.useMemo)(() => of(EMPTY_DEVICES_ARRAY), []);
  const [devices$, setDevices$] = (0, import_react.useState)(placeholderDevices$);
  const devices = useObservableValue(devices$, EMPTY_DEVICES_ARRAY);
  const getDevices2 = () => {
    if (devices$ === placeholderDevices$) {
      setDevices$(manager.listDevices());
    }
    return devices ?? EMPTY_DEVICES_ARRAY;
  };
  return { getDevices: getDevices2 };
}
var CallStateHooks = Object.freeze({
  __proto__: null,
  useAnonymousParticipantCount,
  useCallBlockedUserIds,
  useCallCallingState,
  useCallClosedCaptions,
  useCallCreatedAt,
  useCallCreatedBy,
  useCallCustomData,
  useCallEgress,
  useCallEndedAt,
  useCallEndedBy,
  useCallIngress,
  useCallMembers,
  useCallSession,
  useCallSettings,
  useCallStartedAt,
  useCallStartsAt,
  useCallState,
  useCallStatsReport,
  useCallThumbnail,
  useCallUpdatedAt,
  useCameraState,
  useDominantSpeaker,
  useHasOngoingScreenShare,
  useHasPermissions,
  useIncomingVideoSettings,
  useIsCallCaptioningInProgress,
  useIsCallHLSBroadcastingInProgress,
  useIsCallLive,
  useIsCallRecordingInProgress,
  useIsCallTranscribingInProgress,
  useLocalParticipant,
  useMicrophoneState,
  useOwnCapabilities,
  useParticipantCount,
  useParticipants,
  usePinnedParticipants,
  useRawParticipants,
  useRemoteParticipants,
  useScreenShareState,
  useSpeakerState
});
function useEffectEventShim(cb) {
  const cbRef = (0, import_react.useRef)(cb);
  (0, import_react.useLayoutEffect)(() => {
    cbRef.current = cb;
  }, [cb]);
  return (0, import_react.useCallback)((...args) => {
    const callback = cbRef.current;
    return callback(...args);
  }, []);
}
var useEffectEvent = useEffectEventShim;
var useStore = () => {
  const client = useStreamVideoClient();
  if (!client) {
    throw new Error(`StreamVideoClient isn't initialized or this hook is called outside of <StreamVideo> context.`);
  }
  return client.state;
};
var useCalls = () => {
  const { calls$ } = useStore();
  return useObservableValue(calls$);
};
var useConnectedUser = () => {
  const { connectedUser$ } = useStore();
  return useObservableValue(connectedUser$);
};
var useToggleCallRecording = () => {
  const call = useCall();
  const isCallRecordingInProgress = useIsCallRecordingInProgress();
  const [isAwaitingResponse, setIsAwaitingResponse] = (0, import_react.useState)(false);
  (0, import_react.useEffect)(() => {
    setIsAwaitingResponse((isAwaiting) => {
      if (isAwaiting)
        return false;
      return isAwaiting;
    });
  }, [isCallRecordingInProgress]);
  const toggleCallRecording = (0, import_react.useCallback)(async () => {
    try {
      setIsAwaitingResponse(true);
      if (isCallRecordingInProgress) {
        await call?.stopRecording();
      } else {
        await call?.startRecording();
      }
    } catch (e2) {
      console.error(`Failed start recording`, e2);
      throw e2;
    }
  }, [call, isCallRecordingInProgress]);
  return { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress };
};
var useCallStateHooks = () => CallStateHooks;
var Restricted = ({ canRequestOnly, hasPermissionsOnly, requiredGrants, requireAll = true, children }) => {
  const call = useCall();
  const { useCallSettings: useCallSettings2, useOwnCapabilities: useOwnCapabilities2 } = useCallStateHooks();
  const ownCapabilities = useOwnCapabilities2();
  const settings = useCallSettings2();
  const hasPermissions = requiredGrants[requireAll ? "every" : "some"]((capability) => ownCapabilities?.includes(capability));
  if (hasPermissionsOnly)
    return hasPermissions ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }) : null;
  const canRequest = requiredGrants.some((capability) => call?.permissionsContext.canRequest(capability, settings));
  if (canRequestOnly)
    return canRequest ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }) : null;
  if (hasPermissions || canRequest)
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  return null;
};

// node_modules/@stream-io/video-react-sdk/dist/index.es.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/wasm-feature-detect/dist/esm/index.js
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));

// node_modules/@mediapipe/tasks-vision/vision_bundle.mjs
var t = "undefined" != typeof self ? self : {};
function e() {
  throw Error("Invalid UTF8");
}
function n(t2, e2) {
  return e2 = String.fromCharCode.apply(null, e2), null == t2 ? e2 : t2 + e2;
}
var r;
var i;
var s = "undefined" != typeof TextDecoder;
var o;
var a = "undefined" != typeof TextEncoder;
function c(t2) {
  if (a) t2 = (o ||= new TextEncoder()).encode(t2);
  else {
    let n2 = 0;
    const r2 = new Uint8Array(3 * t2.length);
    for (let i2 = 0; i2 < t2.length; i2++) {
      var e2 = t2.charCodeAt(i2);
      if (e2 < 128) r2[n2++] = e2;
      else {
        if (e2 < 2048) r2[n2++] = e2 >> 6 | 192;
        else {
          if (e2 >= 55296 && e2 <= 57343) {
            if (e2 <= 56319 && i2 < t2.length) {
              const s2 = t2.charCodeAt(++i2);
              if (s2 >= 56320 && s2 <= 57343) {
                e2 = 1024 * (e2 - 55296) + s2 - 56320 + 65536, r2[n2++] = e2 >> 18 | 240, r2[n2++] = e2 >> 12 & 63 | 128, r2[n2++] = e2 >> 6 & 63 | 128, r2[n2++] = 63 & e2 | 128;
                continue;
              }
              i2--;
            }
            e2 = 65533;
          }
          r2[n2++] = e2 >> 12 | 224, r2[n2++] = e2 >> 6 & 63 | 128;
        }
        r2[n2++] = 63 & e2 | 128;
      }
    }
    t2 = n2 === r2.length ? r2 : r2.subarray(0, n2);
  }
  return t2;
}
var h;
var u;
t: {
  for (l = ["CLOSURE_FLAGS"], d = t, f = 0; f < l.length; f++) if (null == (d = d[l[f]])) {
    u = null;
    break t;
  }
  u = d;
}
var l;
var d;
var f;
var p;
var g = u && u[610401301];
h = null != g && g;
var m = t.navigator;
function y(t2) {
  return !!h && (!!p && p.brands.some((({ brand: e2 }) => e2 && -1 != e2.indexOf(t2))));
}
function _(e2) {
  var n2;
  return (n2 = t.navigator) && (n2 = n2.userAgent) || (n2 = ""), -1 != n2.indexOf(e2);
}
function v() {
  return !!h && (!!p && p.brands.length > 0);
}
function E() {
  return v() ? y("Chromium") : (_("Chrome") || _("CriOS")) && !(!v() && _("Edge")) || _("Silk");
}
function w(t2) {
  return w[" "](t2), t2;
}
p = m && m.userAgentData || null, w[" "] = function() {
};
var T = !v() && (_("Trident") || _("MSIE"));
!_("Android") || E(), E(), _("Safari") && (E() || !v() && _("Coast") || !v() && _("Opera") || !v() && _("Edge") || (v() ? y("Microsoft Edge") : _("Edg/")) || v() && y("Opera"));
var A = {};
var b = null;
function k(t2) {
  const e2 = t2.length;
  let n2 = 3 * e2 / 4;
  n2 % 3 ? n2 = Math.floor(n2) : -1 != "=.".indexOf(t2[e2 - 1]) && (n2 = -1 != "=.".indexOf(t2[e2 - 2]) ? n2 - 2 : n2 - 1);
  const r2 = new Uint8Array(n2);
  let i2 = 0;
  return (function(t3, e3) {
    function n3(e4) {
      for (; r3 < t3.length; ) {
        const e5 = t3.charAt(r3++), n4 = b[e5];
        if (null != n4) return n4;
        if (!/^[\s\xa0]*$/.test(e5)) throw Error("Unknown base64 encoding at char: " + e5);
      }
      return e4;
    }
    S();
    let r3 = 0;
    for (; ; ) {
      const t4 = n3(-1), r4 = n3(0), i3 = n3(64), s2 = n3(64);
      if (64 === s2 && -1 === t4) break;
      e3(t4 << 2 | r4 >> 4), 64 != i3 && (e3(r4 << 4 & 240 | i3 >> 2), 64 != s2 && e3(i3 << 6 & 192 | s2));
    }
  })(t2, (function(t3) {
    r2[i2++] = t3;
  })), i2 !== n2 ? r2.subarray(0, i2) : r2;
}
function S() {
  if (!b) {
    b = {};
    var t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e2 = ["+/=", "+/", "-_=", "-_.", "-_"];
    for (let n2 = 0; n2 < 5; n2++) {
      const r2 = t2.concat(e2[n2].split(""));
      A[n2] = r2;
      for (let t3 = 0; t3 < r2.length; t3++) {
        const e3 = r2[t3];
        void 0 === b[e3] && (b[e3] = t3);
      }
    }
  }
}
var x = "undefined" != typeof Uint8Array;
var L = !T && "function" == typeof btoa;
function R(t2) {
  if (!L) {
    var e2;
    void 0 === e2 && (e2 = 0), S(), e2 = A[e2];
    var n2 = Array(Math.floor(t2.length / 3)), r2 = e2[64] || "";
    let c2 = 0, h2 = 0;
    for (; c2 < t2.length - 2; c2 += 3) {
      var i2 = t2[c2], s2 = t2[c2 + 1], o2 = t2[c2 + 2], a2 = e2[i2 >> 2];
      i2 = e2[(3 & i2) << 4 | s2 >> 4], s2 = e2[(15 & s2) << 2 | o2 >> 6], o2 = e2[63 & o2], n2[h2++] = a2 + i2 + s2 + o2;
    }
    switch (a2 = 0, o2 = r2, t2.length - c2) {
      case 2:
        o2 = e2[(15 & (a2 = t2[c2 + 1])) << 2] || r2;
      case 1:
        t2 = t2[c2], n2[h2] = e2[t2 >> 2] + e2[(3 & t2) << 4 | a2 >> 4] + o2 + r2;
    }
    return n2.join("");
  }
  for (e2 = "", n2 = 0, r2 = t2.length - 10240; n2 < r2; ) e2 += String.fromCharCode.apply(null, t2.subarray(n2, n2 += 10240));
  return e2 += String.fromCharCode.apply(null, n2 ? t2.subarray(n2) : t2), btoa(e2);
}
var F = /[-_.]/g;
var I = { "-": "+", _: "/", ".": "=" };
function M(t2) {
  return I[t2] || "";
}
function P(t2) {
  if (!L) return k(t2);
  F.test(t2) && (t2 = t2.replace(F, M)), t2 = atob(t2);
  const e2 = new Uint8Array(t2.length);
  for (let n2 = 0; n2 < t2.length; n2++) e2[n2] = t2.charCodeAt(n2);
  return e2;
}
function C(t2) {
  return x && null != t2 && t2 instanceof Uint8Array;
}
var O = {};
function U() {
  return B ||= new N(null, O);
}
function D(t2) {
  j(O);
  var e2 = t2.g;
  return null == (e2 = null == e2 || C(e2) ? e2 : "string" == typeof e2 ? P(e2) : null) ? e2 : t2.g = e2;
}
var N = class {
  h() {
    return new Uint8Array(D(this) || 0);
  }
  constructor(t2, e2) {
    if (j(e2), this.g = t2, null != t2 && 0 === t2.length) throw Error("ByteString should be constructed with non-empty values");
  }
};
var B;
var G;
function j(t2) {
  if (t2 !== O) throw Error("illegal external caller");
}
function V(t2, e2) {
  t2.__closure__error__context__984382 || (t2.__closure__error__context__984382 = {}), t2.__closure__error__context__984382.severity = e2;
}
function X(t2) {
  return V(t2 = Error(t2), "warning"), t2;
}
function H(e2) {
  if (null != e2) {
    var n2 = G ??= {}, r2 = n2[e2] || 0;
    r2 >= 5 || (n2[e2] = r2 + 1, V(e2 = Error(), "incident"), (function(e3) {
      t.setTimeout((() => {
        throw e3;
      }), 0);
    })(e2));
  }
}
var W = "function" == typeof Symbol && "symbol" == typeof Symbol();
function z(t2, e2, n2 = false) {
  return "function" == typeof Symbol && "symbol" == typeof Symbol() ? n2 && Symbol.for && t2 ? Symbol.for(t2) : null != t2 ? Symbol(t2) : Symbol() : e2;
}
var K = z("jas", void 0, true);
var Y = z(void 0, "0di");
var $ = z(void 0, "1oa");
var q = z(void 0, Symbol());
var J = z(void 0, "0actk");
var Z = z(void 0, "8utk");
var Q = W ? K : "Ea";
var tt = { Ea: { value: 0, configurable: true, writable: true, enumerable: false } };
var et = Object.defineProperties;
function nt(t2, e2) {
  W || Q in t2 || et(t2, tt), t2[Q] |= e2;
}
function rt(t2, e2) {
  W || Q in t2 || et(t2, tt), t2[Q] = e2;
}
function it(t2) {
  return nt(t2, 34), t2;
}
function st(t2, e2) {
  rt(e2, -15615 & (0 | t2));
}
function ot(t2, e2) {
  rt(e2, -15581 & (34 | t2));
}
function at() {
  return "function" == typeof BigInt;
}
function ct(t2) {
  return Array.prototype.slice.call(t2);
}
var ht;
var ut = {};
function lt(t2) {
  return null !== t2 && "object" == typeof t2 && !Array.isArray(t2) && t2.constructor === Object;
}
function dt(t2, e2) {
  if (null != t2) {
    if ("string" == typeof t2) t2 = t2 ? new N(t2, O) : U();
    else if (t2.constructor !== N) if (C(t2)) t2 = t2.length ? new N(new Uint8Array(t2), O) : U();
    else {
      if (!e2) throw Error();
      t2 = void 0;
    }
  }
  return t2;
}
var ft = [];
function pt(t2) {
  if (2 & t2) throw Error();
}
rt(ft, 55), ht = Object.freeze(ft);
var gt = class {
  constructor(t2, e2, n2) {
    this.g = t2, this.h = e2, this.l = n2;
  }
  next() {
    const t2 = this.g.next();
    return t2.done || (t2.value = this.h.call(this.l, t2.value)), t2;
  }
  [Symbol.iterator]() {
    return this;
  }
};
function mt(t2) {
  return q ? t2[q] : void 0;
}
var yt = Object.freeze({});
function _t(t2) {
  return t2.Na = true, t2;
}
var vt = _t(((t2) => "number" == typeof t2));
var Et = _t(((t2) => "string" == typeof t2));
var wt = _t(((t2) => "boolean" == typeof t2));
var Tt = "function" == typeof t.BigInt && "bigint" == typeof t.BigInt(0);
function At(t2) {
  var e2 = t2;
  if (Et(e2)) {
    if (!/^\s*(?:-?[1-9]\d*|0)?\s*$/.test(e2)) throw Error(String(e2));
  } else if (vt(e2) && !Number.isSafeInteger(e2)) throw Error(String(e2));
  return Tt ? BigInt(t2) : t2 = wt(t2) ? t2 ? "1" : "0" : Et(t2) ? t2.trim() || "0" : String(t2);
}
var bt = _t(((t2) => Tt ? t2 >= St && t2 <= Lt : "-" === t2[0] ? Rt(t2, kt) : Rt(t2, xt)));
var kt = Number.MIN_SAFE_INTEGER.toString();
var St = Tt ? BigInt(Number.MIN_SAFE_INTEGER) : void 0;
var xt = Number.MAX_SAFE_INTEGER.toString();
var Lt = Tt ? BigInt(Number.MAX_SAFE_INTEGER) : void 0;
function Rt(t2, e2) {
  if (t2.length > e2.length) return false;
  if (t2.length < e2.length || t2 === e2) return true;
  for (let n2 = 0; n2 < t2.length; n2++) {
    const r2 = t2[n2], i2 = e2[n2];
    if (r2 > i2) return false;
    if (r2 < i2) return true;
  }
}
var Ft = "function" == typeof Uint8Array.prototype.slice;
var It;
var Mt = 0;
var Pt = 0;
function Ct(t2) {
  const e2 = t2 >>> 0;
  Mt = e2, Pt = (t2 - e2) / 4294967296 >>> 0;
}
function Ot(t2) {
  if (t2 < 0) {
    Ct(-t2);
    const [e2, n2] = Xt(Mt, Pt);
    Mt = e2 >>> 0, Pt = n2 >>> 0;
  } else Ct(t2);
}
function Ut(t2) {
  const e2 = It ||= new DataView(new ArrayBuffer(8));
  e2.setFloat32(0, +t2, true), Pt = 0, Mt = e2.getUint32(0, true);
}
function Dt(t2, e2) {
  const n2 = 4294967296 * e2 + (t2 >>> 0);
  return Number.isSafeInteger(n2) ? n2 : Bt(t2, e2);
}
function Nt(t2, e2) {
  const n2 = 2147483648 & e2;
  return n2 && (e2 = ~e2 >>> 0, 0 == (t2 = 1 + ~t2 >>> 0) && (e2 = e2 + 1 >>> 0)), "number" == typeof (t2 = Dt(t2, e2)) ? n2 ? -t2 : t2 : n2 ? "-" + t2 : t2;
}
function Bt(t2, e2) {
  if (t2 >>>= 0, (e2 >>>= 0) <= 2097151) var n2 = "" + (4294967296 * e2 + t2);
  else at() ? n2 = "" + (BigInt(e2) << BigInt(32) | BigInt(t2)) : (t2 = (16777215 & t2) + 6777216 * (n2 = 16777215 & (t2 >>> 24 | e2 << 8)) + 6710656 * (e2 = e2 >> 16 & 65535), n2 += 8147497 * e2, e2 *= 2, t2 >= 1e7 && (n2 += t2 / 1e7 >>> 0, t2 %= 1e7), n2 >= 1e7 && (e2 += n2 / 1e7 >>> 0, n2 %= 1e7), n2 = e2 + Gt(n2) + Gt(t2));
  return n2;
}
function Gt(t2) {
  return t2 = String(t2), "0000000".slice(t2.length) + t2;
}
function jt() {
  var t2 = Mt, e2 = Pt;
  if (2147483648 & e2) if (at()) t2 = "" + (BigInt(0 | e2) << BigInt(32) | BigInt(t2 >>> 0));
  else {
    const [n2, r2] = Xt(t2, e2);
    t2 = "-" + Bt(n2, r2);
  }
  else t2 = Bt(t2, e2);
  return t2;
}
function Vt(t2) {
  if (t2.length < 16) Ot(Number(t2));
  else if (at()) t2 = BigInt(t2), Mt = Number(t2 & BigInt(4294967295)) >>> 0, Pt = Number(t2 >> BigInt(32) & BigInt(4294967295));
  else {
    const e2 = +("-" === t2[0]);
    Pt = Mt = 0;
    const n2 = t2.length;
    for (let r2 = e2, i2 = (n2 - e2) % 6 + e2; i2 <= n2; r2 = i2, i2 += 6) {
      const e3 = Number(t2.slice(r2, i2));
      Pt *= 1e6, Mt = 1e6 * Mt + e3, Mt >= 4294967296 && (Pt += Math.trunc(Mt / 4294967296), Pt >>>= 0, Mt >>>= 0);
    }
    if (e2) {
      const [t3, e3] = Xt(Mt, Pt);
      Mt = t3, Pt = e3;
    }
  }
}
function Xt(t2, e2) {
  return e2 = ~e2, t2 ? t2 = 1 + ~t2 : e2 += 1, [t2, e2];
}
var Ht = "function" == typeof BigInt ? BigInt.asIntN : void 0;
var Wt = "function" == typeof BigInt ? BigInt.asUintN : void 0;
var zt = Number.isSafeInteger;
var Kt = Number.isFinite;
var Yt = Math.trunc;
var $t = At(0);
function qt(t2) {
  return null == t2 || "number" == typeof t2 ? t2 : "NaN" === t2 || "Infinity" === t2 || "-Infinity" === t2 ? Number(t2) : void 0;
}
function Jt(t2) {
  return null == t2 || "boolean" == typeof t2 ? t2 : "number" == typeof t2 ? !!t2 : void 0;
}
var Zt = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
function Qt(t2) {
  switch (typeof t2) {
    case "bigint":
      return true;
    case "number":
      return Kt(t2);
    case "string":
      return Zt.test(t2);
    default:
      return false;
  }
}
function te(t2) {
  if (null == t2) return t2;
  if ("string" == typeof t2 && t2) t2 = +t2;
  else if ("number" != typeof t2) return;
  return Kt(t2) ? 0 | t2 : void 0;
}
function ee(t2) {
  if (null == t2) return t2;
  if ("string" == typeof t2 && t2) t2 = +t2;
  else if ("number" != typeof t2) return;
  return Kt(t2) ? t2 >>> 0 : void 0;
}
function ne(t2) {
  if ("-" === t2[0]) return false;
  const e2 = t2.length;
  return e2 < 20 || 20 === e2 && Number(t2.substring(0, 6)) < 184467;
}
function re(t2) {
  const e2 = t2.length;
  return "-" === t2[0] ? e2 < 20 || 20 === e2 && Number(t2.substring(0, 7)) > -922337 : e2 < 19 || 19 === e2 && Number(t2.substring(0, 6)) < 922337;
}
function ie(t2) {
  return re(t2) ? t2 : (Vt(t2), jt());
}
function se(t2) {
  return t2 = Yt(t2), zt(t2) || (Ot(t2), t2 = Nt(Mt, Pt)), t2;
}
function oe(t2) {
  var e2 = Yt(Number(t2));
  return zt(e2) ? String(e2) : (-1 !== (e2 = t2.indexOf(".")) && (t2 = t2.substring(0, e2)), ie(t2));
}
function ae(t2) {
  var e2 = Yt(Number(t2));
  return zt(e2) ? At(e2) : (-1 !== (e2 = t2.indexOf(".")) && (t2 = t2.substring(0, e2)), at() ? At(Ht(64, BigInt(t2))) : At(ie(t2)));
}
function ce(t2) {
  if (zt(t2)) t2 = At(se(t2));
  else {
    if (t2 = Yt(t2), zt(t2)) t2 = String(t2);
    else {
      const e2 = String(t2);
      re(e2) ? t2 = e2 : (Ot(t2), t2 = jt());
    }
    t2 = At(t2);
  }
  return t2;
}
function he(t2) {
  return null == t2 ? t2 : "bigint" == typeof t2 ? (bt(t2) ? t2 = Number(t2) : (t2 = Ht(64, t2), t2 = bt(t2) ? Number(t2) : String(t2)), t2) : Qt(t2) ? "number" == typeof t2 ? se(t2) : oe(t2) : void 0;
}
function ue(t2) {
  if (null == t2) return t2;
  var e2 = typeof t2;
  if ("bigint" === e2) return String(Wt(64, t2));
  if (Qt(t2)) {
    if ("string" === e2) return e2 = Yt(Number(t2)), zt(e2) && e2 >= 0 ? t2 = String(e2) : (-1 !== (e2 = t2.indexOf(".")) && (t2 = t2.substring(0, e2)), ne(t2) || (Vt(t2), t2 = Bt(Mt, Pt))), t2;
    if ("number" === e2) return (t2 = Yt(t2)) >= 0 && zt(t2) ? t2 : (function(t3) {
      if (t3 < 0) {
        Ot(t3);
        var e3 = Bt(Mt, Pt);
        return t3 = Number(e3), zt(t3) ? t3 : e3;
      }
      return ne(e3 = String(t3)) ? e3 : (Ot(t3), Dt(Mt, Pt));
    })(t2);
  }
}
function le(t2) {
  if ("string" != typeof t2) throw Error();
  return t2;
}
function de(t2) {
  if (null != t2 && "string" != typeof t2) throw Error();
  return t2;
}
function fe(t2) {
  return null == t2 || "string" == typeof t2 ? t2 : void 0;
}
function pe(t2, e2, n2, r2) {
  if (null != t2 && "object" == typeof t2 && t2.W === ut) return t2;
  if (!Array.isArray(t2)) return n2 ? 2 & r2 ? ((t2 = e2[Y]) || (it((t2 = new e2()).u), t2 = e2[Y] = t2), e2 = t2) : e2 = new e2() : e2 = void 0, e2;
  let i2 = n2 = 0 | t2[Q];
  return 0 === i2 && (i2 |= 32 & r2), i2 |= 2 & r2, i2 !== n2 && rt(t2, i2), new e2(t2);
}
function ge(t2, e2, n2) {
  if (e2) t: {
    if (!Qt(e2 = t2)) throw X("int64");
    switch (typeof e2) {
      case "string":
        e2 = ae(e2);
        break t;
      case "bigint":
        e2 = At(Ht(64, e2));
        break t;
      default:
        e2 = ce(e2);
    }
  }
  else t2 = typeof (e2 = t2), e2 = null == e2 ? e2 : "bigint" === t2 ? At(Ht(64, e2)) : Qt(e2) ? "string" === t2 ? ae(e2) : ce(e2) : void 0;
  return null == (t2 = e2) ? n2 ? $t : void 0 : t2;
}
function me(t2) {
  return t2;
}
var ye = {};
var _e = (function() {
  try {
    return w(new class extends Map {
      constructor() {
        super();
      }
    }()), false;
  } catch {
    return true;
  }
})();
var ve = class {
  constructor() {
    this.g = /* @__PURE__ */ new Map();
  }
  get(t2) {
    return this.g.get(t2);
  }
  set(t2, e2) {
    return this.g.set(t2, e2), this.size = this.g.size, this;
  }
  delete(t2) {
    return t2 = this.g.delete(t2), this.size = this.g.size, t2;
  }
  clear() {
    this.g.clear(), this.size = this.g.size;
  }
  has(t2) {
    return this.g.has(t2);
  }
  entries() {
    return this.g.entries();
  }
  keys() {
    return this.g.keys();
  }
  values() {
    return this.g.values();
  }
  forEach(t2, e2) {
    return this.g.forEach(t2, e2);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
var Ee = _e ? (Object.setPrototypeOf(ve.prototype, Map.prototype), Object.defineProperties(ve.prototype, { size: { value: 0, configurable: true, enumerable: true, writable: true } }), ve) : class extends Map {
  constructor() {
    super();
  }
};
function we(t2) {
  return t2;
}
function Te(t2) {
  if (2 & t2.M) throw Error("Cannot mutate an immutable Map");
}
var Ae = class extends Ee {
  constructor(t2, e2, n2 = we, r2 = we) {
    super();
    let i2 = 0 | t2[Q];
    i2 |= 64, rt(t2, i2), this.M = i2, this.I = e2, this.S = n2, this.X = this.I ? be : r2;
    for (let s2 = 0; s2 < t2.length; s2++) {
      const o2 = t2[s2], a2 = n2(o2[0], false, true);
      let c2 = o2[1];
      e2 ? void 0 === c2 && (c2 = null) : c2 = r2(o2[1], false, true, void 0, void 0, i2), super.set(a2, c2);
    }
  }
  La() {
    var t2 = Ce;
    if (0 !== this.size) return Array.from(super.entries(), ((e2) => (e2[0] = t2(e2[0]), e2[1] = t2(e2[1]), e2)));
  }
  da(t2 = ke) {
    const e2 = [], n2 = super.entries();
    for (var r2; !(r2 = n2.next()).done; ) (r2 = r2.value)[0] = t2(r2[0]), r2[1] = t2(r2[1]), e2.push(r2);
    return e2;
  }
  clear() {
    Te(this), super.clear();
  }
  delete(t2) {
    return Te(this), super.delete(this.S(t2, true, false));
  }
  entries() {
    if (this.I) {
      var t2 = super.keys();
      t2 = new gt(t2, Se, this);
    } else t2 = super.entries();
    return t2;
  }
  values() {
    if (this.I) {
      var t2 = super.keys();
      t2 = new gt(t2, Ae.prototype.get, this);
    } else t2 = super.values();
    return t2;
  }
  forEach(t2, e2) {
    this.I ? super.forEach(((n2, r2, i2) => {
      t2.call(e2, i2.get(r2), r2, i2);
    })) : super.forEach(t2, e2);
  }
  set(t2, e2) {
    return Te(this), null == (t2 = this.S(t2, true, false)) ? this : null == e2 ? (super.delete(t2), this) : super.set(t2, this.X(e2, true, true, this.I, false, this.M));
  }
  Ja(t2) {
    const e2 = this.S(t2[0], false, true);
    t2 = t2[1], t2 = this.I ? void 0 === t2 ? null : t2 : this.X(t2, false, true, void 0, false, this.M), super.set(e2, t2);
  }
  has(t2) {
    return super.has(this.S(t2, false, false));
  }
  get(t2) {
    t2 = this.S(t2, false, false);
    const e2 = super.get(t2);
    if (void 0 !== e2) {
      var n2 = this.I;
      return n2 ? ((n2 = this.X(e2, false, true, n2, this.pa, this.M)) !== e2 && super.set(t2, n2), n2) : e2;
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
function be(t2, e2, n2, r2, i2, s2) {
  return t2 = pe(t2, r2, n2, s2), i2 && (t2 = je(t2)), t2;
}
function ke(t2) {
  return t2;
}
function Se(t2) {
  return [t2, this.get(t2)];
}
var xe;
var Le;
var Re;
var Fe;
function Ie() {
  return xe ||= new Ae(it([]), void 0, void 0, void 0, ye);
}
function Me(t2, e2, n2, r2, i2) {
  if (null != t2) {
    if (Array.isArray(t2)) {
      const s2 = 0 | t2[Q];
      return 0 === t2.length && 1 & s2 ? void 0 : i2 && 2 & s2 ? t2 : Pe(t2, e2, n2, void 0 !== r2, i2);
    }
    return e2(t2, r2);
  }
}
function Pe(t2, e2, n2, r2, i2) {
  const s2 = r2 || n2 ? 0 | t2[Q] : 0, o2 = r2 ? !!(32 & s2) : void 0;
  let a2 = 0;
  const c2 = (r2 = ct(t2)).length;
  for (let t3 = 0; t3 < c2; t3++) {
    var h2 = r2[t3];
    if (t3 === c2 - 1 && lt(h2)) {
      var u2 = e2, l = n2, d = o2, f = i2;
      let t4;
      for (let e3 in h2) {
        const n3 = Me(h2[e3], u2, l, d, f);
        null != n3 && ((t4 ??= {})[e3] = n3);
      }
      h2 = t4;
    } else h2 = Me(r2[t3], e2, n2, o2, i2);
    r2[t3] = h2, null != h2 && (a2 = t3 + 1);
  }
  return a2 < c2 && (r2.length = a2), n2 && ((t2 = mt(t2)) && (r2[q] = ct(t2)), n2(s2, r2)), r2;
}
function Ce(t2) {
  return Me(t2, Oe, void 0, void 0, false);
}
function Oe(t2) {
  switch (typeof t2) {
    case "number":
      return Number.isFinite(t2) ? t2 : "" + t2;
    case "bigint":
      return bt(t2) ? Number(t2) : "" + t2;
    case "boolean":
      return t2 ? 1 : 0;
    case "object":
      if (C(t2)) return C(t2) && H(Z), R(t2);
      if (t2.W === ut) return Ue(t2);
      if (t2 instanceof N) {
        const e2 = t2.g;
        return null == e2 ? "" : "string" == typeof e2 ? e2 : t2.g = R(e2);
      }
      return t2 instanceof Ae ? t2.La() : void 0;
  }
  return t2;
}
function Ue(t2) {
  var e2 = t2.u;
  t2 = Pe(e2, Oe, void 0, void 0, false);
  var n2 = 0 | e2[Q];
  if ((e2 = t2.length) && !(512 & n2)) {
    var r2 = t2[e2 - 1], i2 = false;
    lt(r2) ? (e2--, i2 = true) : r2 = void 0;
    var s2 = e2 - (n2 = 512 & n2 ? 0 : -1), o2 = (Le ?? me)(s2, n2, t2, r2);
    if (r2 && (t2[e2] = void 0), s2 < o2 && r2) {
      for (var a2 in s2 = true, r2) {
        const c2 = +a2;
        c2 <= o2 ? (t2[i2 = c2 + n2] = r2[a2], e2 = Math.max(i2 + 1, e2), i2 = false, delete r2[a2]) : s2 = false;
      }
      s2 && (r2 = void 0);
    }
    for (s2 = e2 - 1; e2 > 0; s2 = e2 - 1) if (null == (a2 = t2[s2])) e2--, i2 = true;
    else {
      if (!((s2 -= n2) >= o2)) break;
      (r2 ??= {})[s2] = a2, e2--, i2 = true;
    }
    i2 && (t2.length = e2), r2 && t2.push(r2);
  }
  return t2;
}
function De(t2, e2, n2) {
  return t2 = Ne(t2, e2[0], e2[1], n2 ? 1 : 2), e2 !== Re && n2 && nt(t2, 8192), t2;
}
function Ne(t2, e2, n2, r2) {
  if (null == t2) {
    var i2 = 96;
    n2 ? (t2 = [n2], i2 |= 512) : t2 = [], e2 && (i2 = -16760833 & i2 | (1023 & e2) << 14);
  } else {
    if (!Array.isArray(t2)) throw Error("narr");
    if (8192 & (i2 = 0 | t2[Q]) || !(64 & i2) || 2 & i2 || H(J), 1024 & i2) throw Error("farr");
    if (64 & i2) return t2;
    if (1 === r2 || 2 === r2 || (i2 |= 64), n2 && (i2 |= 512, n2 !== t2[0])) throw Error("mid");
    t: {
      var s2 = (n2 = t2).length;
      if (s2) {
        var o2 = s2 - 1;
        if (lt(r2 = n2[o2])) {
          if ((o2 -= e2 = 512 & (i2 |= 256) ? 0 : -1) >= 1024) throw Error("pvtlmt");
          for (var a2 in r2) (s2 = +a2) < o2 && (n2[s2 + e2] = r2[a2], delete r2[a2]);
          i2 = -16760833 & i2 | (1023 & o2) << 14;
          break t;
        }
      }
      if (e2) {
        if ((a2 = Math.max(e2, s2 - (512 & i2 ? 0 : -1))) > 1024) throw Error("spvt");
        i2 = -16760833 & i2 | (1023 & a2) << 14;
      }
    }
  }
  return rt(t2, i2), t2;
}
function Be(t2, e2, n2 = ot) {
  if (null != t2) {
    if (x && t2 instanceof Uint8Array) return e2 ? t2 : new Uint8Array(t2);
    if (Array.isArray(t2)) {
      var r2 = 0 | t2[Q];
      return 2 & r2 ? t2 : (e2 &&= 0 === r2 || !!(32 & r2) && !(64 & r2 || !(16 & r2)), e2 ? (rt(t2, 34 | r2), 4 & r2 && Object.freeze(t2), t2) : Pe(t2, Be, 4 & r2 ? ot : n2, true, true));
    }
    return t2.W === ut ? t2 = 2 & (r2 = 0 | (n2 = t2.u)[Q]) ? t2 : new t2.constructor(Ge(n2, r2, true)) : t2 instanceof Ae && !(2 & t2.M) && (n2 = it(t2.da(Be)), t2 = new Ae(n2, t2.I, t2.S, t2.X)), t2;
  }
}
function Ge(t2, e2, n2) {
  const r2 = n2 || 2 & e2 ? ot : st, i2 = !!(32 & e2);
  return t2 = (function(t3, e3, n3) {
    const r3 = ct(t3);
    var i3 = r3.length;
    const s2 = 256 & e3 ? r3[i3 - 1] : void 0;
    for (i3 += s2 ? -1 : 0, e3 = 512 & e3 ? 1 : 0; e3 < i3; e3++) r3[e3] = n3(r3[e3]);
    if (s2) {
      e3 = r3[e3] = {};
      for (const t4 in s2) e3[t4] = n3(s2[t4]);
    }
    return (t3 = mt(t3)) && (r3[q] = ct(t3)), r3;
  })(t2, e2, ((t3) => Be(t3, i2, r2))), nt(t2, 32 | (n2 ? 2 : 0)), t2;
}
function je(t2) {
  const e2 = t2.u, n2 = 0 | e2[Q];
  return 2 & n2 ? new t2.constructor(Ge(e2, n2, false)) : t2;
}
function Ve(t2, e2) {
  return Xe(t2 = t2.u, 0 | t2[Q], e2);
}
function Xe(t2, e2, n2) {
  if (-1 === n2) return null;
  const r2 = n2 + (512 & e2 ? 0 : -1), i2 = t2.length - 1;
  return r2 >= i2 && 256 & e2 ? t2[i2][n2] : r2 <= i2 ? t2[r2] : void 0;
}
function He(t2, e2, n2) {
  const r2 = t2.u;
  let i2 = 0 | r2[Q];
  return pt(i2), We(r2, i2, e2, n2), t2;
}
function We(t2, e2, n2, r2) {
  const i2 = 512 & e2 ? 0 : -1, s2 = n2 + i2;
  var o2 = t2.length - 1;
  return s2 >= o2 && 256 & e2 ? (t2[o2][n2] = r2, e2) : s2 <= o2 ? (t2[s2] = r2, e2) : (void 0 !== r2 && (n2 >= (o2 = e2 >> 14 & 1023 || 536870912) ? null != r2 && (t2[o2 + i2] = { [n2]: r2 }, rt(t2, e2 |= 256)) : t2[s2] = r2), e2);
}
function ze(t2, e2) {
  let n2 = 0 | (t2 = t2.u)[Q];
  const r2 = Xe(t2, n2, e2), i2 = qt(r2);
  return null != i2 && i2 !== r2 && We(t2, n2, e2, i2), i2;
}
function Ke(t2) {
  let e2 = 0 | (t2 = t2.u)[Q];
  const n2 = Xe(t2, e2, 1), r2 = dt(n2, true);
  return null != r2 && r2 !== n2 && We(t2, e2, 1, r2), r2;
}
function Ye() {
  return void 0 === yt ? 2 : 4;
}
function $e(t2, e2, n2, r2, i2) {
  const s2 = t2.u, o2 = 2 & (t2 = 0 | s2[Q]) ? 1 : r2;
  i2 = !!i2;
  let a2 = 0 | (r2 = qe(s2, t2, e2))[Q];
  if (!(4 & a2)) {
    4 & a2 && (r2 = ct(r2), a2 = pn(a2, t2), t2 = We(s2, t2, e2, r2));
    let i3 = 0, o3 = 0;
    for (; i3 < r2.length; i3++) {
      const t3 = n2(r2[i3]);
      null != t3 && (r2[o3++] = t3);
    }
    o3 < i3 && (r2.length = o3), a2 = Je(a2, t2), n2 = -2049 & (20 | a2), a2 = n2 &= -4097, rt(r2, a2), 2 & a2 && Object.freeze(r2);
  }
  return 1 === o2 || 4 === o2 && 32 & a2 ? Ze(a2) || (i2 = a2, a2 |= 2, a2 !== i2 && rt(r2, a2), Object.freeze(r2)) : (2 === o2 && Ze(a2) && (r2 = ct(r2), a2 = pn(a2, t2), a2 = gn(a2, t2, i2), rt(r2, a2), t2 = We(s2, t2, e2, r2)), Ze(a2) || (e2 = a2, a2 = gn(a2, t2, i2), a2 !== e2 && rt(r2, a2))), r2;
}
function qe(t2, e2, n2) {
  return t2 = Xe(t2, e2, n2), Array.isArray(t2) ? t2 : ht;
}
function Je(t2, e2) {
  return 0 === t2 && (t2 = pn(t2, e2)), 1 | t2;
}
function Ze(t2) {
  return !!(2 & t2) && !!(4 & t2) || !!(1024 & t2);
}
function Qe(t2) {
  t2 = ct(t2);
  for (let e2 = 0; e2 < t2.length; e2++) {
    const n2 = t2[e2] = ct(t2[e2]);
    Array.isArray(n2[1]) && (n2[1] = it(n2[1]));
  }
  return t2;
}
function tn(t2, e2, n2, r2) {
  let i2 = 0 | (t2 = t2.u)[Q];
  pt(i2), We(t2, i2, e2, ("0" === r2 ? 0 === Number(n2) : n2 === r2) ? void 0 : n2);
}
function en(t2, e2, n2, r2) {
  pt(e2);
  let i2 = qe(t2, e2, n2);
  const s2 = i2 !== ht;
  if (64 & e2 || !(8192 & e2) || !s2) {
    const o2 = s2 ? 0 | i2[Q] : 0;
    let a2 = o2;
    (!s2 || 2 & a2 || Ze(a2) || 4 & a2 && !(32 & a2)) && (i2 = ct(i2), a2 = pn(a2, e2), e2 = We(t2, e2, n2, i2)), a2 = -13 & Je(a2, e2), a2 = gn(r2 ? -17 & a2 : 16 | a2, e2, true), a2 !== o2 && rt(i2, a2);
  }
  return i2;
}
function nn(t2, e2) {
  var n2 = Ts;
  return on(rn(t2 = t2.u), t2, 0 | t2[Q], n2) === e2 ? e2 : -1;
}
function rn(t2) {
  if (W) return t2[$] ?? (t2[$] = /* @__PURE__ */ new Map());
  if ($ in t2) return t2[$];
  const e2 = /* @__PURE__ */ new Map();
  return Object.defineProperty(t2, $, { value: e2 }), e2;
}
function sn(t2, e2, n2, r2) {
  const i2 = rn(t2), s2 = on(i2, t2, e2, n2);
  return s2 !== r2 && (s2 && (e2 = We(t2, e2, s2)), i2.set(n2, r2)), e2;
}
function on(t2, e2, n2, r2) {
  let i2 = t2.get(r2);
  if (null != i2) return i2;
  i2 = 0;
  for (let t3 = 0; t3 < r2.length; t3++) {
    const s2 = r2[t3];
    null != Xe(e2, n2, s2) && (0 !== i2 && (n2 = We(e2, n2, i2)), i2 = s2);
  }
  return t2.set(r2, i2), i2;
}
function an(t2, e2, n2) {
  let r2 = 0 | t2[Q];
  const i2 = Xe(t2, r2, n2);
  let s2;
  if (null != i2 && i2.W === ut) return (e2 = je(i2)) !== i2 && We(t2, r2, n2, e2), e2.u;
  if (Array.isArray(i2)) {
    const t3 = 0 | i2[Q];
    s2 = 2 & t3 ? De(Ge(i2, t3, false), e2, true) : 64 & t3 ? i2 : De(s2, e2, true);
  } else s2 = De(void 0, e2, true);
  return s2 !== i2 && We(t2, r2, n2, s2), s2;
}
function cn(t2, e2, n2) {
  let r2 = 0 | (t2 = t2.u)[Q];
  const i2 = Xe(t2, r2, n2);
  return (e2 = pe(i2, e2, false, r2)) !== i2 && null != e2 && We(t2, r2, n2, e2), e2;
}
function hn(t2, e2, n2) {
  if (null == (e2 = cn(t2, e2, n2))) return e2;
  let r2 = 0 | (t2 = t2.u)[Q];
  if (!(2 & r2)) {
    const i2 = je(e2);
    i2 !== e2 && We(t2, r2, n2, e2 = i2);
  }
  return e2;
}
function un(t2, e2, n2, r2, i2, s2, o2) {
  t2 = t2.u;
  var a2 = !!(2 & e2);
  const c2 = a2 ? 1 : i2;
  s2 = !!s2, o2 &&= !a2;
  var h2 = 0 | (i2 = qe(t2, e2, r2))[Q];
  if (!(a2 = !!(4 & h2))) {
    var u2 = i2, l = e2;
    const t3 = !!(2 & (h2 = Je(h2, e2)));
    t3 && (l |= 2);
    let r3 = !t3, s3 = true, o3 = 0, a3 = 0;
    for (; o3 < u2.length; o3++) {
      const e3 = pe(u2[o3], n2, false, l);
      if (e3 instanceof n2) {
        if (!t3) {
          const t4 = !!(2 & (0 | e3.u[Q]));
          r3 &&= !t4, s3 &&= t4;
        }
        u2[a3++] = e3;
      }
    }
    a3 < o3 && (u2.length = a3), h2 |= 4, h2 = s3 ? 16 | h2 : -17 & h2, rt(u2, h2 = r3 ? 8 | h2 : -9 & h2), t3 && Object.freeze(u2);
  }
  if (o2 && !(8 & h2 || !i2.length && (1 === c2 || 4 === c2 && 32 & h2))) {
    for (Ze(h2) && (i2 = ct(i2), h2 = pn(h2, e2), e2 = We(t2, e2, r2, i2)), n2 = i2, o2 = h2, u2 = 0; u2 < n2.length; u2++) (h2 = n2[u2]) !== (l = je(h2)) && (n2[u2] = l);
    o2 |= 8, rt(n2, o2 = n2.length ? -17 & o2 : 16 | o2), h2 = o2;
  }
  return 1 === c2 || 4 === c2 && 32 & h2 ? Ze(h2) || (e2 = h2, (h2 |= !i2.length || 16 & h2 && (!a2 || 32 & h2) ? 2 : 1024) !== e2 && rt(i2, h2), Object.freeze(i2)) : (2 === c2 && Ze(h2) && (rt(i2 = ct(i2), h2 = gn(h2 = pn(h2, e2), e2, s2)), e2 = We(t2, e2, r2, i2)), Ze(h2) || (r2 = h2, (h2 = gn(h2, e2, s2)) !== r2 && rt(i2, h2))), i2;
}
function ln(t2, e2, n2) {
  const r2 = 0 | t2.u[Q];
  return un(t2, r2, e2, n2, Ye(), false, !(2 & r2));
}
function dn(t2, e2, n2, r2) {
  return null == r2 && (r2 = void 0), He(t2, n2, r2);
}
function fn(t2, e2, n2, r2) {
  null == r2 && (r2 = void 0);
  t: {
    let i2 = 0 | (t2 = t2.u)[Q];
    if (pt(i2), null == r2) {
      const r3 = rn(t2);
      if (on(r3, t2, i2, n2) !== e2) break t;
      r3.set(n2, 0);
    } else i2 = sn(t2, i2, n2, e2);
    We(t2, i2, e2, r2);
  }
}
function pn(t2, e2) {
  return -1025 & (t2 = 32 | (2 & e2 ? 2 | t2 : -3 & t2));
}
function gn(t2, e2, n2) {
  return 32 & e2 && n2 || (t2 &= -33), t2;
}
function mn(t2, e2, n2) {
  pt(0 | t2.u[Q]), $e(t2, e2, fe, 2, true).push(le(n2));
}
function yn(t2, e2, n2, r2) {
  const i2 = 0 | t2.u[Q];
  pt(i2), t2 = un(t2, i2, n2, e2, 2, true), r2 = null != r2 ? r2 : new n2(), t2.push(r2), t2[Q] = 2 & (0 | r2.u[Q]) ? -9 & t2[Q] : -17 & t2[Q];
}
function _n(t2, e2) {
  return te(Ve(t2, e2));
}
function vn(t2, e2) {
  return fe(Ve(t2, e2));
}
function En(t2, e2) {
  return ze(t2, e2) ?? 0;
}
function wn(t2, e2, n2) {
  if (null != n2 && "boolean" != typeof n2) throw t2 = typeof n2, Error(`Expected boolean but got ${"object" != t2 ? t2 : n2 ? Array.isArray(n2) ? "array" : t2 : "null"}: ${n2}`);
  He(t2, e2, n2);
}
function Tn(t2, e2, n2) {
  if (null != n2) {
    if ("number" != typeof n2) throw X("int32");
    if (!Kt(n2)) throw X("int32");
    n2 |= 0;
  }
  He(t2, e2, n2);
}
function An(t2, e2, n2) {
  if (null != n2 && "number" != typeof n2) throw Error(`Value of float/double field must be a number, found ${typeof n2}: ${n2}`);
  He(t2, e2, n2);
}
function bn(t2, e2, n2) {
  {
    const o2 = t2.u;
    let a2 = 0 | o2[Q];
    if (pt(a2), null == n2) We(o2, a2, e2);
    else {
      var r2 = t2 = 0 | n2[Q], i2 = Ze(t2), s2 = i2 || Object.isFrozen(n2);
      for (i2 || (t2 = 0), s2 || (n2 = ct(n2), r2 = 0, t2 = gn(t2 = pn(t2, a2), a2, true), s2 = false), t2 |= 21, i2 = 0; i2 < n2.length; i2++) {
        const e3 = n2[i2], o3 = le(e3);
        Object.is(e3, o3) || (s2 && (n2 = ct(n2), r2 = 0, t2 = gn(t2 = pn(t2, a2), a2, true), s2 = false), n2[i2] = o3);
      }
      t2 !== r2 && (s2 && (n2 = ct(n2), t2 = gn(t2 = pn(t2, a2), a2, true)), rt(n2, t2)), We(o2, a2, e2, n2);
    }
  }
}
function kn(t2, e2) {
  return Error(`Invalid wire type: ${t2} (at position ${e2})`);
}
function Sn() {
  return Error("Failed to read varint, encoding is invalid.");
}
function xn(t2, e2) {
  return Error(`Tried to read past the end of the data ${e2} > ${t2}`);
}
function Ln(t2) {
  if ("string" == typeof t2) return { buffer: P(t2), O: false };
  if (Array.isArray(t2)) return { buffer: new Uint8Array(t2), O: false };
  if (t2.constructor === Uint8Array) return { buffer: t2, O: false };
  if (t2.constructor === ArrayBuffer) return { buffer: new Uint8Array(t2), O: false };
  if (t2.constructor === N) return { buffer: D(t2) || new Uint8Array(0), O: true };
  if (t2 instanceof Uint8Array) return { buffer: new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength), O: false };
  throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
}
function Rn(t2, e2) {
  let n2, r2 = 0, i2 = 0, s2 = 0;
  const o2 = t2.h;
  let a2 = t2.g;
  do {
    n2 = o2[a2++], r2 |= (127 & n2) << s2, s2 += 7;
  } while (s2 < 32 && 128 & n2);
  for (s2 > 32 && (i2 |= (127 & n2) >> 4), s2 = 3; s2 < 32 && 128 & n2; s2 += 7) n2 = o2[a2++], i2 |= (127 & n2) << s2;
  if (Dn(t2, a2), n2 < 128) return e2(r2 >>> 0, i2 >>> 0);
  throw Sn();
}
function Fn(t2) {
  let e2 = 0, n2 = t2.g;
  const r2 = n2 + 10, i2 = t2.h;
  for (; n2 < r2; ) {
    const r3 = i2[n2++];
    if (e2 |= r3, 0 == (128 & r3)) return Dn(t2, n2), !!(127 & e2);
  }
  throw Sn();
}
function In(t2) {
  const e2 = t2.h;
  let n2 = t2.g, r2 = e2[n2++], i2 = 127 & r2;
  if (128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 7, 128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 14, 128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 21, 128 & r2 && (r2 = e2[n2++], i2 |= r2 << 28, 128 & r2 && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++]))))) throw Sn();
  return Dn(t2, n2), i2;
}
function Mn(t2) {
  return In(t2) >>> 0;
}
function Pn(t2) {
  var e2 = t2.h;
  const n2 = t2.g, r2 = e2[n2], i2 = e2[n2 + 1], s2 = e2[n2 + 2];
  return e2 = e2[n2 + 3], Dn(t2, t2.g + 4), (r2 << 0 | i2 << 8 | s2 << 16 | e2 << 24) >>> 0;
}
function Cn(t2) {
  var e2 = Pn(t2);
  t2 = 2 * (e2 >> 31) + 1;
  const n2 = e2 >>> 23 & 255;
  return e2 &= 8388607, 255 == n2 ? e2 ? NaN : t2 * (1 / 0) : 0 == n2 ? 1401298464324817e-60 * t2 * e2 : t2 * Math.pow(2, n2 - 150) * (e2 + 8388608);
}
function On(t2) {
  return In(t2);
}
function Un(t2, e2, { aa: n2 = false } = {}) {
  t2.aa = n2, e2 && (e2 = Ln(e2), t2.h = e2.buffer, t2.m = e2.O, t2.j = 0, t2.l = t2.h.length, t2.g = t2.j);
}
function Dn(t2, e2) {
  if (t2.g = e2, e2 > t2.l) throw xn(t2.l, e2);
}
function Nn(t2, e2) {
  if (e2 < 0) throw Error(`Tried to read a negative byte length: ${e2}`);
  const n2 = t2.g, r2 = n2 + e2;
  if (r2 > t2.l) throw xn(e2, t2.l - n2);
  return t2.g = r2, n2;
}
function Bn(t2, e2) {
  if (0 == e2) return U();
  var n2 = Nn(t2, e2);
  return t2.aa && t2.m ? n2 = t2.h.subarray(n2, n2 + e2) : (t2 = t2.h, n2 = n2 === (e2 = n2 + e2) ? new Uint8Array(0) : Ft ? t2.slice(n2, e2) : new Uint8Array(t2.subarray(n2, e2))), 0 == n2.length ? U() : new N(n2, O);
}
Ae.prototype.toJSON = void 0;
var Gn = [];
function jn(t2) {
  var e2 = t2.g;
  if (e2.g == e2.l) return false;
  t2.l = t2.g.g;
  var n2 = Mn(t2.g);
  if (e2 = n2 >>> 3, !((n2 &= 7) >= 0 && n2 <= 5)) throw kn(n2, t2.l);
  if (e2 < 1) throw Error(`Invalid field number: ${e2} (at position ${t2.l})`);
  return t2.m = e2, t2.h = n2, true;
}
function Vn(t2) {
  switch (t2.h) {
    case 0:
      0 != t2.h ? Vn(t2) : Fn(t2.g);
      break;
    case 1:
      Dn(t2 = t2.g, t2.g + 8);
      break;
    case 2:
      if (2 != t2.h) Vn(t2);
      else {
        var e2 = Mn(t2.g);
        Dn(t2 = t2.g, t2.g + e2);
      }
      break;
    case 5:
      Dn(t2 = t2.g, t2.g + 4);
      break;
    case 3:
      for (e2 = t2.m; ; ) {
        if (!jn(t2)) throw Error("Unmatched start-group tag: stream EOF");
        if (4 == t2.h) {
          if (t2.m != e2) throw Error("Unmatched end-group tag");
          break;
        }
        Vn(t2);
      }
      break;
    default:
      throw kn(t2.h, t2.l);
  }
}
function Xn(t2, e2, n2) {
  const r2 = t2.g.l, i2 = Mn(t2.g), s2 = t2.g.g + i2;
  let o2 = s2 - r2;
  if (o2 <= 0 && (t2.g.l = s2, n2(e2, t2, void 0, void 0, void 0), o2 = s2 - t2.g.g), o2) throw Error(`Message parsing ended unexpectedly. Expected to read ${i2} bytes, instead read ${i2 - o2} bytes, either the data ended unexpectedly or the message misreported its own length`);
  return t2.g.g = s2, t2.g.l = r2, e2;
}
function Hn(t2) {
  var o2 = Mn(t2.g), a2 = Nn(t2 = t2.g, o2);
  if (t2 = t2.h, s) {
    var c2, h2 = t2;
    (c2 = i) || (c2 = i = new TextDecoder("utf-8", { fatal: true })), o2 = a2 + o2, h2 = 0 === a2 && o2 === h2.length ? h2 : h2.subarray(a2, o2);
    try {
      var u2 = c2.decode(h2);
    } catch (t3) {
      if (void 0 === r) {
        try {
          c2.decode(new Uint8Array([128]));
        } catch (t4) {
        }
        try {
          c2.decode(new Uint8Array([97])), r = true;
        } catch (t4) {
          r = false;
        }
      }
      throw !r && (i = void 0), t3;
    }
  } else {
    o2 = (u2 = a2) + o2, a2 = [];
    let r2, i2 = null;
    for (; u2 < o2; ) {
      var l = t2[u2++];
      l < 128 ? a2.push(l) : l < 224 ? u2 >= o2 ? e() : (r2 = t2[u2++], l < 194 || 128 != (192 & r2) ? (u2--, e()) : a2.push((31 & l) << 6 | 63 & r2)) : l < 240 ? u2 >= o2 - 1 ? e() : (r2 = t2[u2++], 128 != (192 & r2) || 224 === l && r2 < 160 || 237 === l && r2 >= 160 || 128 != (192 & (c2 = t2[u2++])) ? (u2--, e()) : a2.push((15 & l) << 12 | (63 & r2) << 6 | 63 & c2)) : l <= 244 ? u2 >= o2 - 2 ? e() : (r2 = t2[u2++], 128 != (192 & r2) || r2 - 144 + (l << 28) >> 30 != 0 || 128 != (192 & (c2 = t2[u2++])) || 128 != (192 & (h2 = t2[u2++])) ? (u2--, e()) : (l = (7 & l) << 18 | (63 & r2) << 12 | (63 & c2) << 6 | 63 & h2, l -= 65536, a2.push(55296 + (l >> 10 & 1023), 56320 + (1023 & l)))) : e(), a2.length >= 8192 && (i2 = n(i2, a2), a2.length = 0);
    }
    u2 = n(i2, a2);
  }
  return u2;
}
function Wn(t2) {
  const e2 = Mn(t2.g);
  return Bn(t2.g, e2);
}
function zn(t2, e2, n2) {
  var r2 = Mn(t2.g);
  for (r2 = t2.g.g + r2; t2.g.g < r2; ) n2.push(e2(t2.g));
}
var Kn = [];
function Yn(t2, e2, n2) {
  e2.g ? e2.m(t2, e2.g, e2.h, n2) : e2.m(t2, e2.h, n2);
}
var $n = class {
  constructor(t2, e2) {
    this.u = Ne(t2, e2);
  }
  toJSON() {
    try {
      var t2 = Ue(this);
    } finally {
      Le = void 0;
    }
    return t2;
  }
  l() {
    var t2 = _o;
    return t2.g ? t2.l(this, t2.g, t2.h) : t2.l(this, t2.h, t2.defaultValue);
  }
  clone() {
    const t2 = this.u;
    return new this.constructor(Ge(t2, 0 | t2[Q], false));
  }
  O() {
    return !!(2 & (0 | this.u[Q]));
  }
};
function qn(t2) {
  return t2 ? /^\d+$/.test(t2) ? (Vt(t2), new Jn(Mt, Pt)) : null : Zn ||= new Jn(0, 0);
}
$n.prototype.W = ut, $n.prototype.toString = function() {
  return this.u.toString();
};
var Jn = class {
  constructor(t2, e2) {
    this.h = t2 >>> 0, this.g = e2 >>> 0;
  }
};
var Zn;
function Qn(t2) {
  return t2 ? /^-?\d+$/.test(t2) ? (Vt(t2), new tr(Mt, Pt)) : null : er ||= new tr(0, 0);
}
var tr = class {
  constructor(t2, e2) {
    this.h = t2 >>> 0, this.g = e2 >>> 0;
  }
};
var er;
function nr(t2, e2, n2) {
  for (; n2 > 0 || e2 > 127; ) t2.g.push(127 & e2 | 128), e2 = (e2 >>> 7 | n2 << 25) >>> 0, n2 >>>= 7;
  t2.g.push(e2);
}
function rr(t2, e2) {
  for (; e2 > 127; ) t2.g.push(127 & e2 | 128), e2 >>>= 7;
  t2.g.push(e2);
}
function ir(t2, e2) {
  if (e2 >= 0) rr(t2, e2);
  else {
    for (let n2 = 0; n2 < 9; n2++) t2.g.push(127 & e2 | 128), e2 >>= 7;
    t2.g.push(1);
  }
}
function sr(t2, e2) {
  t2.g.push(e2 >>> 0 & 255), t2.g.push(e2 >>> 8 & 255), t2.g.push(e2 >>> 16 & 255), t2.g.push(e2 >>> 24 & 255);
}
function or(t2, e2) {
  0 !== e2.length && (t2.l.push(e2), t2.h += e2.length);
}
function ar(t2, e2, n2) {
  rr(t2.g, 8 * e2 + n2);
}
function cr(t2, e2) {
  return ar(t2, e2, 2), e2 = t2.g.end(), or(t2, e2), e2.push(t2.h), e2;
}
function hr(t2, e2) {
  var n2 = e2.pop();
  for (n2 = t2.h + t2.g.length() - n2; n2 > 127; ) e2.push(127 & n2 | 128), n2 >>>= 7, t2.h++;
  e2.push(n2), t2.h++;
}
function ur(t2, e2, n2) {
  ar(t2, e2, 2), rr(t2.g, n2.length), or(t2, t2.g.end()), or(t2, n2);
}
function lr(t2, e2, n2, r2) {
  null != n2 && (e2 = cr(t2, e2), r2(n2, t2), hr(t2, e2));
}
function dr() {
  const t2 = class {
    constructor() {
      throw Error();
    }
  };
  return Object.setPrototypeOf(t2, t2.prototype), t2;
}
var fr = dr();
var pr = dr();
var gr = dr();
var mr = dr();
var yr = dr();
var _r = dr();
var vr = dr();
var Er = dr();
var wr = dr();
var Tr = class {
  constructor(t2, e2, n2) {
    this.g = t2, this.h = e2, t2 = fr, this.l = !!t2 && n2 === t2 || false;
  }
};
function Ar(t2, e2) {
  return new Tr(t2, e2, fr);
}
function br(t2, e2, n2, r2, i2) {
  lr(t2, n2, Or(e2, r2), i2);
}
var kr = Ar((function(t2, e2, n2, r2, i2) {
  return 2 === t2.h && (Xn(t2, an(e2, r2, n2), i2), true);
}), br);
var Sr = Ar((function(t2, e2, n2, r2, i2) {
  return 2 === t2.h && (Xn(t2, an(e2, r2, n2), i2), true);
}), br);
var xr = Symbol();
var Lr = Symbol();
var Rr = Symbol();
var Fr = Symbol();
var Ir;
var Mr;
function Pr(t2, e2, n2, r2) {
  var i2 = r2[t2];
  if (i2) return i2;
  (i2 = {}).Ma = r2, i2.T = (function(t3) {
    switch (typeof t3) {
      case "boolean":
        return Re ||= [0, void 0, true];
      case "number":
        return t3 > 0 ? void 0 : 0 === t3 ? Fe ||= [0, void 0] : [-t3, void 0];
      case "string":
        return [0, t3];
      case "object":
        return t3;
    }
  })(r2[0]);
  var s2 = r2[1];
  let o2 = 1;
  s2 && s2.constructor === Object && (i2.ga = s2, "function" == typeof (s2 = r2[++o2]) && (i2.la = true, Ir ??= s2, Mr ??= r2[o2 + 1], s2 = r2[o2 += 2]));
  const a2 = {};
  for (; s2 && Array.isArray(s2) && s2.length && "number" == typeof s2[0] && s2[0] > 0; ) {
    for (var c2 = 0; c2 < s2.length; c2++) a2[s2[c2]] = s2;
    s2 = r2[++o2];
  }
  for (c2 = 1; void 0 !== s2; ) {
    let t3;
    "number" == typeof s2 && (c2 += s2, s2 = r2[++o2]);
    var h2 = void 0;
    if (s2 instanceof Tr ? t3 = s2 : (t3 = kr, o2--), t3?.l) {
      s2 = r2[++o2], h2 = r2;
      var u2 = o2;
      "function" == typeof s2 && (s2 = s2(), h2[u2] = s2), h2 = s2;
    }
    for (u2 = c2 + 1, "number" == typeof (s2 = r2[++o2]) && s2 < 0 && (u2 -= s2, s2 = r2[++o2]); c2 < u2; c2++) {
      const r3 = a2[c2];
      h2 ? n2(i2, c2, t3, h2, r3) : e2(i2, c2, t3, r3);
    }
  }
  return r2[t2] = i2;
}
function Cr(t2) {
  return Array.isArray(t2) ? t2[0] instanceof Tr ? t2 : [Sr, t2] : [t2, void 0];
}
function Or(t2, e2) {
  return t2 instanceof $n ? t2.u : Array.isArray(t2) ? De(t2, e2, false) : void 0;
}
function Ur(t2, e2, n2, r2) {
  const i2 = n2.g;
  t2[e2] = r2 ? (t3, e3, n3) => i2(t3, e3, n3, r2) : i2;
}
function Dr(t2, e2, n2, r2, i2) {
  const s2 = n2.g;
  let o2, a2;
  t2[e2] = (t3, e3, n3) => s2(t3, e3, n3, a2 ||= Pr(Lr, Ur, Dr, r2).T, o2 ||= Nr(r2), i2);
}
function Nr(t2) {
  let e2 = t2[Rr];
  if (null != e2) return e2;
  const n2 = Pr(Lr, Ur, Dr, t2);
  return e2 = n2.la ? (t3, e3) => Ir(t3, e3, n2) : (t3, e3) => {
    const r2 = 0 | t3[Q];
    for (; jn(e3) && 4 != e3.h; ) {
      var i2 = e3.m, s2 = n2[i2];
      if (null == s2) {
        var o2 = n2.ga;
        o2 && (o2 = o2[i2]) && (null != (o2 = Br(o2)) && (s2 = n2[i2] = o2));
      }
      null != s2 && s2(e3, t3, i2) || (i2 = (s2 = e3).l, Vn(s2), s2.fa ? s2 = void 0 : (o2 = s2.g.g - i2, s2.g.g = i2, s2 = Bn(s2.g, o2)), i2 = t3, s2 && ((o2 = i2[q]) ? o2.push(s2) : i2[q] = [s2]));
    }
    return 8192 & r2 && it(t3), true;
  }, t2[Rr] = e2;
}
function Br(t2) {
  const e2 = (t2 = Cr(t2))[0].g;
  if (t2 = t2[1]) {
    const n2 = Nr(t2), r2 = Pr(Lr, Ur, Dr, t2).T;
    return (t3, i2, s2) => e2(t3, i2, s2, r2, n2);
  }
  return e2;
}
function Gr(t2, e2, n2) {
  t2[e2] = n2.h;
}
function jr(t2, e2, n2, r2) {
  let i2, s2;
  const o2 = n2.h;
  t2[e2] = (t3, e3, n3) => o2(t3, e3, n3, s2 ||= Pr(xr, Gr, jr, r2).T, i2 ||= Vr(r2));
}
function Vr(t2) {
  let e2 = t2[Fr];
  if (!e2) {
    const n2 = Pr(xr, Gr, jr, t2);
    e2 = (t3, e3) => Xr(t3, e3, n2), t2[Fr] = e2;
  }
  return e2;
}
function Xr(t2, e2, n2) {
  !(function(t3, e3, n3) {
    const r2 = 512 & e3 ? 0 : -1, i2 = t3.length, s2 = i2 + ((e3 = 64 & e3 ? 256 & e3 : !!i2 && lt(t3[i2 - 1])) ? -1 : 0);
    for (let e4 = 0; e4 < s2; e4++) n3(e4 - r2, t3[e4]);
    if (e3) {
      t3 = t3[i2 - 1];
      for (const e4 in t3) !isNaN(e4) && n3(+e4, t3[e4]);
    }
  })(t2, 0 | t2[Q] | (n2.T[1] ? 512 : 0), ((t3, r2) => {
    if (null != r2) {
      var i2 = (function(t4, e3) {
        var n3 = t4[e3];
        if (n3) return n3;
        if ((n3 = t4.ga) && (n3 = n3[e3])) {
          var r3 = (n3 = Cr(n3))[0].h;
          if (n3 = n3[1]) {
            const e4 = Vr(n3), i3 = Pr(xr, Gr, jr, n3).T;
            n3 = t4.la ? Mr(i3, e4) : (t5, n4, s2) => r3(t5, n4, s2, i3, e4);
          } else n3 = r3;
          return t4[e3] = n3;
        }
      })(n2, t3);
      i2 && i2(e2, r2, t3);
    }
  })), (t2 = mt(t2)) && (function(t3, e3) {
    or(t3, t3.g.end());
    for (let n3 = 0; n3 < e3.length; n3++) or(t3, D(e3[n3]) || new Uint8Array(0));
  })(e2, t2);
}
function Hr(t2, e2) {
  if (Array.isArray(e2)) {
    var n2 = 0 | e2[Q];
    if (4 & n2) return e2;
    for (var r2 = 0, i2 = 0; r2 < e2.length; r2++) {
      const n3 = t2(e2[r2]);
      null != n3 && (e2[i2++] = n3);
    }
    return i2 < r2 && (e2.length = i2), rt(e2, -6145 & (5 | n2)), 2 & n2 && Object.freeze(e2), e2;
  }
}
function Wr(t2, e2, n2) {
  return new Tr(t2, e2, n2);
}
function zr(t2, e2, n2) {
  return new Tr(t2, e2, n2);
}
function Kr(t2, e2, n2) {
  We(t2, 0 | t2[Q], e2, n2);
}
var Yr = Ar((function(t2, e2, n2, r2, i2) {
  return 2 === t2.h && (t2 = Xn(t2, De([void 0, void 0], r2, true), i2), pt(r2 = 0 | e2[Q]), (i2 = Xe(e2, r2, n2)) instanceof Ae ? 0 != (2 & i2.M) ? ((i2 = i2.da()).push(t2), We(e2, r2, n2, i2)) : i2.Ja(t2) : Array.isArray(i2) ? (2 & (0 | i2[Q]) && We(e2, r2, n2, i2 = Qe(i2)), i2.push(t2)) : We(e2, r2, n2, [t2]), true);
}), (function(t2, e2, n2, r2, i2) {
  if (e2 instanceof Ae) e2.forEach(((e3, s2) => {
    lr(t2, n2, De([s2, e3], r2, false), i2);
  }));
  else if (Array.isArray(e2)) for (let s2 = 0; s2 < e2.length; s2++) {
    const o2 = e2[s2];
    Array.isArray(o2) && lr(t2, n2, De(o2, r2, false), i2);
  }
}));
function $r(t2, e2, n2) {
  if (e2 = (function(t3) {
    if (null == t3) return t3;
    const e3 = typeof t3;
    if ("bigint" === e3) return String(Ht(64, t3));
    if (Qt(t3)) {
      if ("string" === e3) return oe(t3);
      if ("number" === e3) return se(t3);
    }
  })(e2), null != e2) {
    if ("string" == typeof e2) Qn(e2);
    if (null != e2) switch (ar(t2, n2, 0), typeof e2) {
      case "number":
        t2 = t2.g, Ot(e2), nr(t2, Mt, Pt);
        break;
      case "bigint":
        n2 = BigInt.asUintN(64, e2), n2 = new tr(Number(n2 & BigInt(4294967295)), Number(n2 >> BigInt(32))), nr(t2.g, n2.h, n2.g);
        break;
      default:
        n2 = Qn(e2), nr(t2.g, n2.h, n2.g);
    }
  }
}
function qr(t2, e2, n2) {
  null != (e2 = te(e2)) && null != e2 && (ar(t2, n2, 0), ir(t2.g, e2));
}
function Jr(t2, e2, n2) {
  null != (e2 = Jt(e2)) && (ar(t2, n2, 0), t2.g.g.push(e2 ? 1 : 0));
}
function Zr(t2, e2, n2) {
  null != (e2 = fe(e2)) && ur(t2, n2, c(e2));
}
function Qr(t2, e2, n2, r2, i2) {
  lr(t2, n2, Or(e2, r2), i2);
}
function ti(t2, e2, n2) {
  null == e2 || "string" == typeof e2 || e2 instanceof N || (C(e2) ? C(e2) && H(Z) : e2 = void 0), null != e2 && ur(t2, n2, Ln(e2).buffer);
}
function ei(t2, e2, n2) {
  return (5 === t2.h || 2 === t2.h) && (e2 = en(e2, 0 | e2[Q], n2, false), 2 == t2.h ? zn(t2, Cn, e2) : e2.push(Cn(t2.g)), true);
}
var ni = Wr((function(t2, e2, n2) {
  if (1 !== t2.h) return false;
  var r2 = t2.g;
  t2 = Pn(r2);
  const i2 = Pn(r2);
  r2 = 2 * (i2 >> 31) + 1;
  const s2 = i2 >>> 20 & 2047;
  return t2 = 4294967296 * (1048575 & i2) + t2, Kr(e2, n2, 2047 == s2 ? t2 ? NaN : r2 * (1 / 0) : 0 == s2 ? 5e-324 * r2 * t2 : r2 * Math.pow(2, s2 - 1075) * (t2 + 4503599627370496)), true;
}), (function(t2, e2, n2) {
  null != (e2 = qt(e2)) && (ar(t2, n2, 1), t2 = t2.g, (n2 = It ||= new DataView(new ArrayBuffer(8))).setFloat64(0, +e2, true), Mt = n2.getUint32(0, true), Pt = n2.getUint32(4, true), sr(t2, Mt), sr(t2, Pt));
}), dr());
var ri = Wr((function(t2, e2, n2) {
  return 5 === t2.h && (Kr(e2, n2, Cn(t2.g)), true);
}), (function(t2, e2, n2) {
  null != (e2 = qt(e2)) && (ar(t2, n2, 5), t2 = t2.g, Ut(e2), sr(t2, Mt));
}), vr);
var ii = zr(ei, (function(t2, e2, n2) {
  if (null != (e2 = Hr(qt, e2))) for (let o2 = 0; o2 < e2.length; o2++) {
    var r2 = t2, i2 = n2, s2 = e2[o2];
    null != s2 && (ar(r2, i2, 5), r2 = r2.g, Ut(s2), sr(r2, Mt));
  }
}), vr);
var si = zr(ei, (function(t2, e2, n2) {
  if (null != (e2 = Hr(qt, e2)) && e2.length) {
    ar(t2, n2, 2), rr(t2.g, 4 * e2.length);
    for (let r2 = 0; r2 < e2.length; r2++) n2 = t2.g, Ut(e2[r2]), sr(n2, Mt);
  }
}), vr);
var oi = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, Rn(t2.g, Nt)), true);
}), $r, _r);
var ai = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, 0 === (t2 = Rn(t2.g, Nt)) ? void 0 : t2), true);
}), $r, _r);
var ci = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, Rn(t2.g, Dt)), true);
}), (function(t2, e2, n2) {
  if (null != (e2 = ue(e2))) {
    if ("string" == typeof e2) qn(e2);
    if (null != e2) switch (ar(t2, n2, 0), typeof e2) {
      case "number":
        t2 = t2.g, Ot(e2), nr(t2, Mt, Pt);
        break;
      case "bigint":
        n2 = BigInt.asUintN(64, e2), n2 = new Jn(Number(n2 & BigInt(4294967295)), Number(n2 >> BigInt(32))), nr(t2.g, n2.h, n2.g);
        break;
      default:
        n2 = qn(e2), nr(t2.g, n2.h, n2.g);
    }
  }
}), dr());
var hi = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, In(t2.g)), true);
}), qr, mr);
var ui = zr((function(t2, e2, n2) {
  return (0 === t2.h || 2 === t2.h) && (e2 = en(e2, 0 | e2[Q], n2, false), 2 == t2.h ? zn(t2, In, e2) : e2.push(In(t2.g)), true);
}), (function(t2, e2, n2) {
  if (null != (e2 = Hr(te, e2)) && e2.length) {
    n2 = cr(t2, n2);
    for (let n3 = 0; n3 < e2.length; n3++) ir(t2.g, e2[n3]);
    hr(t2, n2);
  }
}), mr);
var li = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, 0 === (t2 = In(t2.g)) ? void 0 : t2), true);
}), qr, mr);
var di = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, Fn(t2.g)), true);
}), Jr, pr);
var fi = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, false === (t2 = Fn(t2.g)) ? void 0 : t2), true);
}), Jr, pr);
var pi = zr((function(t2, e2, n2) {
  return 2 === t2.h && (t2 = Hn(t2), en(e2, 0 | e2[Q], n2, false).push(t2), true);
}), (function(t2, e2, n2) {
  if (null != (e2 = Hr(fe, e2))) for (let o2 = 0; o2 < e2.length; o2++) {
    var r2 = t2, i2 = n2, s2 = e2[o2];
    null != s2 && ur(r2, i2, c(s2));
  }
}), gr);
var gi = Wr((function(t2, e2, n2) {
  return 2 === t2.h && (Kr(e2, n2, "" === (t2 = Hn(t2)) ? void 0 : t2), true);
}), Zr, gr);
var mi = Wr((function(t2, e2, n2) {
  return 2 === t2.h && (Kr(e2, n2, Hn(t2)), true);
}), Zr, gr);
var yi = (function(t2, e2, n2 = fr) {
  return new Tr(t2, e2, n2);
})((function(t2, e2, n2, r2, i2) {
  return 2 === t2.h && (r2 = De(void 0, r2, true), en(e2, 0 | e2[Q], n2, true).push(r2), Xn(t2, r2, i2), true);
}), (function(t2, e2, n2, r2, i2) {
  if (Array.isArray(e2)) for (let s2 = 0; s2 < e2.length; s2++) Qr(t2, e2[s2], n2, r2, i2);
}));
var _i = Ar((function(t2, e2, n2, r2, i2, s2) {
  return 2 === t2.h && (sn(e2, 0 | e2[Q], s2, n2), Xn(t2, e2 = an(e2, r2, n2), i2), true);
}), Qr);
var vi = Wr((function(t2, e2, n2) {
  return 2 === t2.h && (Kr(e2, n2, Wn(t2)), true);
}), ti, Er);
var Ei = zr((function(t2, e2, n2) {
  return (0 === t2.h || 2 === t2.h) && (e2 = en(e2, 0 | e2[Q], n2, false), 2 == t2.h ? zn(t2, Mn, e2) : e2.push(Mn(t2.g)), true);
}), (function(t2, e2, n2) {
  if (null != (e2 = Hr(ee, e2))) for (let o2 = 0; o2 < e2.length; o2++) {
    var r2 = t2, i2 = n2, s2 = e2[o2];
    null != s2 && (ar(r2, i2, 0), rr(r2.g, s2));
  }
}), yr);
var wi = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, 0 === (t2 = Mn(t2.g)) ? void 0 : t2), true);
}), (function(t2, e2, n2) {
  null != (e2 = ee(e2)) && null != e2 && (ar(t2, n2, 0), rr(t2.g, e2));
}), yr);
var Ti = Wr((function(t2, e2, n2) {
  return 0 === t2.h && (Kr(e2, n2, In(t2.g)), true);
}), (function(t2, e2, n2) {
  null != (e2 = te(e2)) && (e2 = parseInt(e2, 10), ar(t2, n2, 0), ir(t2.g, e2));
}), wr);
var Ai = class {
  constructor(t2, e2) {
    this.h = t2, this.g = e2, this.l = hn, this.m = dn, this.defaultValue = void 0;
  }
  register() {
    w(this);
  }
};
function bi(t2, e2) {
  return new Ai(t2, e2);
}
function ki(t2, e2) {
  return (n2, r2) => {
    if (Kn.length) {
      const t3 = Kn.pop();
      t3.o(r2), Un(t3.g, n2, r2), n2 = t3;
    } else n2 = new class {
      constructor(t3, e3) {
        if (Gn.length) {
          const n3 = Gn.pop();
          Un(n3, t3, e3), t3 = n3;
        } else t3 = new class {
          constructor(t4, e4) {
            this.h = null, this.m = false, this.g = this.l = this.j = 0, Un(this, t4, e4);
          }
          clear() {
            this.h = null, this.m = false, this.g = this.l = this.j = 0, this.aa = false;
          }
        }(t3, e3);
        this.g = t3, this.l = this.g.g, this.h = this.m = -1, this.o(e3);
      }
      o({ fa: t3 = false } = {}) {
        this.fa = t3;
      }
    }(n2, r2);
    try {
      const r3 = new t2(), s2 = r3.u;
      Nr(e2)(s2, n2);
      var i2 = r3;
    } finally {
      n2.g.clear(), n2.m = -1, n2.h = -1, Kn.length < 100 && Kn.push(n2);
    }
    return i2;
  };
}
function Si(t2) {
  return function() {
    const e2 = new class {
      constructor() {
        this.l = [], this.h = 0, this.g = new class {
          constructor() {
            this.g = [];
          }
          length() {
            return this.g.length;
          }
          end() {
            const t3 = this.g;
            return this.g = [], t3;
          }
        }();
      }
    }();
    Xr(this.u, e2, Pr(xr, Gr, jr, t2)), or(e2, e2.g.end());
    const n2 = new Uint8Array(e2.h), r2 = e2.l, i2 = r2.length;
    let s2 = 0;
    for (let t3 = 0; t3 < i2; t3++) {
      const e3 = r2[t3];
      n2.set(e3, s2), s2 += e3.length;
    }
    return e2.l = [n2], n2;
  };
}
var xi = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Li = [0, gi, Wr((function(t2, e2, n2) {
  return 2 === t2.h && (Kr(e2, n2, (t2 = Wn(t2)) === U() ? void 0 : t2), true);
}), (function(t2, e2, n2) {
  if (null != e2) {
    if (e2 instanceof $n) {
      const r2 = e2.Oa;
      return void (r2 && (e2 = r2(e2), null != e2 && ur(t2, n2, Ln(e2).buffer)));
    }
    if (Array.isArray(e2)) return;
  }
  ti(t2, e2, n2);
}), Er)];
var Ri;
var Fi = globalThis.trustedTypes;
function Ii(t2) {
  void 0 === Ri && (Ri = (function() {
    let t3 = null;
    if (!Fi) return t3;
    try {
      const e3 = (t4) => t4;
      t3 = Fi.createPolicy("goog#html", { createHTML: e3, createScript: e3, createScriptURL: e3 });
    } catch (t4) {
    }
    return t3;
  })());
  var e2 = Ri;
  return new class {
    constructor(t3) {
      this.g = t3;
    }
    toString() {
      return this.g + "";
    }
  }(e2 ? e2.createScriptURL(t2) : t2);
}
function Mi(t2, ...e2) {
  if (0 === e2.length) return Ii(t2[0]);
  let n2 = t2[0];
  for (let r2 = 0; r2 < e2.length; r2++) n2 += encodeURIComponent(e2[r2]) + t2[r2 + 1];
  return Ii(n2);
}
var Pi = [0, hi, Ti, di, -1, ui, Ti, -1];
var Ci = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Oi = [0, di, mi, di, Ti, -1, zr((function(t2, e2, n2) {
  return (0 === t2.h || 2 === t2.h) && (e2 = en(e2, 0 | e2[Q], n2, false), 2 == t2.h ? zn(t2, On, e2) : e2.push(In(t2.g)), true);
}), (function(t2, e2, n2) {
  if (null != (e2 = Hr(te, e2)) && e2.length) {
    n2 = cr(t2, n2);
    for (let n3 = 0; n3 < e2.length; n3++) ir(t2.g, e2[n3]);
    hr(t2, n2);
  }
}), wr), mi, -1, [0, di, -1], Ti, di, -1];
var Ui = [0, mi, -2];
var Di = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Ni = [0];
var Bi = [0, hi, di, 1, di, -3];
var Gi = class extends $n {
  constructor(t2) {
    super(t2, 2);
  }
};
var ji = {};
ji[336783863] = [0, mi, di, -1, hi, [0, [1, 2, 3, 4, 5, 6, 7, 8, 9], _i, Ni, _i, Oi, _i, Ui, _i, Bi, _i, Pi, _i, [0, mi, -2], _i, [0, mi, Ti], _i, [0, Ti, mi, -1], _i, [0, Ti, -1]], [0, mi], di, [0, [1, 3], [2, 4], _i, [0, ui], -1, _i, [0, pi], -1, yi, [0, mi, -1]], mi];
var Vi = [0, ai, -1, fi, -3, ai, ui, gi, li, ai, -1, fi, li, fi, -2, gi];
function Xi(t2, e2) {
  tn(t2, 2, de(e2), "");
}
function Hi(t2, e2) {
  mn(t2, 3, e2);
}
function Wi(t2, e2) {
  mn(t2, 4, e2);
}
var zi = class extends $n {
  constructor(t2) {
    super(t2, 500);
  }
  o(t2) {
    return dn(this, 0, 7, t2);
  }
};
var Ki = [-1, {}];
var Yi = [0, mi, 1, Ki];
var $i = [0, mi, pi, Ki];
function qi(t2, e2) {
  yn(t2, 1, zi, e2);
}
function Ji(t2, e2) {
  mn(t2, 10, e2);
}
function Zi(t2, e2) {
  mn(t2, 15, e2);
}
var Qi = class extends $n {
  constructor(t2) {
    super(t2, 500);
  }
  o(t2) {
    return dn(this, 0, 1001, t2);
  }
};
var ts = [-500, yi, [-500, gi, -1, pi, -3, [-2, ji, di], yi, Li, li, -1, Yi, $i, yi, [0, gi, fi], gi, Vi, li, pi, 987, pi], 4, yi, [-500, mi, -1, [-1, {}], 998, mi], yi, [-500, mi, pi, -1, [-2, {}, di], 997, pi, -1], li, yi, [-500, mi, pi, Ki, 998, pi], pi, li, Yi, $i, yi, [0, gi, -1, Ki], pi, -2, Vi, gi, -1, fi, [0, fi, wi], 978, Ki, yi, Li];
Qi.prototype.g = Si(ts);
var es = ki(Qi, ts);
var ns = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var rs = class extends $n {
  constructor(t2) {
    super(t2);
  }
  g() {
    return ln(this, ns, 1);
  }
};
var is = [0, yi, [0, hi, ri, mi, -1]];
var ss = ki(rs, is);
var os = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var as = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var cs = class extends $n {
  constructor(t2) {
    super(t2);
  }
  h() {
    return hn(this, os, 2);
  }
  g() {
    return ln(this, as, 5);
  }
};
var hs = ki(class extends $n {
  constructor(t2) {
    super(t2);
  }
}, [0, pi, ui, si, [0, Ti, [0, hi, -3], [0, ri, -3], [0, hi, -1, [0, yi, [0, hi, -2]]], yi, [0, ri, -1, mi, ri]], mi, -1, oi, yi, [0, hi, ri], pi, oi]);
var us = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var ls = ki(class extends $n {
  constructor(t2) {
    super(t2);
  }
}, [0, yi, [0, ri, -4]]);
var ds = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var fs = ki(class extends $n {
  constructor(t2) {
    super(t2);
  }
}, [0, yi, [0, ri, -4]]);
var ps = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var gs = [0, hi, -1, si, Ti];
var ms = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
ms.prototype.g = Si([0, ri, -4, oi]);
var ys = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var _s = ki(class extends $n {
  constructor(t2) {
    super(t2);
  }
}, [0, yi, [0, 1, hi, mi, is], oi]);
var vs = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Es = class extends $n {
  constructor(t2) {
    super(t2);
  }
  ma() {
    const t2 = Ke(this);
    return null == t2 ? U() : t2;
  }
};
var ws = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Ts = [1, 2];
var As = ki(class extends $n {
  constructor(t2) {
    super(t2);
  }
}, [0, yi, [0, Ts, _i, [0, si], _i, [0, vi], hi, mi], oi]);
var bs = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var ks = [0, mi, hi, ri, pi, -1];
var Ss = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var xs = [0, di, -1];
var Ls = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Rs = [1, 2, 3, 4, 5];
var Fs = class extends $n {
  constructor(t2) {
    super(t2);
  }
  g() {
    return null != Ke(this);
  }
  h() {
    return null != vn(this, 2);
  }
};
var Is = class extends $n {
  constructor(t2) {
    super(t2);
  }
  g() {
    return Jt(Ve(this, 2)) ?? false;
  }
};
var Ms = [0, vi, mi, [0, hi, oi, -1], [0, ci, oi]];
var Ps = [0, Ms, di, [0, Rs, _i, Bi, _i, Oi, _i, Pi, _i, Ni, _i, Ui], Ti];
var Cs = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Os = [0, Ps, ri, -1, hi];
var Us = bi(502141897, Cs);
ji[502141897] = Os;
var Ds = ki(class extends $n {
  constructor(t2) {
    super(t2);
  }
}, [0, [0, Ti, -1, ii, Ei], gs]);
var Ns = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Bs = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Gs = [0, Ps, ri, [0, Ps], di];
var js = [0, Ps, Os, Gs, ri, [0, [0, Ms]]];
var Vs = bi(508968150, Bs);
ji[508968150] = js, ji[508968149] = Gs;
var Xs = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Hs = bi(513916220, Xs);
ji[513916220] = [0, Ps, js, hi];
var Ws = class extends $n {
  constructor(t2) {
    super(t2);
  }
  h() {
    return hn(this, bs, 2);
  }
  g() {
    He(this, 2);
  }
};
var zs = [0, Ps, ks];
ji[478825465] = zs;
var Ks = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Ys = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var $s = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var qs = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Js = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Zs = [0, Ps, [0, Ps], zs, -1];
var Qs = [0, Ps, ri, hi];
var to = [0, Ps, ri];
var eo = [0, Ps, Qs, to, ri];
var no = bi(479097054, Js);
ji[479097054] = [0, Ps, eo, Zs], ji[463370452] = Zs, ji[464864288] = Qs;
var ro = bi(462713202, qs);
ji[462713202] = eo, ji[474472470] = to;
var io = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var so = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var oo = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var ao = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var co = [0, Ps, ri, -1, hi];
var ho = [0, Ps, ri, di];
ao.prototype.g = Si([0, Ps, to, [0, Ps], Os, Gs, co, ho]);
var uo = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var lo = bi(456383383, uo);
ji[456383383] = [0, Ps, ks];
var fo = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var po = bi(476348187, fo);
ji[476348187] = [0, Ps, xs];
var go = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var mo = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var yo = [0, Ti, -1];
var _o = bi(458105876, class extends $n {
  constructor(t2) {
    super(t2);
  }
  g() {
    var t2 = this.u;
    const e2 = 0 | t2[Q], n2 = 2 & e2;
    return t2 = (function(t3, e3, n3) {
      var r2 = mo;
      const i2 = 2 & e3;
      let s2 = false;
      if (null == n3) {
        if (i2) return Ie();
        n3 = [];
      } else if (n3.constructor === Ae) {
        if (0 == (2 & n3.M) || i2) return n3;
        n3 = n3.da();
      } else Array.isArray(n3) ? s2 = !!(2 & (0 | n3[Q])) : n3 = [];
      if (i2) {
        if (!n3.length) return Ie();
        s2 || (s2 = true, it(n3));
      } else s2 && (s2 = false, n3 = Qe(n3));
      return s2 || (64 & (0 | n3[Q]) ? n3[Q] &= -33 : 32 & e3 && nt(n3, 32)), We(t3, e3, 2, r2 = new Ae(n3, r2, ge, void 0)), r2;
    })(t2, e2, Xe(t2, e2, 2)), !n2 && mo && (t2.pa = true), t2;
  }
});
ji[458105876] = [0, yo, Yr, [true, oi, [0, mi, -1, pi]]];
var vo = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Eo = bi(458105758, vo);
ji[458105758] = [0, Ps, mi, yo];
var wo = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var To = bi(443442058, wo);
ji[443442058] = [0, Ps, mi, hi, ri, pi, -1, di, ri], ji[514774813] = co;
var Ao = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var bo = bi(516587230, Ao);
function ko(t2, e2) {
  return e2 = e2 ? e2.clone() : new bs(), void 0 !== t2.displayNamesLocale ? He(e2, 1, de(t2.displayNamesLocale)) : void 0 === t2.displayNamesLocale && He(e2, 1), void 0 !== t2.maxResults ? Tn(e2, 2, t2.maxResults) : "maxResults" in t2 && He(e2, 2), void 0 !== t2.scoreThreshold ? An(e2, 3, t2.scoreThreshold) : "scoreThreshold" in t2 && He(e2, 3), void 0 !== t2.categoryAllowlist ? bn(e2, 4, t2.categoryAllowlist) : "categoryAllowlist" in t2 && He(e2, 4), void 0 !== t2.categoryDenylist ? bn(e2, 5, t2.categoryDenylist) : "categoryDenylist" in t2 && He(e2, 5), e2;
}
function So(t2, e2 = -1, n2 = "") {
  return { categories: t2.map(((t3) => ({ index: _n(t3, 1) ?? 0 ?? -1, score: En(t3, 2) ?? 0, categoryName: vn(t3, 3) ?? "" ?? "", displayName: vn(t3, 4) ?? "" ?? "" }))), headIndex: e2, headName: n2 };
}
function xo(t2) {
  var e2 = $e(t2, 3, qt, Ye()), n2 = $e(t2, 2, te, Ye()), r2 = $e(t2, 1, fe, Ye()), i2 = $e(t2, 9, fe, Ye());
  const s2 = { categories: [], keypoints: [] };
  for (let t3 = 0; t3 < e2.length; t3++) s2.categories.push({ score: e2[t3], index: n2[t3] ?? -1, categoryName: r2[t3] ?? "", displayName: i2[t3] ?? "" });
  if ((e2 = hn(t2, cs, 4)?.h()) && (s2.boundingBox = { originX: _n(e2, 1) ?? 0, originY: _n(e2, 2) ?? 0, width: _n(e2, 3) ?? 0, height: _n(e2, 4) ?? 0, angle: 0 }), hn(t2, cs, 4)?.g().length) for (const e3 of hn(t2, cs, 4).g()) s2.keypoints.push({ x: ze(e3, 1) ?? 0, y: ze(e3, 2) ?? 0, score: ze(e3, 4) ?? 0, label: vn(e3, 3) ?? "" });
  return s2;
}
function Lo(t2) {
  const e2 = [];
  for (const n2 of ln(t2, ds, 1)) e2.push({ x: En(n2, 1) ?? 0, y: En(n2, 2) ?? 0, z: En(n2, 3) ?? 0, visibility: En(n2, 4) ?? 0 });
  return e2;
}
function Ro(t2) {
  const e2 = [];
  for (const n2 of ln(t2, us, 1)) e2.push({ x: En(n2, 1) ?? 0, y: En(n2, 2) ?? 0, z: En(n2, 3) ?? 0, visibility: En(n2, 4) ?? 0 });
  return e2;
}
function Fo(t2) {
  return Array.from(t2, ((t3) => t3 > 127 ? t3 - 256 : t3));
}
function Io(t2, e2) {
  if (t2.length !== e2.length) throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${t2.length} vs. ${e2.length}).`);
  let n2 = 0, r2 = 0, i2 = 0;
  for (let s2 = 0; s2 < t2.length; s2++) n2 += t2[s2] * e2[s2], r2 += t2[s2] * t2[s2], i2 += e2[s2] * e2[s2];
  if (r2 <= 0 || i2 <= 0) throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
  return n2 / Math.sqrt(r2 * i2);
}
var Mo;
ji[516587230] = [0, Ps, co, ho, ri], ji[518928384] = ho;
var Po = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
async function Co() {
  if (void 0 === Mo) try {
    await WebAssembly.instantiate(Po), Mo = true;
  } catch {
    Mo = false;
  }
  return Mo;
}
async function Oo(t2, e2 = Mi``) {
  const n2 = await Co() ? "wasm_internal" : "wasm_nosimd_internal";
  return { wasmLoaderPath: `${e2}/${t2}_${n2}.js`, wasmBinaryPath: `${e2}/${t2}_${n2}.wasm` };
}
var Uo = class {
};
function Do() {
  var t2 = navigator;
  return "undefined" != typeof OffscreenCanvas && (!(function(t3 = navigator) {
    return (t3 = t3.userAgent).includes("Safari") && !t3.includes("Chrome");
  })(t2) || !!((t2 = t2.userAgent.match(/Version\/([\d]+).*Safari/)) && t2.length >= 1 && Number(t2[1]) >= 17));
}
async function No(t2) {
  if ("function" != typeof importScripts) {
    const e2 = document.createElement("script");
    return e2.src = t2.toString(), e2.crossOrigin = "anonymous", new Promise(((t3, n2) => {
      e2.addEventListener("load", (() => {
        t3();
      }), false), e2.addEventListener("error", ((t4) => {
        n2(t4);
      }), false), document.body.appendChild(e2);
    }));
  }
  importScripts(t2.toString());
}
function Bo(t2) {
  return void 0 !== t2.videoWidth ? [t2.videoWidth, t2.videoHeight] : void 0 !== t2.naturalWidth ? [t2.naturalWidth, t2.naturalHeight] : void 0 !== t2.displayWidth ? [t2.displayWidth, t2.displayHeight] : [t2.width, t2.height];
}
function Go(t2, e2, n2) {
  t2.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), n2(e2 = t2.i.stringToNewUTF8(e2)), t2.i._free(e2);
}
function jo(t2, e2, n2) {
  if (!t2.i.canvas) throw Error("No OpenGL canvas configured.");
  if (n2 ? t2.i._bindTextureToStream(n2) : t2.i._bindTextureToCanvas(), !(n2 = t2.i.canvas.getContext("webgl2") || t2.i.canvas.getContext("webgl"))) throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
  t2.i.gpuOriginForWebTexturesIsBottomLeft && n2.pixelStorei(n2.UNPACK_FLIP_Y_WEBGL, true), n2.texImage2D(n2.TEXTURE_2D, 0, n2.RGBA, n2.RGBA, n2.UNSIGNED_BYTE, e2), t2.i.gpuOriginForWebTexturesIsBottomLeft && n2.pixelStorei(n2.UNPACK_FLIP_Y_WEBGL, false);
  const [r2, i2] = Bo(e2);
  return !t2.l || r2 === t2.i.canvas.width && i2 === t2.i.canvas.height || (t2.i.canvas.width = r2, t2.i.canvas.height = i2), [r2, i2];
}
function Vo(t2, e2, n2) {
  t2.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
  const r2 = new Uint32Array(e2.length);
  for (let n3 = 0; n3 < e2.length; n3++) r2[n3] = t2.i.stringToNewUTF8(e2[n3]);
  e2 = t2.i._malloc(4 * r2.length), t2.i.HEAPU32.set(r2, e2 >> 2), n2(e2);
  for (const e3 of r2) t2.i._free(e3);
  t2.i._free(e2);
}
function Xo(t2, e2, n2) {
  t2.i.simpleListeners = t2.i.simpleListeners || {}, t2.i.simpleListeners[e2] = n2;
}
function Ho(t2, e2, n2) {
  let r2 = [];
  t2.i.simpleListeners = t2.i.simpleListeners || {}, t2.i.simpleListeners[e2] = (t3, e3, i2) => {
    e3 ? (n2(r2, i2), r2 = []) : r2.push(t3);
  };
}
Uo.forVisionTasks = function(t2) {
  return Oo("vision", t2);
}, Uo.forTextTasks = function(t2) {
  return Oo("text", t2);
}, Uo.forGenAiExperimentalTasks = function(t2) {
  return Oo("genai_experimental", t2);
}, Uo.forGenAiTasks = function(t2) {
  return Oo("genai", t2);
}, Uo.forAudioTasks = function(t2) {
  return Oo("audio", t2);
}, Uo.isSimdSupported = function() {
  return Co();
};
async function Wo(t2, e2, n2, r2) {
  return t2 = await (async (t3, e3, n3, r3, i2) => {
    if (e3 && await No(e3), !self.ModuleFactory) throw Error("ModuleFactory not set.");
    if (n3 && (await No(n3), !self.ModuleFactory)) throw Error("ModuleFactory not set.");
    return self.Module && i2 && ((e3 = self.Module).locateFile = i2.locateFile, i2.mainScriptUrlOrBlob && (e3.mainScriptUrlOrBlob = i2.mainScriptUrlOrBlob)), i2 = await self.ModuleFactory(self.Module || i2), self.ModuleFactory = self.Module = void 0, new t3(i2, r3);
  })(t2, n2.wasmLoaderPath, n2.assetLoaderPath, e2, { locateFile: (t3) => t3.endsWith(".wasm") ? n2.wasmBinaryPath.toString() : n2.assetBinaryPath && t3.endsWith(".data") ? n2.assetBinaryPath.toString() : t3 }), await t2.o(r2), t2;
}
function zo(t2, e2) {
  const n2 = hn(t2.baseOptions, Fs, 1) || new Fs();
  "string" == typeof e2 ? (He(n2, 2, de(e2)), He(n2, 1)) : e2 instanceof Uint8Array && (He(n2, 1, dt(e2, false)), He(n2, 2)), dn(t2.baseOptions, 0, 1, n2);
}
function Ko(t2) {
  try {
    const e2 = t2.G.length;
    if (1 === e2) throw Error(t2.G[0].message);
    if (e2 > 1) throw Error("Encountered multiple errors: " + t2.G.map(((t3) => t3.message)).join(", "));
  } finally {
    t2.G = [];
  }
}
function Yo(t2, e2) {
  t2.B = Math.max(t2.B, e2);
}
function $o(t2, e2) {
  t2.A = new zi(), Xi(t2.A, "PassThroughCalculator"), Hi(t2.A, "free_memory"), Wi(t2.A, "free_memory_unused_out"), Ji(e2, "free_memory"), qi(e2, t2.A);
}
function qo(t2, e2) {
  Hi(t2.A, e2), Wi(t2.A, e2 + "_unused_out");
}
function Jo(t2) {
  t2.g.addBoolToStream(true, "free_memory", t2.B);
}
var Zo = class {
  constructor(t2) {
    this.g = t2, this.G = [], this.B = 0, this.g.setAutoRenderToScreen(false);
  }
  l(t2, e2 = true) {
    if (e2) {
      const e3 = t2.baseOptions || {};
      if (t2.baseOptions?.modelAssetBuffer && t2.baseOptions?.modelAssetPath) throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
      if (!(hn(this.baseOptions, Fs, 1)?.g() || hn(this.baseOptions, Fs, 1)?.h() || t2.baseOptions?.modelAssetBuffer || t2.baseOptions?.modelAssetPath)) throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
      if ((function(t3, e4) {
        let n2 = hn(t3.baseOptions, Ls, 3);
        if (!n2) {
          var r2 = n2 = new Ls(), i2 = new Di();
          fn(r2, 4, Rs, i2);
        }
        "delegate" in e4 && ("GPU" === e4.delegate ? (e4 = n2, r2 = new Ci(), fn(e4, 2, Rs, r2)) : (e4 = n2, r2 = new Di(), fn(e4, 4, Rs, r2))), dn(t3.baseOptions, 0, 3, n2);
      })(this, e3), e3.modelAssetPath) return fetch(e3.modelAssetPath.toString()).then(((t3) => {
        if (t3.ok) return t3.arrayBuffer();
        throw Error(`Failed to fetch model: ${e3.modelAssetPath} (${t3.status})`);
      })).then(((t3) => {
        try {
          this.g.i.FS_unlink("/model.dat");
        } catch {
        }
        this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(t3), true, false, false), zo(this, "/model.dat"), this.m(), this.J();
      }));
      if (e3.modelAssetBuffer instanceof Uint8Array) zo(this, e3.modelAssetBuffer);
      else if (e3.modelAssetBuffer) return (async function(t3) {
        const e4 = [];
        for (var n2 = 0; ; ) {
          const { done: r2, value: i2 } = await t3.read();
          if (r2) break;
          e4.push(i2), n2 += i2.length;
        }
        if (0 === e4.length) return new Uint8Array(0);
        if (1 === e4.length) return e4[0];
        t3 = new Uint8Array(n2), n2 = 0;
        for (const r2 of e4) t3.set(r2, n2), n2 += r2.length;
        return t3;
      })(e3.modelAssetBuffer).then(((t3) => {
        zo(this, t3), this.m(), this.J();
      }));
    }
    return this.m(), this.J(), Promise.resolve();
  }
  J() {
  }
  ca() {
    let t2;
    if (this.g.ca(((e2) => {
      t2 = es(e2);
    })), !t2) throw Error("Failed to retrieve CalculatorGraphConfig");
    return t2;
  }
  setGraph(t2, e2) {
    this.g.attachErrorListener(((t3, e3) => {
      this.G.push(Error(e3));
    })), this.g.Ha(), this.g.setGraph(t2, e2), this.A = void 0, Ko(this);
  }
  finishProcessing() {
    this.g.finishProcessing(), Ko(this);
  }
  close() {
    this.A = void 0, this.g.closeGraph();
  }
};
function Qo(t2, e2) {
  if (!t2) throw Error(`Unable to obtain required WebGL resource: ${e2}`);
  return t2;
}
Zo.prototype.close = Zo.prototype.close;
var ta = class {
  constructor(t2, e2, n2, r2) {
    this.g = t2, this.h = e2, this.m = n2, this.l = r2;
  }
  bind() {
    this.g.bindVertexArray(this.h);
  }
  close() {
    this.g.deleteVertexArray(this.h), this.g.deleteBuffer(this.m), this.g.deleteBuffer(this.l);
  }
};
function ea(t2, e2, n2) {
  const r2 = t2.g;
  if (n2 = Qo(r2.createShader(n2), "Failed to create WebGL shader"), r2.shaderSource(n2, e2), r2.compileShader(n2), !r2.getShaderParameter(n2, r2.COMPILE_STATUS)) throw Error(`Could not compile WebGL shader: ${r2.getShaderInfoLog(n2)}`);
  return r2.attachShader(t2.h, n2), n2;
}
function na(t2, e2) {
  const n2 = t2.g, r2 = Qo(n2.createVertexArray(), "Failed to create vertex array");
  n2.bindVertexArray(r2);
  const i2 = Qo(n2.createBuffer(), "Failed to create buffer");
  n2.bindBuffer(n2.ARRAY_BUFFER, i2), n2.enableVertexAttribArray(t2.P), n2.vertexAttribPointer(t2.P, 2, n2.FLOAT, false, 0, 0), n2.bufferData(n2.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n2.STATIC_DRAW);
  const s2 = Qo(n2.createBuffer(), "Failed to create buffer");
  return n2.bindBuffer(n2.ARRAY_BUFFER, s2), n2.enableVertexAttribArray(t2.J), n2.vertexAttribPointer(t2.J, 2, n2.FLOAT, false, 0, 0), n2.bufferData(n2.ARRAY_BUFFER, new Float32Array(e2 ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), n2.STATIC_DRAW), n2.bindBuffer(n2.ARRAY_BUFFER, null), n2.bindVertexArray(null), new ta(n2, r2, i2, s2);
}
function ra(t2, e2) {
  if (t2.g) {
    if (e2 !== t2.g) throw Error("Cannot change GL context once initialized");
  } else t2.g = e2;
}
function ia(t2, e2, n2, r2) {
  return ra(t2, e2), t2.h || (t2.m(), t2.C()), n2 ? (t2.s || (t2.s = na(t2, true)), n2 = t2.s) : (t2.v || (t2.v = na(t2, false)), n2 = t2.v), e2.useProgram(t2.h), n2.bind(), t2.l(), t2 = r2(), n2.g.bindVertexArray(null), t2;
}
function sa(t2, e2, n2) {
  return ra(t2, e2), t2 = Qo(e2.createTexture(), "Failed to create texture"), e2.bindTexture(e2.TEXTURE_2D, t2), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, n2 ?? e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, n2 ?? e2.LINEAR), e2.bindTexture(e2.TEXTURE_2D, null), t2;
}
function oa(t2, e2, n2) {
  ra(t2, e2), t2.A || (t2.A = Qo(e2.createFramebuffer(), "Failed to create framebuffe.")), e2.bindFramebuffer(e2.FRAMEBUFFER, t2.A), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, n2, 0);
}
function aa(t2) {
  t2.g?.bindFramebuffer(t2.g.FRAMEBUFFER, null);
}
var ca = class {
  G() {
    return "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n ";
  }
  m() {
    const t2 = this.g;
    if (this.h = Qo(t2.createProgram(), "Failed to create WebGL program"), this.Z = ea(this, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", t2.VERTEX_SHADER), this.Y = ea(this, this.G(), t2.FRAGMENT_SHADER), t2.linkProgram(this.h), !t2.getProgramParameter(this.h, t2.LINK_STATUS)) throw Error(`Error during program linking: ${t2.getProgramInfoLog(this.h)}`);
    this.P = t2.getAttribLocation(this.h, "aVertex"), this.J = t2.getAttribLocation(this.h, "aTex");
  }
  C() {
  }
  l() {
  }
  close() {
    if (this.h) {
      const t2 = this.g;
      t2.deleteProgram(this.h), t2.deleteShader(this.Z), t2.deleteShader(this.Y);
    }
    this.A && this.g.deleteFramebuffer(this.A), this.v && this.v.close(), this.s && this.s.close();
  }
};
var ha = class extends ca {
  G() {
    return "\n  precision mediump float;\n  uniform sampler2D backgroundTexture;\n  uniform sampler2D maskTexture;\n  uniform sampler2D colorMappingTexture;\n  varying vec2 vTex;\n  void main() {\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\n    float category = texture2D(maskTexture, vTex).r;\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\n  }\n ";
  }
  C() {
    const t2 = this.g;
    t2.activeTexture(t2.TEXTURE1), this.B = sa(this, t2, t2.LINEAR), t2.activeTexture(t2.TEXTURE2), this.j = sa(this, t2, t2.NEAREST);
  }
  m() {
    super.m();
    const t2 = this.g;
    this.L = Qo(t2.getUniformLocation(this.h, "backgroundTexture"), "Uniform location"), this.U = Qo(t2.getUniformLocation(this.h, "colorMappingTexture"), "Uniform location"), this.K = Qo(t2.getUniformLocation(this.h, "maskTexture"), "Uniform location");
  }
  l() {
    super.l();
    const t2 = this.g;
    t2.uniform1i(this.K, 0), t2.uniform1i(this.L, 1), t2.uniform1i(this.U, 2);
  }
  close() {
    this.B && this.g.deleteTexture(this.B), this.j && this.g.deleteTexture(this.j), super.close();
  }
};
var ua = class extends ca {
  G() {
    return "\n  precision mediump float;\n  uniform sampler2D maskTexture;\n  uniform sampler2D defaultTexture;\n  uniform sampler2D overlayTexture;\n  varying vec2 vTex;\n  void main() {\n    float confidence = texture2D(maskTexture, vTex).r;\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\n    // Apply the alpha from the overlay and merge in the default color\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\n  }\n ";
  }
  C() {
    const t2 = this.g;
    t2.activeTexture(t2.TEXTURE1), this.j = sa(this, t2), t2.activeTexture(t2.TEXTURE2), this.B = sa(this, t2);
  }
  m() {
    super.m();
    const t2 = this.g;
    this.K = Qo(t2.getUniformLocation(this.h, "defaultTexture"), "Uniform location"), this.L = Qo(t2.getUniformLocation(this.h, "overlayTexture"), "Uniform location"), this.H = Qo(t2.getUniformLocation(this.h, "maskTexture"), "Uniform location");
  }
  l() {
    super.l();
    const t2 = this.g;
    t2.uniform1i(this.H, 0), t2.uniform1i(this.K, 1), t2.uniform1i(this.L, 2);
  }
  close() {
    this.j && this.g.deleteTexture(this.j), this.B && this.g.deleteTexture(this.B), super.close();
  }
};
function la(t2, e2) {
  switch (e2) {
    case 0:
      return t2.g.find(((t3) => t3 instanceof Uint8Array));
    case 1:
      return t2.g.find(((t3) => t3 instanceof Float32Array));
    case 2:
      return t2.g.find(((t3) => "undefined" != typeof WebGLTexture && t3 instanceof WebGLTexture));
    default:
      throw Error(`Type is not supported: ${e2}`);
  }
}
function da(t2) {
  var e2 = la(t2, 1);
  if (!e2) {
    if (e2 = la(t2, 0)) e2 = new Float32Array(e2).map(((t3) => t3 / 255));
    else {
      e2 = new Float32Array(t2.width * t2.height);
      const r2 = pa(t2);
      var n2 = ma(t2);
      if (oa(n2, r2, fa(t2)), "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "document" in self && "ontouchend" in self.document) {
        n2 = new Float32Array(t2.width * t2.height * 4), r2.readPixels(0, 0, t2.width, t2.height, r2.RGBA, r2.FLOAT, n2);
        for (let t3 = 0, r3 = 0; t3 < e2.length; ++t3, r3 += 4) e2[t3] = n2[r3];
      } else r2.readPixels(0, 0, t2.width, t2.height, r2.RED, r2.FLOAT, e2);
    }
    t2.g.push(e2);
  }
  return e2;
}
function fa(t2) {
  let e2 = la(t2, 2);
  if (!e2) {
    const n2 = pa(t2);
    e2 = ya(t2);
    const r2 = da(t2), i2 = ga(t2);
    n2.texImage2D(n2.TEXTURE_2D, 0, i2, t2.width, t2.height, 0, n2.RED, n2.FLOAT, r2), _a(t2);
  }
  return e2;
}
function pa(t2) {
  if (!t2.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return t2.h || (t2.h = Qo(t2.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t2.h;
}
function ga(t2) {
  if (t2 = pa(t2), !va) if (t2.getExtension("EXT_color_buffer_float") && t2.getExtension("OES_texture_float_linear") && t2.getExtension("EXT_float_blend")) va = t2.R32F;
  else {
    if (!t2.getExtension("EXT_color_buffer_half_float")) throw Error("GPU does not fully support 4-channel float32 or float16 formats");
    va = t2.R16F;
  }
  return va;
}
function ma(t2) {
  return t2.l || (t2.l = new ca()), t2.l;
}
function ya(t2) {
  const e2 = pa(t2);
  e2.viewport(0, 0, t2.width, t2.height), e2.activeTexture(e2.TEXTURE0);
  let n2 = la(t2, 2);
  return n2 || (n2 = sa(ma(t2), e2, t2.m ? e2.LINEAR : e2.NEAREST), t2.g.push(n2), t2.j = true), e2.bindTexture(e2.TEXTURE_2D, n2), n2;
}
function _a(t2) {
  t2.h.bindTexture(t2.h.TEXTURE_2D, null);
}
var va;
var Ea = class {
  constructor(t2, e2, n2, r2, i2, s2, o2) {
    this.g = t2, this.m = e2, this.j = n2, this.canvas = r2, this.l = i2, this.width = s2, this.height = o2, this.j && (0 === --wa && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources."));
  }
  Da() {
    return !!la(this, 0);
  }
  ja() {
    return !!la(this, 1);
  }
  R() {
    return !!la(this, 2);
  }
  ia() {
    return (e2 = la(t2 = this, 0)) || (e2 = da(t2), e2 = new Uint8Array(e2.map(((t3) => 255 * t3))), t2.g.push(e2)), e2;
    var t2, e2;
  }
  ha() {
    return da(this);
  }
  N() {
    return fa(this);
  }
  clone() {
    const t2 = [];
    for (const e2 of this.g) {
      let n2;
      if (e2 instanceof Uint8Array) n2 = new Uint8Array(e2);
      else if (e2 instanceof Float32Array) n2 = new Float32Array(e2);
      else {
        if (!(e2 instanceof WebGLTexture)) throw Error(`Type is not supported: ${e2}`);
        {
          const t3 = pa(this), e3 = ma(this);
          t3.activeTexture(t3.TEXTURE1), n2 = sa(e3, t3, this.m ? t3.LINEAR : t3.NEAREST), t3.bindTexture(t3.TEXTURE_2D, n2);
          const r2 = ga(this);
          t3.texImage2D(t3.TEXTURE_2D, 0, r2, this.width, this.height, 0, t3.RED, t3.FLOAT, null), t3.bindTexture(t3.TEXTURE_2D, null), oa(e3, t3, n2), ia(e3, t3, false, (() => {
            ya(this), t3.clearColor(0, 0, 0, 0), t3.clear(t3.COLOR_BUFFER_BIT), t3.drawArrays(t3.TRIANGLE_FAN, 0, 4), _a(this);
          })), aa(e3), _a(this);
        }
      }
      t2.push(n2);
    }
    return new Ea(t2, this.m, this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && pa(this).deleteTexture(la(this, 2)), wa = -1;
  }
};
Ea.prototype.close = Ea.prototype.close, Ea.prototype.clone = Ea.prototype.clone, Ea.prototype.getAsWebGLTexture = Ea.prototype.N, Ea.prototype.getAsFloat32Array = Ea.prototype.ha, Ea.prototype.getAsUint8Array = Ea.prototype.ia, Ea.prototype.hasWebGLTexture = Ea.prototype.R, Ea.prototype.hasFloat32Array = Ea.prototype.ja, Ea.prototype.hasUint8Array = Ea.prototype.Da;
var wa = 250;
var Ta = { color: "white", lineWidth: 4, radius: 6 };
function Aa(t2) {
  return { ...Ta, fillColor: (t2 = t2 || {}).color, ...t2 };
}
function ba(t2, e2) {
  return t2 instanceof Function ? t2(e2) : t2;
}
function ka(t2, e2, n2) {
  return Math.max(Math.min(e2, n2), Math.min(Math.max(e2, n2), t2));
}
function Sa(t2) {
  if (!t2.l) throw Error("CPU rendering requested but CanvasRenderingContext2D not provided.");
  return t2.l;
}
function xa(t2) {
  if (!t2.j) throw Error("GPU rendering requested but WebGL2RenderingContext not provided.");
  return t2.j;
}
function La(t2, e2, n2) {
  if (e2.R()) n2(e2.N());
  else {
    const r2 = e2.ja() ? e2.ha() : e2.ia();
    t2.m = t2.m ?? new ca();
    const i2 = xa(t2);
    n2((t2 = new Ea([r2], e2.m, false, i2.canvas, t2.m, e2.width, e2.height)).N()), t2.close();
  }
}
function Ra(t2, e2, n2, r2) {
  const i2 = (function(t3) {
    return t3.g || (t3.g = new ha()), t3.g;
  })(t2), s2 = xa(t2), o2 = Array.isArray(n2) ? new ImageData(new Uint8ClampedArray(n2), 1, 1) : n2;
  ia(i2, s2, true, (() => {
    !(function(t4, e3, n3, r3) {
      const i3 = t4.g;
      if (i3.activeTexture(i3.TEXTURE0), i3.bindTexture(i3.TEXTURE_2D, e3), i3.activeTexture(i3.TEXTURE1), i3.bindTexture(i3.TEXTURE_2D, t4.B), i3.texImage2D(i3.TEXTURE_2D, 0, i3.RGBA, i3.RGBA, i3.UNSIGNED_BYTE, n3), t4.H && (function(t5, e4) {
        if (t5 !== e4) return false;
        t5 = t5.entries(), e4 = e4.entries();
        for (const [r4, i4] of t5) {
          t5 = r4;
          const s3 = i4;
          var n4 = e4.next();
          if (n4.done) return false;
          const [o3, a2] = n4.value;
          if (n4 = a2, t5 !== o3 || s3[0] !== n4[0] || s3[1] !== n4[1] || s3[2] !== n4[2] || s3[3] !== n4[3]) return false;
        }
        return !!e4.next().done;
      })(t4.H, r3)) i3.activeTexture(i3.TEXTURE2), i3.bindTexture(i3.TEXTURE_2D, t4.j);
      else {
        t4.H = r3;
        const e4 = Array(1024).fill(0);
        r3.forEach(((t5, n4) => {
          if (4 !== t5.length) throw Error(`Color at index ${n4} is not a four-channel value.`);
          e4[4 * n4] = t5[0], e4[4 * n4 + 1] = t5[1], e4[4 * n4 + 2] = t5[2], e4[4 * n4 + 3] = t5[3];
        })), i3.activeTexture(i3.TEXTURE2), i3.bindTexture(i3.TEXTURE_2D, t4.j), i3.texImage2D(i3.TEXTURE_2D, 0, i3.RGBA, 256, 1, 0, i3.RGBA, i3.UNSIGNED_BYTE, new Uint8Array(e4));
      }
    })(i2, e2, o2, r2), s2.clearColor(0, 0, 0, 0), s2.clear(s2.COLOR_BUFFER_BIT), s2.drawArrays(s2.TRIANGLE_FAN, 0, 4);
    const t3 = i2.g;
    t3.activeTexture(t3.TEXTURE0), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE1), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE2), t3.bindTexture(t3.TEXTURE_2D, null);
  }));
}
function Fa(t2, e2, n2, r2) {
  const i2 = xa(t2), s2 = (function(t3) {
    return t3.h || (t3.h = new ua()), t3.h;
  })(t2), o2 = Array.isArray(n2) ? new ImageData(new Uint8ClampedArray(n2), 1, 1) : n2, a2 = Array.isArray(r2) ? new ImageData(new Uint8ClampedArray(r2), 1, 1) : r2;
  ia(s2, i2, true, (() => {
    var t3 = s2.g;
    t3.activeTexture(t3.TEXTURE0), t3.bindTexture(t3.TEXTURE_2D, e2), t3.activeTexture(t3.TEXTURE1), t3.bindTexture(t3.TEXTURE_2D, s2.j), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, o2), t3.activeTexture(t3.TEXTURE2), t3.bindTexture(t3.TEXTURE_2D, s2.B), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, a2), i2.clearColor(0, 0, 0, 0), i2.clear(i2.COLOR_BUFFER_BIT), i2.drawArrays(i2.TRIANGLE_FAN, 0, 4), i2.bindTexture(i2.TEXTURE_2D, null), (t3 = s2.g).activeTexture(t3.TEXTURE0), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE1), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE2), t3.bindTexture(t3.TEXTURE_2D, null);
  }));
}
var Ia = class {
  constructor(t2, e2) {
    "undefined" != typeof CanvasRenderingContext2D && t2 instanceof CanvasRenderingContext2D || t2 instanceof OffscreenCanvasRenderingContext2D ? (this.l = t2, this.j = e2) : this.j = t2;
  }
  wa(t2, e2) {
    if (t2) {
      var n2 = Sa(this);
      e2 = Aa(e2), n2.save();
      var r2 = n2.canvas, i2 = 0;
      for (const s2 of t2) n2.fillStyle = ba(e2.fillColor, { index: i2, from: s2 }), n2.strokeStyle = ba(e2.color, { index: i2, from: s2 }), n2.lineWidth = ba(e2.lineWidth, { index: i2, from: s2 }), (t2 = new Path2D()).arc(s2.x * r2.width, s2.y * r2.height, ba(e2.radius, { index: i2, from: s2 }), 0, 2 * Math.PI), n2.fill(t2), n2.stroke(t2), ++i2;
      n2.restore();
    }
  }
  va(t2, e2, n2) {
    if (t2 && e2) {
      var r2 = Sa(this);
      n2 = Aa(n2), r2.save();
      var i2 = r2.canvas, s2 = 0;
      for (const o2 of e2) {
        r2.beginPath(), e2 = t2[o2.start];
        const a2 = t2[o2.end];
        e2 && a2 && (r2.strokeStyle = ba(n2.color, { index: s2, from: e2, to: a2 }), r2.lineWidth = ba(n2.lineWidth, { index: s2, from: e2, to: a2 }), r2.moveTo(e2.x * i2.width, e2.y * i2.height), r2.lineTo(a2.x * i2.width, a2.y * i2.height)), ++s2, r2.stroke();
      }
      r2.restore();
    }
  }
  sa(t2, e2) {
    const n2 = Sa(this);
    e2 = Aa(e2), n2.save(), n2.beginPath(), n2.lineWidth = ba(e2.lineWidth, {}), n2.strokeStyle = ba(e2.color, {}), n2.fillStyle = ba(e2.fillColor, {}), n2.moveTo(t2.originX, t2.originY), n2.lineTo(t2.originX + t2.width, t2.originY), n2.lineTo(t2.originX + t2.width, t2.originY + t2.height), n2.lineTo(t2.originX, t2.originY + t2.height), n2.lineTo(t2.originX, t2.originY), n2.stroke(), n2.fill(), n2.restore();
  }
  ta(t2, e2, n2 = [0, 0, 0, 255]) {
    this.l ? (function(t3, e3, n3, r2) {
      const i2 = xa(t3);
      La(t3, e3, ((e4) => {
        Ra(t3, e4, n3, r2), (e4 = Sa(t3)).drawImage(i2.canvas, 0, 0, e4.canvas.width, e4.canvas.height);
      }));
    })(this, t2, n2, e2) : Ra(this, t2.N(), n2, e2);
  }
  ua(t2, e2, n2) {
    this.l ? (function(t3, e3, n3, r2) {
      const i2 = xa(t3);
      La(t3, e3, ((e4) => {
        Fa(t3, e4, n3, r2), (e4 = Sa(t3)).drawImage(i2.canvas, 0, 0, e4.canvas.width, e4.canvas.height);
      }));
    })(this, t2, e2, n2) : Fa(this, t2.N(), e2, n2);
  }
  close() {
    this.g?.close(), this.g = void 0, this.h?.close(), this.h = void 0, this.m?.close(), this.m = void 0;
  }
};
function Ma(t2, e2) {
  switch (e2) {
    case 0:
      return t2.g.find(((t3) => t3 instanceof ImageData));
    case 1:
      return t2.g.find(((t3) => "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap));
    case 2:
      return t2.g.find(((t3) => "undefined" != typeof WebGLTexture && t3 instanceof WebGLTexture));
    default:
      throw Error(`Type is not supported: ${e2}`);
  }
}
function Pa(t2) {
  var e2 = Ma(t2, 0);
  if (!e2) {
    e2 = Oa(t2);
    const n2 = Ua(t2), r2 = new Uint8Array(t2.width * t2.height * 4);
    oa(n2, e2, Ca(t2)), e2.readPixels(0, 0, t2.width, t2.height, e2.RGBA, e2.UNSIGNED_BYTE, r2), aa(n2), e2 = new ImageData(new Uint8ClampedArray(r2.buffer), t2.width, t2.height), t2.g.push(e2);
  }
  return e2;
}
function Ca(t2) {
  let e2 = Ma(t2, 2);
  if (!e2) {
    const n2 = Oa(t2);
    e2 = Da(t2);
    const r2 = Ma(t2, 1) || Pa(t2);
    n2.texImage2D(n2.TEXTURE_2D, 0, n2.RGBA, n2.RGBA, n2.UNSIGNED_BYTE, r2), Na(t2);
  }
  return e2;
}
function Oa(t2) {
  if (!t2.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return t2.h || (t2.h = Qo(t2.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t2.h;
}
function Ua(t2) {
  return t2.l || (t2.l = new ca()), t2.l;
}
function Da(t2) {
  const e2 = Oa(t2);
  e2.viewport(0, 0, t2.width, t2.height), e2.activeTexture(e2.TEXTURE0);
  let n2 = Ma(t2, 2);
  return n2 || (n2 = sa(Ua(t2), e2), t2.g.push(n2), t2.m = true), e2.bindTexture(e2.TEXTURE_2D, n2), n2;
}
function Na(t2) {
  t2.h.bindTexture(t2.h.TEXTURE_2D, null);
}
function Ba(t2) {
  const e2 = Oa(t2);
  return ia(Ua(t2), e2, true, (() => (function(t3, e3) {
    const n2 = t3.canvas;
    if (n2.width === t3.width && n2.height === t3.height) return e3();
    const r2 = n2.width, i2 = n2.height;
    return n2.width = t3.width, n2.height = t3.height, t3 = e3(), n2.width = r2, n2.height = i2, t3;
  })(t2, (() => {
    if (e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.clearColor(0, 0, 0, 0), e2.clear(e2.COLOR_BUFFER_BIT), e2.drawArrays(e2.TRIANGLE_FAN, 0, 4), !(t2.canvas instanceof OffscreenCanvas)) throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
    return t2.canvas.transferToImageBitmap();
  }))));
}
Ia.prototype.close = Ia.prototype.close, Ia.prototype.drawConfidenceMask = Ia.prototype.ua, Ia.prototype.drawCategoryMask = Ia.prototype.ta, Ia.prototype.drawBoundingBox = Ia.prototype.sa, Ia.prototype.drawConnectors = Ia.prototype.va, Ia.prototype.drawLandmarks = Ia.prototype.wa, Ia.lerp = function(t2, e2, n2, r2, i2) {
  return ka(r2 * (1 - (t2 - e2) / (n2 - e2)) + i2 * (1 - (n2 - t2) / (n2 - e2)), r2, i2);
}, Ia.clamp = ka;
var Ga = class {
  constructor(t2, e2, n2, r2, i2, s2, o2) {
    this.g = t2, this.j = e2, this.m = n2, this.canvas = r2, this.l = i2, this.width = s2, this.height = o2, (this.j || this.m) && (0 === --ja && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources."));
  }
  Ca() {
    return !!Ma(this, 0);
  }
  ka() {
    return !!Ma(this, 1);
  }
  R() {
    return !!Ma(this, 2);
  }
  Aa() {
    return Pa(this);
  }
  za() {
    var t2 = Ma(this, 1);
    return t2 || (Ca(this), Da(this), t2 = Ba(this), Na(this), this.g.push(t2), this.j = true), t2;
  }
  N() {
    return Ca(this);
  }
  clone() {
    const t2 = [];
    for (const e2 of this.g) {
      let n2;
      if (e2 instanceof ImageData) n2 = new ImageData(e2.data, this.width, this.height);
      else if (e2 instanceof WebGLTexture) {
        const t3 = Oa(this), e3 = Ua(this);
        t3.activeTexture(t3.TEXTURE1), n2 = sa(e3, t3), t3.bindTexture(t3.TEXTURE_2D, n2), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, this.width, this.height, 0, t3.RGBA, t3.UNSIGNED_BYTE, null), t3.bindTexture(t3.TEXTURE_2D, null), oa(e3, t3, n2), ia(e3, t3, false, (() => {
          Da(this), t3.clearColor(0, 0, 0, 0), t3.clear(t3.COLOR_BUFFER_BIT), t3.drawArrays(t3.TRIANGLE_FAN, 0, 4), Na(this);
        })), aa(e3), Na(this);
      } else {
        if (!(e2 instanceof ImageBitmap)) throw Error(`Type is not supported: ${e2}`);
        Ca(this), Da(this), n2 = Ba(this), Na(this);
      }
      t2.push(n2);
    }
    return new Ga(t2, this.ka(), this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && Ma(this, 1).close(), this.m && Oa(this).deleteTexture(Ma(this, 2)), ja = -1;
  }
};
Ga.prototype.close = Ga.prototype.close, Ga.prototype.clone = Ga.prototype.clone, Ga.prototype.getAsWebGLTexture = Ga.prototype.N, Ga.prototype.getAsImageBitmap = Ga.prototype.za, Ga.prototype.getAsImageData = Ga.prototype.Aa, Ga.prototype.hasWebGLTexture = Ga.prototype.R, Ga.prototype.hasImageBitmap = Ga.prototype.ka, Ga.prototype.hasImageData = Ga.prototype.Ca;
var ja = 250;
function Va(...t2) {
  return t2.map((([t3, e2]) => ({ start: t3, end: e2 })));
}
var Xa = /* @__PURE__ */ (function(t2) {
  return class extends t2 {
    Ha() {
      this.i._registerModelResourcesGraphService();
    }
  };
})((Ha = class {
  constructor(t2, e2) {
    this.l = true, this.i = t2, this.g = null, this.h = 0, this.m = "function" == typeof this.i._addIntToInputStream, void 0 !== e2 ? this.i.canvas = e2 : Do() ? this.i.canvas = new OffscreenCanvas(1, 1) : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.i.canvas = document.createElement("canvas"));
  }
  async initializeGraph(t2) {
    const e2 = await (await fetch(t2)).arrayBuffer();
    t2 = !(t2.endsWith(".pbtxt") || t2.endsWith(".textproto")), this.setGraph(new Uint8Array(e2), t2);
  }
  setGraphFromString(t2) {
    this.setGraph(new TextEncoder().encode(t2), false);
  }
  setGraph(t2, e2) {
    const n2 = t2.length, r2 = this.i._malloc(n2);
    this.i.HEAPU8.set(t2, r2), e2 ? this.i._changeBinaryGraph(n2, r2) : this.i._changeTextGraph(n2, r2), this.i._free(r2);
  }
  configureAudio(t2, e2, n2, r2, i2) {
    this.i._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), Go(this, r2 || "input_audio", ((r3) => {
      Go(this, i2 = i2 || "audio_header", ((i3) => {
        this.i._configureAudio(r3, i3, t2, e2 ?? 0, n2);
      }));
    }));
  }
  setAutoResizeCanvas(t2) {
    this.l = t2;
  }
  setAutoRenderToScreen(t2) {
    this.i._setAutoRenderToScreen(t2);
  }
  setGpuBufferVerticalFlip(t2) {
    this.i.gpuOriginForWebTexturesIsBottomLeft = t2;
  }
  ca(t2) {
    Xo(this, "__graph_config__", ((e2) => {
      t2(e2);
    })), Go(this, "__graph_config__", ((t3) => {
      this.i._getGraphConfig(t3, void 0);
    })), delete this.i.simpleListeners.__graph_config__;
  }
  attachErrorListener(t2) {
    this.i.errorListener = t2;
  }
  attachEmptyPacketListener(t2, e2) {
    this.i.emptyPacketListeners = this.i.emptyPacketListeners || {}, this.i.emptyPacketListeners[t2] = e2;
  }
  addAudioToStream(t2, e2, n2) {
    this.addAudioToStreamWithShape(t2, 0, 0, e2, n2);
  }
  addAudioToStreamWithShape(t2, e2, n2, r2, i2) {
    const s2 = 4 * t2.length;
    this.h !== s2 && (this.g && this.i._free(this.g), this.g = this.i._malloc(s2), this.h = s2), this.i.HEAPF32.set(t2, this.g / 4), Go(this, r2, ((t3) => {
      this.i._addAudioToInputStream(this.g, e2, n2, t3, i2);
    }));
  }
  addGpuBufferToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const [r2, i2] = jo(this, t2, e3);
      this.i._addBoundTextureToStream(e3, r2, i2, n2);
    }));
  }
  addBoolToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      this.i._addBoolToInputStream(t2, e3, n2);
    }));
  }
  addDoubleToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      this.i._addDoubleToInputStream(t2, e3, n2);
    }));
  }
  addFloatToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      this.i._addFloatToInputStream(t2, e3, n2);
    }));
  }
  addIntToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      this.i._addIntToInputStream(t2, e3, n2);
    }));
  }
  addUintToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      this.i._addUintToInputStream(t2, e3, n2);
    }));
  }
  addStringToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      Go(this, t2, ((t3) => {
        this.i._addStringToInputStream(t3, e3, n2);
      }));
    }));
  }
  addStringRecordToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      Vo(this, Object.keys(t2), ((r2) => {
        Vo(this, Object.values(t2), ((i2) => {
          this.i._addFlatHashMapToInputStream(r2, i2, Object.keys(t2).length, e3, n2);
        }));
      }));
    }));
  }
  addProtoToStream(t2, e2, n2, r2) {
    Go(this, n2, ((n3) => {
      Go(this, e2, ((e3) => {
        const i2 = this.i._malloc(t2.length);
        this.i.HEAPU8.set(t2, i2), this.i._addProtoToInputStream(i2, t2.length, e3, n3, r2), this.i._free(i2);
      }));
    }));
  }
  addEmptyPacketToStream(t2, e2) {
    Go(this, t2, ((t3) => {
      this.i._addEmptyPacketToInputStream(t3, e2);
    }));
  }
  addBoolVectorToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const r2 = this.i._allocateBoolVector(t2.length);
      if (!r2) throw Error("Unable to allocate new bool vector on heap.");
      for (const e4 of t2) this.i._addBoolVectorEntry(r2, e4);
      this.i._addBoolVectorToInputStream(r2, e3, n2);
    }));
  }
  addDoubleVectorToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const r2 = this.i._allocateDoubleVector(t2.length);
      if (!r2) throw Error("Unable to allocate new double vector on heap.");
      for (const e4 of t2) this.i._addDoubleVectorEntry(r2, e4);
      this.i._addDoubleVectorToInputStream(r2, e3, n2);
    }));
  }
  addFloatVectorToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const r2 = this.i._allocateFloatVector(t2.length);
      if (!r2) throw Error("Unable to allocate new float vector on heap.");
      for (const e4 of t2) this.i._addFloatVectorEntry(r2, e4);
      this.i._addFloatVectorToInputStream(r2, e3, n2);
    }));
  }
  addIntVectorToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const r2 = this.i._allocateIntVector(t2.length);
      if (!r2) throw Error("Unable to allocate new int vector on heap.");
      for (const e4 of t2) this.i._addIntVectorEntry(r2, e4);
      this.i._addIntVectorToInputStream(r2, e3, n2);
    }));
  }
  addUintVectorToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const r2 = this.i._allocateUintVector(t2.length);
      if (!r2) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const e4 of t2) this.i._addUintVectorEntry(r2, e4);
      this.i._addUintVectorToInputStream(r2, e3, n2);
    }));
  }
  addStringVectorToStream(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const r2 = this.i._allocateStringVector(t2.length);
      if (!r2) throw Error("Unable to allocate new string vector on heap.");
      for (const e4 of t2) Go(this, e4, ((t3) => {
        this.i._addStringVectorEntry(r2, t3);
      }));
      this.i._addStringVectorToInputStream(r2, e3, n2);
    }));
  }
  addBoolToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      this.i._addBoolToInputSidePacket(t2, e3);
    }));
  }
  addDoubleToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      this.i._addDoubleToInputSidePacket(t2, e3);
    }));
  }
  addFloatToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      this.i._addFloatToInputSidePacket(t2, e3);
    }));
  }
  addIntToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      this.i._addIntToInputSidePacket(t2, e3);
    }));
  }
  addUintToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      this.i._addUintToInputSidePacket(t2, e3);
    }));
  }
  addStringToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      Go(this, t2, ((t3) => {
        this.i._addStringToInputSidePacket(t3, e3);
      }));
    }));
  }
  addProtoToInputSidePacket(t2, e2, n2) {
    Go(this, n2, ((n3) => {
      Go(this, e2, ((e3) => {
        const r2 = this.i._malloc(t2.length);
        this.i.HEAPU8.set(t2, r2), this.i._addProtoToInputSidePacket(r2, t2.length, e3, n3), this.i._free(r2);
      }));
    }));
  }
  addBoolVectorToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      const n2 = this.i._allocateBoolVector(t2.length);
      if (!n2) throw Error("Unable to allocate new bool vector on heap.");
      for (const e4 of t2) this.i._addBoolVectorEntry(n2, e4);
      this.i._addBoolVectorToInputSidePacket(n2, e3);
    }));
  }
  addDoubleVectorToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      const n2 = this.i._allocateDoubleVector(t2.length);
      if (!n2) throw Error("Unable to allocate new double vector on heap.");
      for (const e4 of t2) this.i._addDoubleVectorEntry(n2, e4);
      this.i._addDoubleVectorToInputSidePacket(n2, e3);
    }));
  }
  addFloatVectorToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      const n2 = this.i._allocateFloatVector(t2.length);
      if (!n2) throw Error("Unable to allocate new float vector on heap.");
      for (const e4 of t2) this.i._addFloatVectorEntry(n2, e4);
      this.i._addFloatVectorToInputSidePacket(n2, e3);
    }));
  }
  addIntVectorToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      const n2 = this.i._allocateIntVector(t2.length);
      if (!n2) throw Error("Unable to allocate new int vector on heap.");
      for (const e4 of t2) this.i._addIntVectorEntry(n2, e4);
      this.i._addIntVectorToInputSidePacket(n2, e3);
    }));
  }
  addUintVectorToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      const n2 = this.i._allocateUintVector(t2.length);
      if (!n2) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const e4 of t2) this.i._addUintVectorEntry(n2, e4);
      this.i._addUintVectorToInputSidePacket(n2, e3);
    }));
  }
  addStringVectorToInputSidePacket(t2, e2) {
    Go(this, e2, ((e3) => {
      const n2 = this.i._allocateStringVector(t2.length);
      if (!n2) throw Error("Unable to allocate new string vector on heap.");
      for (const e4 of t2) Go(this, e4, ((t3) => {
        this.i._addStringVectorEntry(n2, t3);
      }));
      this.i._addStringVectorToInputSidePacket(n2, e3);
    }));
  }
  attachBoolListener(t2, e2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachBoolListener(t3);
    }));
  }
  attachBoolVectorListener(t2, e2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachBoolVectorListener(t3);
    }));
  }
  attachIntListener(t2, e2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachIntListener(t3);
    }));
  }
  attachIntVectorListener(t2, e2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachIntVectorListener(t3);
    }));
  }
  attachUintListener(t2, e2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachUintListener(t3);
    }));
  }
  attachUintVectorListener(t2, e2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachUintVectorListener(t3);
    }));
  }
  attachDoubleListener(t2, e2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachDoubleListener(t3);
    }));
  }
  attachDoubleVectorListener(t2, e2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachDoubleVectorListener(t3);
    }));
  }
  attachFloatListener(t2, e2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachFloatListener(t3);
    }));
  }
  attachFloatVectorListener(t2, e2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachFloatVectorListener(t3);
    }));
  }
  attachStringListener(t2, e2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachStringListener(t3);
    }));
  }
  attachStringVectorListener(t2, e2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachStringVectorListener(t3);
    }));
  }
  attachProtoListener(t2, e2, n2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachProtoListener(t3, n2 || false);
    }));
  }
  attachProtoVectorListener(t2, e2, n2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.i._attachProtoVectorListener(t3, n2 || false);
    }));
  }
  attachAudioListener(t2, e2, n2) {
    this.i._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), Xo(this, t2, ((t3, n3) => {
      t3 = new Float32Array(t3.buffer, t3.byteOffset, t3.length / 4), e2(t3, n3);
    })), Go(this, t2, ((t3) => {
      this.i._attachAudioListener(t3, n2 || false);
    }));
  }
  finishProcessing() {
    this.i._waitUntilIdle();
  }
  closeGraph() {
    this.i._closeGraph(), this.i.simpleListeners = void 0, this.i.emptyPacketListeners = void 0;
  }
}, class extends Ha {
  get ea() {
    return this.i;
  }
  oa(t2, e2, n2) {
    Go(this, e2, ((e3) => {
      const [r2, i2] = jo(this, t2, e3);
      this.ea._addBoundTextureAsImageToStream(e3, r2, i2, n2);
    }));
  }
  V(t2, e2) {
    Xo(this, t2, e2), Go(this, t2, ((t3) => {
      this.ea._attachImageListener(t3);
    }));
  }
  ba(t2, e2) {
    Ho(this, t2, e2), Go(this, t2, ((t3) => {
      this.ea._attachImageVectorListener(t3);
    }));
  }
}));
var Ha;
var Wa = class extends Xa {
};
async function za(t2, e2, n2) {
  return (async function(t3, e3, n3, r2) {
    return Wo(t3, e3, n3, r2);
  })(t2, n2.canvas ?? (Do() ? void 0 : document.createElement("canvas")), e2, n2);
}
function Ka(t2, e2, n2, r2) {
  if (t2.U) {
    const s2 = new ms();
    if (n2?.regionOfInterest) {
      if (!t2.na) throw Error("This task doesn't support region-of-interest.");
      var i2 = n2.regionOfInterest;
      if (i2.left >= i2.right || i2.top >= i2.bottom) throw Error("Expected RectF with left < right and top < bottom.");
      if (i2.left < 0 || i2.top < 0 || i2.right > 1 || i2.bottom > 1) throw Error("Expected RectF values to be in [0,1].");
      An(s2, 1, (i2.left + i2.right) / 2), An(s2, 2, (i2.top + i2.bottom) / 2), An(s2, 4, i2.right - i2.left), An(s2, 3, i2.bottom - i2.top);
    } else An(s2, 1, 0.5), An(s2, 2, 0.5), An(s2, 4, 1), An(s2, 3, 1);
    if (n2?.rotationDegrees) {
      if (n2?.rotationDegrees % 90 != 0) throw Error("Expected rotation to be a multiple of 90.");
      if (An(s2, 5, -Math.PI * n2.rotationDegrees / 180), n2?.rotationDegrees % 180 != 0) {
        const [t3, r3] = Bo(e2);
        n2 = En(s2, 3) * r3 / t3, i2 = En(s2, 4) * t3 / r3, An(s2, 4, n2), An(s2, 3, i2);
      }
    }
    t2.g.addProtoToStream(s2.g(), "mediapipe.NormalizedRect", t2.U, r2);
  }
  t2.g.oa(e2, t2.Z, r2 ?? performance.now()), t2.finishProcessing();
}
function Ya(t2, e2, n2) {
  if (t2.baseOptions?.g()) throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
  Ka(t2, e2, n2, t2.B + 1);
}
function $a(t2, e2, n2, r2) {
  if (!t2.baseOptions?.g()) throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
  Ka(t2, e2, n2, r2);
}
function qa(t2, e2, n2, r2) {
  var i2 = e2.data;
  const s2 = e2.width, o2 = s2 * (e2 = e2.height);
  if ((i2 instanceof Uint8Array || i2 instanceof Float32Array) && i2.length !== o2) throw Error("Unsupported channel count: " + i2.length / o2);
  return t2 = new Ea([i2], n2, false, t2.g.i.canvas, t2.P, s2, e2), r2 ? t2.clone() : t2;
}
var Ja = class extends Zo {
  constructor(t2, e2, n2, r2) {
    super(t2), this.g = t2, this.Z = e2, this.U = n2, this.na = r2, this.P = new ca();
  }
  l(t2, e2 = true) {
    if ("runningMode" in t2 && wn(this.baseOptions, 2, !!t2.runningMode && "IMAGE" !== t2.runningMode), void 0 !== t2.canvas && this.g.i.canvas !== t2.canvas) throw Error("You must create a new task to reset the canvas.");
    return super.l(t2, e2);
  }
  close() {
    this.P.close(), super.close();
  }
};
Ja.prototype.close = Ja.prototype.close;
var Za = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect_in", false), this.j = { detections: [] }, dn(t2 = this.h = new Cs(), 0, 1, e2 = new Is()), An(this.h, 2, 0.5), An(this.h, 3, 0.3);
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return "minDetectionConfidence" in t2 && An(this.h, 2, t2.minDetectionConfidence ?? 0.5), "minSuppressionThreshold" in t2 && An(this.h, 3, t2.minSuppressionThreshold ?? 0.3), this.l(t2);
  }
  D(t2, e2) {
    return this.j = { detections: [] }, Ya(this, t2, e2), this.j;
  }
  F(t2, e2, n2) {
    return this.j = { detections: [] }, $a(this, t2, n2, e2), this.j;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect_in"), Zi(t2, "detections");
    const e2 = new Gi();
    Yn(e2, Us, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect_in"), Wi(n2, "DETECTIONS:detections"), n2.o(e2), qi(t2, n2), this.g.attachProtoVectorListener("detections", ((t3, e3) => {
      for (const e4 of t3) t3 = hs(e4), this.j.detections.push(xo(t3));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("detections", ((t3) => {
      Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
Za.prototype.detectForVideo = Za.prototype.F, Za.prototype.detect = Za.prototype.D, Za.prototype.setOptions = Za.prototype.o, Za.createFromModelPath = async function(t2, e2) {
  return za(Za, t2, { baseOptions: { modelAssetPath: e2 } });
}, Za.createFromModelBuffer = function(t2, e2) {
  return za(Za, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, Za.createFromOptions = function(t2, e2) {
  return za(Za, t2, e2);
};
var Qa = Va([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]);
var tc = Va([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]);
var ec = Va([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]);
var nc = Va([474, 475], [475, 476], [476, 477], [477, 474]);
var rc = Va([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]);
var ic = Va([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]);
var sc = Va([469, 470], [470, 471], [471, 472], [472, 469]);
var oc = Va([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]);
var ac = [...Qa, ...tc, ...ec, ...rc, ...ic, ...oc];
var cc = Va([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
function hc(t2) {
  t2.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
}
var uc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect", false), this.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }, this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = false, dn(t2 = this.h = new Bs(), 0, 1, e2 = new Is()), this.v = new Ns(), dn(this.h, 0, 3, this.v), this.s = new Cs(), dn(this.h, 0, 2, this.s), Tn(this.s, 4, 1), An(this.s, 2, 0.5), An(this.v, 2, 0.5), An(this.h, 4, 0.5);
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return "numFaces" in t2 && Tn(this.s, 4, t2.numFaces ?? 1), "minFaceDetectionConfidence" in t2 && An(this.s, 2, t2.minFaceDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && An(this.h, 4, t2.minTrackingConfidence ?? 0.5), "minFacePresenceConfidence" in t2 && An(this.v, 2, t2.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t2 && (this.outputFaceBlendshapes = !!t2.outputFaceBlendshapes), "outputFacialTransformationMatrixes" in t2 && (this.outputFacialTransformationMatrixes = !!t2.outputFacialTransformationMatrixes), this.l(t2);
  }
  D(t2, e2) {
    return hc(this), Ya(this, t2, e2), this.j;
  }
  F(t2, e2, n2) {
    return hc(this), $a(this, t2, n2, e2), this.j;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect"), Zi(t2, "face_landmarks");
    const e2 = new Gi();
    Yn(e2, Vs, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "NORM_LANDMARKS:face_landmarks"), n2.o(e2), qi(t2, n2), this.g.attachProtoVectorListener("face_landmarks", ((t3, e3) => {
      for (const e4 of t3) t3 = fs(e4), this.j.faceLandmarks.push(Lo(t3));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("face_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.outputFaceBlendshapes && (Zi(t2, "blendshapes"), Wi(n2, "BLENDSHAPES:blendshapes"), this.g.attachProtoVectorListener("blendshapes", ((t3, e3) => {
      if (this.outputFaceBlendshapes) for (const e4 of t3) t3 = ss(e4), this.j.faceBlendshapes.push(So(t3.g() ?? []));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("blendshapes", ((t3) => {
      Yo(this, t3);
    }))), this.outputFacialTransformationMatrixes && (Zi(t2, "face_geometry"), Wi(n2, "FACE_GEOMETRY:face_geometry"), this.g.attachProtoVectorListener("face_geometry", ((t3, e3) => {
      if (this.outputFacialTransformationMatrixes) for (const e4 of t3) (t3 = hn(Ds(e4), ps, 2)) && this.j.facialTransformationMatrixes.push({ rows: _n(t3, 1) ?? 0 ?? 0, columns: _n(t3, 2) ?? 0 ?? 0, data: $e(t3, 3, qt, Ye()).slice() ?? [] });
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("face_geometry", ((t3) => {
      Yo(this, t3);
    }))), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
uc.prototype.detectForVideo = uc.prototype.F, uc.prototype.detect = uc.prototype.D, uc.prototype.setOptions = uc.prototype.o, uc.createFromModelPath = function(t2, e2) {
  return za(uc, t2, { baseOptions: { modelAssetPath: e2 } });
}, uc.createFromModelBuffer = function(t2, e2) {
  return za(uc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, uc.createFromOptions = function(t2, e2) {
  return za(uc, t2, e2);
}, uc.FACE_LANDMARKS_LIPS = Qa, uc.FACE_LANDMARKS_LEFT_EYE = tc, uc.FACE_LANDMARKS_LEFT_EYEBROW = ec, uc.FACE_LANDMARKS_LEFT_IRIS = nc, uc.FACE_LANDMARKS_RIGHT_EYE = rc, uc.FACE_LANDMARKS_RIGHT_EYEBROW = ic, uc.FACE_LANDMARKS_RIGHT_IRIS = sc, uc.FACE_LANDMARKS_FACE_OVAL = oc, uc.FACE_LANDMARKS_CONTOURS = ac, uc.FACE_LANDMARKS_TESSELATION = cc;
var lc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect", true), dn(t2 = this.j = new Xs(), 0, 1, e2 = new Is());
  }
  get baseOptions() {
    return hn(this.j, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.j, 0, 1, t2);
  }
  o(t2) {
    return super.l(t2);
  }
  Ka(t2, e2, n2) {
    const r2 = "function" != typeof e2 ? e2 : {};
    if (this.h = "function" == typeof e2 ? e2 : n2, Ya(this, t2, r2 ?? {}), !this.h) return this.s;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect"), Zi(t2, "stylized_image");
    const e2 = new Gi();
    Yn(e2, Hs, this.j);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "STYLIZED_IMAGE:stylized_image"), n2.o(e2), qi(t2, n2), this.g.V("stylized_image", ((t3, e3) => {
      var n3 = !this.h, r2 = t3.data, i2 = t3.width;
      const s2 = i2 * (t3 = t3.height);
      if (r2 instanceof Uint8Array) if (r2.length === 3 * s2) {
        const e4 = new Uint8ClampedArray(4 * s2);
        for (let t4 = 0; t4 < s2; ++t4) e4[4 * t4] = r2[3 * t4], e4[4 * t4 + 1] = r2[3 * t4 + 1], e4[4 * t4 + 2] = r2[3 * t4 + 2], e4[4 * t4 + 3] = 255;
        r2 = new ImageData(e4, i2, t3);
      } else {
        if (r2.length !== 4 * s2) throw Error("Unsupported channel count: " + r2.length / s2);
        r2 = new ImageData(new Uint8ClampedArray(r2.buffer, r2.byteOffset, r2.length), i2, t3);
      }
      else if (!(r2 instanceof WebGLTexture)) throw Error(`Unsupported format: ${r2.constructor.name}`);
      i2 = new Ga([r2], false, false, this.g.i.canvas, this.P, i2, t3), this.s = n3 = n3 ? i2.clone() : i2, this.h && this.h(n3), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("stylized_image", ((t3) => {
      this.s = null, this.h && this.h(null), Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
lc.prototype.stylize = lc.prototype.Ka, lc.prototype.setOptions = lc.prototype.o, lc.createFromModelPath = function(t2, e2) {
  return za(lc, t2, { baseOptions: { modelAssetPath: e2 } });
}, lc.createFromModelBuffer = function(t2, e2) {
  return za(lc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, lc.createFromOptions = function(t2, e2) {
  return za(lc, t2, e2);
};
var dc = Va([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
function fc(t2) {
  t2.gestures = [], t2.landmarks = [], t2.worldLandmarks = [], t2.handedness = [];
}
function pc(t2) {
  return 0 === t2.gestures.length ? { gestures: [], landmarks: [], worldLandmarks: [], handedness: [], handednesses: [] } : { gestures: t2.gestures, landmarks: t2.landmarks, worldLandmarks: t2.worldLandmarks, handedness: t2.handedness, handednesses: t2.handedness };
}
function gc(t2, e2 = true) {
  const n2 = [];
  for (const i2 of t2) {
    var r2 = ss(i2);
    t2 = [];
    for (const n3 of r2.g()) r2 = e2 && null != _n(n3, 1) ? _n(n3, 1) ?? 0 : -1, t2.push({ score: En(n3, 2) ?? 0, index: r2, categoryName: vn(n3, 3) ?? "" ?? "", displayName: vn(n3, 4) ?? "" ?? "" });
    n2.push(t2);
  }
  return n2;
}
var mc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect", false), this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handedness = [], dn(t2 = this.j = new Js(), 0, 1, e2 = new Is()), this.s = new qs(), dn(this.j, 0, 2, this.s), this.C = new $s(), dn(this.s, 0, 3, this.C), this.v = new Ys(), dn(this.s, 0, 2, this.v), this.h = new Ks(), dn(this.j, 0, 3, this.h), An(this.v, 2, 0.5), An(this.s, 4, 0.5), An(this.C, 2, 0.5);
  }
  get baseOptions() {
    return hn(this.j, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.j, 0, 1, t2);
  }
  o(t2) {
    if (Tn(this.v, 3, t2.numHands ?? 1), "minHandDetectionConfidence" in t2 && An(this.v, 2, t2.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && An(this.s, 4, t2.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t2 && An(this.C, 2, t2.minHandPresenceConfidence ?? 0.5), t2.cannedGesturesClassifierOptions) {
      var e2 = new Ws(), n2 = e2, r2 = ko(t2.cannedGesturesClassifierOptions, hn(this.h, Ws, 3)?.h());
      dn(n2, 0, 2, r2), dn(this.h, 0, 3, e2);
    } else void 0 === t2.cannedGesturesClassifierOptions && hn(this.h, Ws, 3)?.g();
    return t2.customGesturesClassifierOptions ? (dn(n2 = e2 = new Ws(), 0, 2, r2 = ko(t2.customGesturesClassifierOptions, hn(this.h, Ws, 4)?.h())), dn(this.h, 0, 4, e2)) : void 0 === t2.customGesturesClassifierOptions && hn(this.h, Ws, 4)?.g(), this.l(t2);
  }
  Fa(t2, e2) {
    return fc(this), Ya(this, t2, e2), pc(this);
  }
  Ga(t2, e2, n2) {
    return fc(this), $a(this, t2, n2, e2), pc(this);
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect"), Zi(t2, "hand_gestures"), Zi(t2, "hand_landmarks"), Zi(t2, "world_hand_landmarks"), Zi(t2, "handedness");
    const e2 = new Gi();
    Yn(e2, no, this.j);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "HAND_GESTURES:hand_gestures"), Wi(n2, "LANDMARKS:hand_landmarks"), Wi(n2, "WORLD_LANDMARKS:world_hand_landmarks"), Wi(n2, "HANDEDNESS:handedness"), n2.o(e2), qi(t2, n2), this.g.attachProtoVectorListener("hand_landmarks", ((t3, e3) => {
      for (const e4 of t3) {
        t3 = fs(e4);
        const n3 = [];
        for (const e5 of ln(t3, ds, 1)) n3.push({ x: En(e5, 1) ?? 0, y: En(e5, 2) ?? 0, z: En(e5, 3) ?? 0, visibility: En(e5, 4) ?? 0 });
        this.landmarks.push(n3);
      }
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("hand_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoVectorListener("world_hand_landmarks", ((t3, e3) => {
      for (const e4 of t3) {
        t3 = ls(e4);
        const n3 = [];
        for (const e5 of ln(t3, us, 1)) n3.push({ x: En(e5, 1) ?? 0, y: En(e5, 2) ?? 0, z: En(e5, 3) ?? 0, visibility: En(e5, 4) ?? 0 });
        this.worldLandmarks.push(n3);
      }
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("world_hand_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoVectorListener("hand_gestures", ((t3, e3) => {
      this.gestures.push(...gc(t3, false)), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("hand_gestures", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoVectorListener("handedness", ((t3, e3) => {
      this.handedness.push(...gc(t3)), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("handedness", ((t3) => {
      Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
function yc(t2) {
  return { landmarks: t2.landmarks, worldLandmarks: t2.worldLandmarks, handednesses: t2.handedness, handedness: t2.handedness };
}
mc.prototype.recognizeForVideo = mc.prototype.Ga, mc.prototype.recognize = mc.prototype.Fa, mc.prototype.setOptions = mc.prototype.o, mc.createFromModelPath = function(t2, e2) {
  return za(mc, t2, { baseOptions: { modelAssetPath: e2 } });
}, mc.createFromModelBuffer = function(t2, e2) {
  return za(mc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, mc.createFromOptions = function(t2, e2) {
  return za(mc, t2, e2);
}, mc.HAND_CONNECTIONS = dc;
var _c = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.handedness = [], dn(t2 = this.h = new qs(), 0, 1, e2 = new Is()), this.s = new $s(), dn(this.h, 0, 3, this.s), this.j = new Ys(), dn(this.h, 0, 2, this.j), Tn(this.j, 3, 1), An(this.j, 2, 0.5), An(this.s, 2, 0.5), An(this.h, 4, 0.5);
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return "numHands" in t2 && Tn(this.j, 3, t2.numHands ?? 1), "minHandDetectionConfidence" in t2 && An(this.j, 2, t2.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && An(this.h, 4, t2.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t2 && An(this.s, 2, t2.minHandPresenceConfidence ?? 0.5), this.l(t2);
  }
  D(t2, e2) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], Ya(this, t2, e2), yc(this);
  }
  F(t2, e2, n2) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], $a(this, t2, n2, e2), yc(this);
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect"), Zi(t2, "hand_landmarks"), Zi(t2, "world_hand_landmarks"), Zi(t2, "handedness");
    const e2 = new Gi();
    Yn(e2, ro, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "LANDMARKS:hand_landmarks"), Wi(n2, "WORLD_LANDMARKS:world_hand_landmarks"), Wi(n2, "HANDEDNESS:handedness"), n2.o(e2), qi(t2, n2), this.g.attachProtoVectorListener("hand_landmarks", ((t3, e3) => {
      for (const e4 of t3) t3 = fs(e4), this.landmarks.push(Lo(t3));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("hand_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoVectorListener("world_hand_landmarks", ((t3, e3) => {
      for (const e4 of t3) t3 = ls(e4), this.worldLandmarks.push(Ro(t3));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("world_hand_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoVectorListener("handedness", ((t3, e3) => {
      var n3 = this.handedness, r2 = n3.push;
      const i2 = [];
      for (const e4 of t3) {
        t3 = ss(e4);
        const n4 = [];
        for (const e5 of t3.g()) n4.push({ score: En(e5, 2) ?? 0, index: _n(e5, 1) ?? 0 ?? -1, categoryName: vn(e5, 3) ?? "" ?? "", displayName: vn(e5, 4) ?? "" ?? "" });
        i2.push(n4);
      }
      r2.call(n3, ...i2), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("handedness", ((t3) => {
      Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
_c.prototype.detectForVideo = _c.prototype.F, _c.prototype.detect = _c.prototype.D, _c.prototype.setOptions = _c.prototype.o, _c.createFromModelPath = function(t2, e2) {
  return za(_c, t2, { baseOptions: { modelAssetPath: e2 } });
}, _c.createFromModelBuffer = function(t2, e2) {
  return za(_c, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, _c.createFromOptions = function(t2, e2) {
  return za(_c, t2, e2);
}, _c.HAND_CONNECTIONS = dc;
var vc = Va([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
function Ec(t2) {
  t2.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] };
}
function wc(t2) {
  try {
    if (!t2.C) return t2.h;
    t2.C(t2.h);
  } finally {
    Jo(t2);
  }
}
function Tc(t2, e2) {
  t2 = fs(t2), e2.push(Lo(t2));
}
var Ac = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "input_frames_image", null, false), this.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] }, this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = false, dn(t2 = this.j = new ao(), 0, 1, e2 = new Is()), this.K = new $s(), dn(this.j, 0, 2, this.K), this.Y = new io(), dn(this.j, 0, 3, this.Y), this.s = new Cs(), dn(this.j, 0, 4, this.s), this.H = new Ns(), dn(this.j, 0, 5, this.H), this.v = new so(), dn(this.j, 0, 6, this.v), this.L = new oo(), dn(this.j, 0, 7, this.L), An(this.s, 2, 0.5), An(this.s, 3, 0.3), An(this.H, 2, 0.5), An(this.v, 2, 0.5), An(this.v, 3, 0.3), An(this.L, 2, 0.5), An(this.K, 2, 0.5);
  }
  get baseOptions() {
    return hn(this.j, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.j, 0, 1, t2);
  }
  o(t2) {
    return "minFaceDetectionConfidence" in t2 && An(this.s, 2, t2.minFaceDetectionConfidence ?? 0.5), "minFaceSuppressionThreshold" in t2 && An(this.s, 3, t2.minFaceSuppressionThreshold ?? 0.3), "minFacePresenceConfidence" in t2 && An(this.H, 2, t2.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t2 && (this.outputFaceBlendshapes = !!t2.outputFaceBlendshapes), "minPoseDetectionConfidence" in t2 && An(this.v, 2, t2.minPoseDetectionConfidence ?? 0.5), "minPoseSuppressionThreshold" in t2 && An(this.v, 3, t2.minPoseSuppressionThreshold ?? 0.3), "minPosePresenceConfidence" in t2 && An(this.L, 2, t2.minPosePresenceConfidence ?? 0.5), "outputPoseSegmentationMasks" in t2 && (this.outputPoseSegmentationMasks = !!t2.outputPoseSegmentationMasks), "minHandLandmarksConfidence" in t2 && An(this.K, 2, t2.minHandLandmarksConfidence ?? 0.5), this.l(t2);
  }
  D(t2, e2, n2) {
    const r2 = "function" != typeof e2 ? e2 : {};
    return this.C = "function" == typeof e2 ? e2 : n2, Ec(this), Ya(this, t2, r2), wc(this);
  }
  F(t2, e2, n2, r2) {
    const i2 = "function" != typeof n2 ? n2 : {};
    return this.C = "function" == typeof n2 ? n2 : r2, Ec(this), $a(this, t2, i2, e2), wc(this);
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "input_frames_image"), Zi(t2, "pose_landmarks"), Zi(t2, "pose_world_landmarks"), Zi(t2, "face_landmarks"), Zi(t2, "left_hand_landmarks"), Zi(t2, "left_hand_world_landmarks"), Zi(t2, "right_hand_landmarks"), Zi(t2, "right_hand_world_landmarks");
    const e2 = new Gi(), n2 = new xi();
    tn(n2, 1, de("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""), (function(t3, e3) {
      if (null != e3) if (Array.isArray(e3)) He(t3, 2, Pe(e3, Oe, void 0, void 0, false));
      else {
        if (!("string" == typeof e3 || e3 instanceof N || C(e3))) throw Error("invalid value in Any.value field: " + e3 + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
        tn(t3, 2, dt(e3, false), U());
      }
    })(n2, this.j.g());
    const r2 = new zi();
    Xi(r2, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"), yn(r2, 8, xi, n2), Hi(r2, "IMAGE:input_frames_image"), Wi(r2, "POSE_LANDMARKS:pose_landmarks"), Wi(r2, "POSE_WORLD_LANDMARKS:pose_world_landmarks"), Wi(r2, "FACE_LANDMARKS:face_landmarks"), Wi(r2, "LEFT_HAND_LANDMARKS:left_hand_landmarks"), Wi(r2, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"), Wi(r2, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"), Wi(r2, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"), r2.o(e2), qi(t2, r2), $o(this, t2), this.g.attachProtoListener("pose_landmarks", ((t3, e3) => {
      Tc(t3, this.h.poseLandmarks), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("pose_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoListener("pose_world_landmarks", ((t3, e3) => {
      var n3 = this.h.poseWorldLandmarks;
      t3 = ls(t3), n3.push(Ro(t3)), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("pose_world_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.outputPoseSegmentationMasks && (Wi(r2, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"), qo(this, "pose_segmentation_mask"), this.g.V("pose_segmentation_mask", ((t3, e3) => {
      this.h.poseSegmentationMasks = [qa(this, t3, true, !this.C)], Yo(this, e3);
    })), this.g.attachEmptyPacketListener("pose_segmentation_mask", ((t3) => {
      this.h.poseSegmentationMasks = [], Yo(this, t3);
    }))), this.g.attachProtoListener("face_landmarks", ((t3, e3) => {
      Tc(t3, this.h.faceLandmarks), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("face_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.outputFaceBlendshapes && (Zi(t2, "extra_blendshapes"), Wi(r2, "FACE_BLENDSHAPES:extra_blendshapes"), this.g.attachProtoListener("extra_blendshapes", ((t3, e3) => {
      var n3 = this.h.faceBlendshapes;
      this.outputFaceBlendshapes && (t3 = ss(t3), n3.push(So(t3.g() ?? []))), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("extra_blendshapes", ((t3) => {
      Yo(this, t3);
    }))), this.g.attachProtoListener("left_hand_landmarks", ((t3, e3) => {
      Tc(t3, this.h.leftHandLandmarks), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("left_hand_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoListener("left_hand_world_landmarks", ((t3, e3) => {
      var n3 = this.h.leftHandWorldLandmarks;
      t3 = ls(t3), n3.push(Ro(t3)), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("left_hand_world_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoListener("right_hand_landmarks", ((t3, e3) => {
      Tc(t3, this.h.rightHandLandmarks), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("right_hand_landmarks", ((t3) => {
      Yo(this, t3);
    })), this.g.attachProtoListener("right_hand_world_landmarks", ((t3, e3) => {
      var n3 = this.h.rightHandWorldLandmarks;
      t3 = ls(t3), n3.push(Ro(t3)), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("right_hand_world_landmarks", ((t3) => {
      Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
Ac.prototype.detectForVideo = Ac.prototype.F, Ac.prototype.detect = Ac.prototype.D, Ac.prototype.setOptions = Ac.prototype.o, Ac.createFromModelPath = function(t2, e2) {
  return za(Ac, t2, { baseOptions: { modelAssetPath: e2 } });
}, Ac.createFromModelBuffer = function(t2, e2) {
  return za(Ac, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, Ac.createFromOptions = function(t2, e2) {
  return za(Ac, t2, e2);
}, Ac.HAND_CONNECTIONS = dc, Ac.POSE_CONNECTIONS = vc, Ac.FACE_LANDMARKS_LIPS = Qa, Ac.FACE_LANDMARKS_LEFT_EYE = tc, Ac.FACE_LANDMARKS_LEFT_EYEBROW = ec, Ac.FACE_LANDMARKS_LEFT_IRIS = nc, Ac.FACE_LANDMARKS_RIGHT_EYE = rc, Ac.FACE_LANDMARKS_RIGHT_EYEBROW = ic, Ac.FACE_LANDMARKS_RIGHT_IRIS = sc, Ac.FACE_LANDMARKS_FACE_OVAL = oc, Ac.FACE_LANDMARKS_CONTOURS = ac, Ac.FACE_LANDMARKS_TESSELATION = cc;
var bc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "input_image", "norm_rect", true), this.j = { classifications: [] }, dn(t2 = this.h = new uo(), 0, 1, e2 = new Is());
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return dn(this.h, 0, 2, ko(t2, hn(this.h, bs, 2))), this.l(t2);
  }
  qa(t2, e2) {
    return this.j = { classifications: [] }, Ya(this, t2, e2), this.j;
  }
  ra(t2, e2, n2) {
    return this.j = { classifications: [] }, $a(this, t2, n2, e2), this.j;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "input_image"), Ji(t2, "norm_rect"), Zi(t2, "classifications");
    const e2 = new Gi();
    Yn(e2, lo, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), Hi(n2, "IMAGE:input_image"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "CLASSIFICATIONS:classifications"), n2.o(e2), qi(t2, n2), this.g.attachProtoListener("classifications", ((t3, e3) => {
      this.j = (function(t4) {
        const e4 = { classifications: ln(t4, ys, 1).map(((t5) => So(hn(t5, rs, 4)?.g() ?? [], _n(t5, 2) ?? 0, vn(t5, 3) ?? ""))) };
        return null != he(Ve(t4, 2)) && (e4.timestampMs = he(Ve(t4, 2)) ?? 0), e4;
      })(_s(t3)), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("classifications", ((t3) => {
      Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
bc.prototype.classifyForVideo = bc.prototype.ra, bc.prototype.classify = bc.prototype.qa, bc.prototype.setOptions = bc.prototype.o, bc.createFromModelPath = function(t2, e2) {
  return za(bc, t2, { baseOptions: { modelAssetPath: e2 } });
}, bc.createFromModelBuffer = function(t2, e2) {
  return za(bc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, bc.createFromOptions = function(t2, e2) {
  return za(bc, t2, e2);
};
var kc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect", true), this.h = new fo(), this.embeddings = { embeddings: [] }, dn(t2 = this.h, 0, 1, e2 = new Is());
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    var e2 = this.h, n2 = hn(this.h, Ss, 2);
    return n2 = n2 ? n2.clone() : new Ss(), void 0 !== t2.l2Normalize ? wn(n2, 1, t2.l2Normalize) : "l2Normalize" in t2 && He(n2, 1), void 0 !== t2.quantize ? wn(n2, 2, t2.quantize) : "quantize" in t2 && He(n2, 2), dn(e2, 0, 2, n2), this.l(t2);
  }
  xa(t2, e2) {
    return Ya(this, t2, e2), this.embeddings;
  }
  ya(t2, e2, n2) {
    return $a(this, t2, n2, e2), this.embeddings;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect"), Zi(t2, "embeddings_out");
    const e2 = new Gi();
    Yn(e2, po, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "EMBEDDINGS:embeddings_out"), n2.o(e2), qi(t2, n2), this.g.attachProtoListener("embeddings_out", ((t3, e3) => {
      t3 = As(t3), this.embeddings = (function(t4) {
        return { embeddings: ln(t4, ws, 1).map(((t5) => {
          const e4 = { headIndex: _n(t5, 3) ?? 0 ?? -1, headName: vn(t5, 4) ?? "" ?? "" };
          if (void 0 !== cn(t5, vs, nn(t5, 1))) t5 = $e(t5 = hn(t5, vs, nn(t5, 1)), 1, qt, Ye()), e4.floatEmbedding = t5.slice();
          else {
            const n3 = new Uint8Array(0);
            e4.quantizedEmbedding = hn(t5, Es, nn(t5, 2))?.ma()?.h() ?? n3;
          }
          return e4;
        })), timestampMs: he(Ve(t4, 2)) ?? 0 };
      })(t3), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("embeddings_out", ((t3) => {
      Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
kc.cosineSimilarity = function(t2, e2) {
  if (t2.floatEmbedding && e2.floatEmbedding) t2 = Io(t2.floatEmbedding, e2.floatEmbedding);
  else {
    if (!t2.quantizedEmbedding || !e2.quantizedEmbedding) throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
    t2 = Io(Fo(t2.quantizedEmbedding), Fo(e2.quantizedEmbedding));
  }
  return t2;
}, kc.prototype.embedForVideo = kc.prototype.ya, kc.prototype.embed = kc.prototype.xa, kc.prototype.setOptions = kc.prototype.o, kc.createFromModelPath = function(t2, e2) {
  return za(kc, t2, { baseOptions: { modelAssetPath: e2 } });
}, kc.createFromModelBuffer = function(t2, e2) {
  return za(kc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, kc.createFromOptions = function(t2, e2) {
  return za(kc, t2, e2);
};
var Sc = class {
  constructor(t2, e2, n2) {
    this.confidenceMasks = t2, this.categoryMask = e2, this.qualityScores = n2;
  }
  close() {
    this.confidenceMasks?.forEach(((t2) => {
      t2.close();
    })), this.categoryMask?.close();
  }
};
function xc(t2) {
  t2.categoryMask = void 0, t2.confidenceMasks = void 0, t2.qualityScores = void 0;
}
function Lc(t2) {
  try {
    const e2 = new Sc(t2.confidenceMasks, t2.categoryMask, t2.qualityScores);
    if (!t2.j) return e2;
    t2.j(e2);
  } finally {
    Jo(t2);
  }
}
Sc.prototype.close = Sc.prototype.close;
var Rc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect", false), this.s = [], this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new vo(), this.v = new go(), dn(this.h, 0, 3, this.v), dn(t2 = this.h, 0, 1, e2 = new Is());
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return void 0 !== t2.displayNamesLocale ? He(this.h, 2, de(t2.displayNamesLocale)) : "displayNamesLocale" in t2 && He(this.h, 2), "outputCategoryMask" in t2 && (this.outputCategoryMask = t2.outputCategoryMask ?? false), "outputConfidenceMasks" in t2 && (this.outputConfidenceMasks = t2.outputConfidenceMasks ?? true), super.l(t2);
  }
  J() {
    !(function(t2) {
      const e2 = ln(t2.ca(), zi, 1).filter(((t3) => (vn(t3, 1) ?? "").includes("mediapipe.tasks.TensorsToSegmentationCalculator")));
      if (t2.s = [], e2.length > 1) throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
      1 === e2.length && (hn(e2[0], Gi, 7)?.l()?.g() ?? /* @__PURE__ */ new Map()).forEach(((e3, n2) => {
        t2.s[Number(n2)] = vn(e3, 1) ?? "";
      }));
    })(this);
  }
  segment(t2, e2, n2) {
    const r2 = "function" != typeof e2 ? e2 : {};
    return this.j = "function" == typeof e2 ? e2 : n2, xc(this), Ya(this, t2, r2), Lc(this);
  }
  Ia(t2, e2, n2, r2) {
    const i2 = "function" != typeof n2 ? n2 : {};
    return this.j = "function" == typeof n2 ? n2 : r2, xc(this), $a(this, t2, i2, e2), Lc(this);
  }
  Ba() {
    return this.s;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect");
    const e2 = new Gi();
    Yn(e2, Eo, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect"), n2.o(e2), qi(t2, n2), $o(this, t2), this.outputConfidenceMasks && (Zi(t2, "confidence_masks"), Wi(n2, "CONFIDENCE_MASKS:confidence_masks"), qo(this, "confidence_masks"), this.g.ba("confidence_masks", ((t3, e3) => {
      this.confidenceMasks = t3.map(((t4) => qa(this, t4, true, !this.j))), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("confidence_masks", ((t3) => {
      this.confidenceMasks = [], Yo(this, t3);
    }))), this.outputCategoryMask && (Zi(t2, "category_mask"), Wi(n2, "CATEGORY_MASK:category_mask"), qo(this, "category_mask"), this.g.V("category_mask", ((t3, e3) => {
      this.categoryMask = qa(this, t3, false, !this.j), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("category_mask", ((t3) => {
      this.categoryMask = void 0, Yo(this, t3);
    }))), Zi(t2, "quality_scores"), Wi(n2, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", ((t3, e3) => {
      this.qualityScores = t3, Yo(this, e3);
    })), this.g.attachEmptyPacketListener("quality_scores", ((t3) => {
      this.categoryMask = void 0, Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
Rc.prototype.getLabels = Rc.prototype.Ba, Rc.prototype.segmentForVideo = Rc.prototype.Ia, Rc.prototype.segment = Rc.prototype.segment, Rc.prototype.setOptions = Rc.prototype.o, Rc.createFromModelPath = function(t2, e2) {
  return za(Rc, t2, { baseOptions: { modelAssetPath: e2 } });
}, Rc.createFromModelBuffer = function(t2, e2) {
  return za(Rc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, Rc.createFromOptions = function(t2, e2) {
  return za(Rc, t2, e2);
};
var Fc = class {
  constructor(t2, e2, n2) {
    this.confidenceMasks = t2, this.categoryMask = e2, this.qualityScores = n2;
  }
  close() {
    this.confidenceMasks?.forEach(((t2) => {
      t2.close();
    })), this.categoryMask?.close();
  }
};
Fc.prototype.close = Fc.prototype.close;
var Ic = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Mc = [0, hi, -2];
var Pc = [0, ni, -3, di, ni, -1];
var Cc = [0, Pc];
var Oc = [0, Pc, hi, -1];
var Uc = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Dc = [0, ni, -1, di];
var Nc = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Bc = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
var Gc = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15];
var jc = class extends $n {
  constructor(t2) {
    super(t2);
  }
};
jc.prototype.g = Si([0, yi, [0, Gc, _i, Pc, _i, [0, Pc, Mc], _i, Cc, _i, [0, Cc, Mc], _i, Dc, _i, [0, ni, -3, di, Ti], _i, [0, ni, -3, di], _i, [0, mi, ni, -2, di, hi, di, -1, 2, ni, Mc], _i, Oc, _i, [0, Oc, Mc], ni, Mc, mi, _i, [0, ni, -3, di, Mc, -1], _i, [0, yi, Dc]], mi, [0, mi, hi, -1, di]]);
var Vc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect_in", false), this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new vo(), this.s = new go(), dn(this.h, 0, 3, this.s), dn(t2 = this.h, 0, 1, e2 = new Is());
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return "outputCategoryMask" in t2 && (this.outputCategoryMask = t2.outputCategoryMask ?? false), "outputConfidenceMasks" in t2 && (this.outputConfidenceMasks = t2.outputConfidenceMasks ?? true), super.l(t2);
  }
  segment(t2, e2, n2, r2) {
    const i2 = "function" != typeof n2 ? n2 : {};
    this.j = "function" == typeof n2 ? n2 : r2, this.qualityScores = this.categoryMask = this.confidenceMasks = void 0, n2 = this.B + 1, r2 = new jc();
    const s2 = new Bc();
    var o2 = new Ic();
    if (Tn(o2, 1, 255), dn(s2, 0, 12, o2), e2.keypoint && e2.scribble) throw Error("Cannot provide both keypoint and scribble.");
    if (e2.keypoint) {
      var a2 = new Uc();
      wn(a2, 3, true), An(a2, 1, e2.keypoint.x), An(a2, 2, e2.keypoint.y), fn(s2, 5, Gc, a2);
    } else {
      if (!e2.scribble) throw Error("Must provide either a keypoint or a scribble.");
      for (a2 of (o2 = new Nc(), e2.scribble)) wn(e2 = new Uc(), 3, true), An(e2, 1, a2.x), An(e2, 2, a2.y), yn(o2, 1, Uc, e2);
      fn(s2, 15, Gc, o2);
    }
    yn(r2, 1, Bc, s2), this.g.addProtoToStream(r2.g(), "drishti.RenderData", "roi_in", n2), Ya(this, t2, i2);
    t: {
      try {
        const t3 = new Fc(this.confidenceMasks, this.categoryMask, this.qualityScores);
        if (!this.j) {
          var c2 = t3;
          break t;
        }
        this.j(t3);
      } finally {
        Jo(this);
      }
      c2 = void 0;
    }
    return c2;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "roi_in"), Ji(t2, "norm_rect_in");
    const e2 = new Gi();
    Yn(e2, Eo, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "ROI:roi_in"), Hi(n2, "NORM_RECT:norm_rect_in"), n2.o(e2), qi(t2, n2), $o(this, t2), this.outputConfidenceMasks && (Zi(t2, "confidence_masks"), Wi(n2, "CONFIDENCE_MASKS:confidence_masks"), qo(this, "confidence_masks"), this.g.ba("confidence_masks", ((t3, e3) => {
      this.confidenceMasks = t3.map(((t4) => qa(this, t4, true, !this.j))), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("confidence_masks", ((t3) => {
      this.confidenceMasks = [], Yo(this, t3);
    }))), this.outputCategoryMask && (Zi(t2, "category_mask"), Wi(n2, "CATEGORY_MASK:category_mask"), qo(this, "category_mask"), this.g.V("category_mask", ((t3, e3) => {
      this.categoryMask = qa(this, t3, false, !this.j), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("category_mask", ((t3) => {
      this.categoryMask = void 0, Yo(this, t3);
    }))), Zi(t2, "quality_scores"), Wi(n2, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", ((t3, e3) => {
      this.qualityScores = t3, Yo(this, e3);
    })), this.g.attachEmptyPacketListener("quality_scores", ((t3) => {
      this.categoryMask = void 0, Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
Vc.prototype.segment = Vc.prototype.segment, Vc.prototype.setOptions = Vc.prototype.o, Vc.createFromModelPath = function(t2, e2) {
  return za(Vc, t2, { baseOptions: { modelAssetPath: e2 } });
}, Vc.createFromModelBuffer = function(t2, e2) {
  return za(Vc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, Vc.createFromOptions = function(t2, e2) {
  return za(Vc, t2, e2);
};
var Xc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "input_frame_gpu", "norm_rect", false), this.j = { detections: [] }, dn(t2 = this.h = new wo(), 0, 1, e2 = new Is());
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return void 0 !== t2.displayNamesLocale ? He(this.h, 2, de(t2.displayNamesLocale)) : "displayNamesLocale" in t2 && He(this.h, 2), void 0 !== t2.maxResults ? Tn(this.h, 3, t2.maxResults) : "maxResults" in t2 && He(this.h, 3), void 0 !== t2.scoreThreshold ? An(this.h, 4, t2.scoreThreshold) : "scoreThreshold" in t2 && He(this.h, 4), void 0 !== t2.categoryAllowlist ? bn(this.h, 5, t2.categoryAllowlist) : "categoryAllowlist" in t2 && He(this.h, 5), void 0 !== t2.categoryDenylist ? bn(this.h, 6, t2.categoryDenylist) : "categoryDenylist" in t2 && He(this.h, 6), this.l(t2);
  }
  D(t2, e2) {
    return this.j = { detections: [] }, Ya(this, t2, e2), this.j;
  }
  F(t2, e2, n2) {
    return this.j = { detections: [] }, $a(this, t2, n2, e2), this.j;
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "input_frame_gpu"), Ji(t2, "norm_rect"), Zi(t2, "detections");
    const e2 = new Gi();
    Yn(e2, To, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.ObjectDetectorGraph"), Hi(n2, "IMAGE:input_frame_gpu"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "DETECTIONS:detections"), n2.o(e2), qi(t2, n2), this.g.attachProtoVectorListener("detections", ((t3, e3) => {
      for (const e4 of t3) t3 = hs(e4), this.j.detections.push(xo(t3));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("detections", ((t3) => {
      Yo(this, t3);
    })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
Xc.prototype.detectForVideo = Xc.prototype.F, Xc.prototype.detect = Xc.prototype.D, Xc.prototype.setOptions = Xc.prototype.o, Xc.createFromModelPath = async function(t2, e2) {
  return za(Xc, t2, { baseOptions: { modelAssetPath: e2 } });
}, Xc.createFromModelBuffer = function(t2, e2) {
  return za(Xc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, Xc.createFromOptions = function(t2, e2) {
  return za(Xc, t2, e2);
};
var Hc = class {
  constructor(t2, e2, n2) {
    this.landmarks = t2, this.worldLandmarks = e2, this.segmentationMasks = n2;
  }
  close() {
    this.segmentationMasks?.forEach(((t2) => {
      t2.close();
    }));
  }
};
function Wc(t2) {
  t2.landmarks = [], t2.worldLandmarks = [], t2.segmentationMasks = void 0;
}
function zc(t2) {
  try {
    const e2 = new Hc(t2.landmarks, t2.worldLandmarks, t2.segmentationMasks);
    if (!t2.s) return e2;
    t2.s(e2);
  } finally {
    Jo(t2);
  }
}
Hc.prototype.close = Hc.prototype.close;
var Kc = class extends Ja {
  constructor(t2, e2) {
    super(new Wa(t2, e2), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.outputSegmentationMasks = false, dn(t2 = this.h = new Ao(), 0, 1, e2 = new Is()), this.v = new oo(), dn(this.h, 0, 3, this.v), this.j = new so(), dn(this.h, 0, 2, this.j), Tn(this.j, 4, 1), An(this.j, 2, 0.5), An(this.v, 2, 0.5), An(this.h, 4, 0.5);
  }
  get baseOptions() {
    return hn(this.h, Is, 1);
  }
  set baseOptions(t2) {
    dn(this.h, 0, 1, t2);
  }
  o(t2) {
    return "numPoses" in t2 && Tn(this.j, 4, t2.numPoses ?? 1), "minPoseDetectionConfidence" in t2 && An(this.j, 2, t2.minPoseDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && An(this.h, 4, t2.minTrackingConfidence ?? 0.5), "minPosePresenceConfidence" in t2 && An(this.v, 2, t2.minPosePresenceConfidence ?? 0.5), "outputSegmentationMasks" in t2 && (this.outputSegmentationMasks = t2.outputSegmentationMasks ?? false), this.l(t2);
  }
  D(t2, e2, n2) {
    const r2 = "function" != typeof e2 ? e2 : {};
    return this.s = "function" == typeof e2 ? e2 : n2, Wc(this), Ya(this, t2, r2), zc(this);
  }
  F(t2, e2, n2, r2) {
    const i2 = "function" != typeof n2 ? n2 : {};
    return this.s = "function" == typeof n2 ? n2 : r2, Wc(this), $a(this, t2, i2, e2), zc(this);
  }
  m() {
    var t2 = new Qi();
    Ji(t2, "image_in"), Ji(t2, "norm_rect"), Zi(t2, "normalized_landmarks"), Zi(t2, "world_landmarks"), Zi(t2, "segmentation_masks");
    const e2 = new Gi();
    Yn(e2, bo, this.h);
    const n2 = new zi();
    Xi(n2, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), Hi(n2, "IMAGE:image_in"), Hi(n2, "NORM_RECT:norm_rect"), Wi(n2, "NORM_LANDMARKS:normalized_landmarks"), Wi(n2, "WORLD_LANDMARKS:world_landmarks"), n2.o(e2), qi(t2, n2), $o(this, t2), this.g.attachProtoVectorListener("normalized_landmarks", ((t3, e3) => {
      this.landmarks = [];
      for (const e4 of t3) t3 = fs(e4), this.landmarks.push(Lo(t3));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("normalized_landmarks", ((t3) => {
      this.landmarks = [], Yo(this, t3);
    })), this.g.attachProtoVectorListener("world_landmarks", ((t3, e3) => {
      this.worldLandmarks = [];
      for (const e4 of t3) t3 = ls(e4), this.worldLandmarks.push(Ro(t3));
      Yo(this, e3);
    })), this.g.attachEmptyPacketListener("world_landmarks", ((t3) => {
      this.worldLandmarks = [], Yo(this, t3);
    })), this.outputSegmentationMasks && (Wi(n2, "SEGMENTATION_MASK:segmentation_masks"), qo(this, "segmentation_masks"), this.g.ba("segmentation_masks", ((t3, e3) => {
      this.segmentationMasks = t3.map(((t4) => qa(this, t4, true, !this.s))), Yo(this, e3);
    })), this.g.attachEmptyPacketListener("segmentation_masks", ((t3) => {
      this.segmentationMasks = [], Yo(this, t3);
    }))), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
  }
};
Kc.prototype.detectForVideo = Kc.prototype.F, Kc.prototype.detect = Kc.prototype.D, Kc.prototype.setOptions = Kc.prototype.o, Kc.createFromModelPath = function(t2, e2) {
  return za(Kc, t2, { baseOptions: { modelAssetPath: e2 } });
}, Kc.createFromModelBuffer = function(t2, e2) {
  return za(Kc, t2, { baseOptions: { modelAssetBuffer: e2 } });
}, Kc.createFromOptions = function(t2, e2) {
  return za(Kc, t2, e2);
}, Kc.POSE_CONNECTIONS = vc;

// node_modules/@stream-io/video-filters-web/dist/index.es.js
var isMobile2 = () => /Mobi/i.test(navigator.userAgent);
var isSafari2 = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
var isPlatformSupported = async ({ forceMobileSupport = false, forceSafariSupport = false } = {}) => typeof document !== "undefined" && typeof window !== "undefined" && typeof navigator !== "undefined" && // we don't support mobile devices yet due to performance issues
(forceMobileSupport || !isMobile2()) && // Safari has issues with timer throttling, causing low FPS when the tab goes to the background
(forceSafariSupport || !isSafari2()) && typeof WebAssembly !== "undefined" && !!window.WebGL2RenderingContext && // WebGL2 is required for the video filters
!!document.createElement("canvas").getContext("webgl2") && await simd();
var isMediaPipePlatformSupported = async ({ forceMobileSupport = false, forceSafariSupport = false } = {}) => typeof document !== "undefined" && typeof window !== "undefined" && typeof navigator !== "undefined" && // we don't support mobile devices yet due to performance issues
(forceMobileSupport || !isMobile2()) && // Safari has issues with timer throttling, causing low FPS when the tab goes to the background
(forceSafariSupport || !isSafari2()) && typeof WebAssembly !== "undefined" && typeof OffscreenCanvas !== "undefined" && // OffscreenCanvas is required for efficient rendering
!!window.WebGL2RenderingContext && // WebGL2 is required for the video filters
!!new OffscreenCanvas(1, 1).getContext("webgl2") && typeof VideoFrame !== "undefined" && // VideoFrame API is required for frame processing
typeof createImageBitmap !== "undefined";
var glsl = String.raw;
function createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer) {
  const program = createProgram(gl, vertexShader, fragmentShader);
  const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(positionAttributeLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
  const texCoordAttributeLocation = gl.getAttribLocation(program, "a_texCoord");
  gl.enableVertexAttribArray(texCoordAttributeLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);
  return program;
}
function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error(`Could not link WebGL program: ${gl.getProgramInfoLog(program)}`);
  }
  return program;
}
function compileShader(gl, shaderType, shaderSource) {
  const shader = gl.createShader(shaderType);
  gl.shaderSource(shader, shaderSource);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    throw new Error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`);
  }
  return shader;
}
function createTexture(gl, internalformat, width, height, minFilter = gl.NEAREST, magFilter = gl.NEAREST) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
  gl.texStorage2D(gl.TEXTURE_2D, 1, internalformat, width, height);
  return texture;
}
async function readPixelsAsync(gl, x2, y2, width, height, format, type, dest) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
  gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
  gl.readPixels(x2, y2, width, height, format, type, 0);
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
  gl.deleteBuffer(buf);
  return dest;
}
async function getBufferSubDataAsync(gl, target, buffer2, srcByteOffset, dstBuffer, dstOffset, length) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  gl.flush();
  if (!sync)
    return;
  const res = await clientWaitAsync(gl, sync);
  gl.deleteSync(sync);
  if (res !== gl.WAIT_FAILED) {
    gl.bindBuffer(target, buffer2);
    gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
    gl.bindBuffer(target, null);
  }
}
function clientWaitAsync(gl, sync) {
  return new Promise((resolve) => {
    function test() {
      const res = gl.clientWaitSync(sync, 0, 0);
      if (res === gl.WAIT_FAILED) {
        resolve(res);
        return;
      }
      if (res === gl.TIMEOUT_EXPIRED) {
        setTimeout(test);
        return;
      }
      resolve(res);
    }
    setTimeout(test);
  });
}
function buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {
  const blurPass = buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel);
  const blendPass = buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas);
  function render() {
    blurPass.render();
    blendPass.render();
  }
  function updateCoverage(coverage) {
    blendPass.updateCoverage(coverage);
  }
  function cleanUp() {
    blendPass.cleanUp();
    blurPass.cleanUp();
  }
  return {
    render,
    updateCoverage,
    cleanUp
  };
}
function buildBlurPass(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel) {
  const sigma = typeof blurLevel === "number" ? blurLevel : blurLevel === "low" ? 2 : blurLevel === "medium" ? 4 : 6;
  const windowSize = Math.max(1, Math.floor(sigma * 3));
  const offset2 = new Array(windowSize).fill(0).map((v2, index) => index);
  const variance = sigma ** 2;
  const weights = offset2.map((x2) => {
    const m2 = sigma * Math.sqrt(2 * Math.PI);
    const e2 = Math.exp(-(x2 ** 2) / (2 * variance));
    return e2 / m2;
  });
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_personMask;
    uniform vec2 u_texelSize;

    in vec2 v_texCoord;
    out vec4 outColor;

    const float offset[${windowSize}] = float[](${offset2.map((i2) => i2.toFixed(10)).join(", ")});
    const float weight[${windowSize}] = float[](${weights.map((i2) => i2.toFixed(10)).join(", ")});

    void main() {
      vec4 centerColor = texture(u_inputFrame, v_texCoord);
      float personMask = texture(u_personMask, v_texCoord).a;

      vec4 frameColor = centerColor * weight[0] * (1.0 - personMask);

      for (int i = 1; i < ${windowSize}; i++) {
        vec2 offset = vec2(offset[i]) * u_texelSize;

        vec2 texCoord = v_texCoord + offset;
        frameColor += texture(u_inputFrame, texCoord)
           * weight[i]
           * (1.0 - texture(u_personMask, texCoord).a);

        texCoord = v_texCoord - offset;
        frameColor += texture(u_inputFrame, texCoord)
          * weight[i]
          * (1.0 - texture(u_personMask, texCoord).a);
      }
      outColor = vec4(frameColor.rgb + (1.0 - frameColor.a) * centerColor.rgb, 1.0);
    }
  `;
  const scale = 0.5;
  const outputWidth = canvas.width * scale;
  const outputHeight = canvas.height * scale;
  const texelWidth = 1 / outputWidth;
  const texelHeight = 1 / outputHeight;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const personMaskLocation = gl.getUniformLocation(program, "u_personMask");
  const texelSizeLocation = gl.getUniformLocation(program, "u_texelSize");
  const texture1 = createTexture(
    gl,
    gl.RGBA8,
    outputWidth,
    outputHeight,
    gl.NEAREST,
    // @ts-expect-error types are incomplete
    gl.LINEAR
  );
  const texture2 = createTexture(
    gl,
    gl.RGBA8,
    outputWidth,
    outputHeight,
    gl.NEAREST,
    // @ts-expect-error types are incomplete
    gl.LINEAR
  );
  const frameBuffer1 = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture1, 0);
  const frameBuffer2 = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture2, 0);
  gl.useProgram(program);
  gl.uniform1i(personMaskLocation, 1);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.uniform1i(inputFrameLocation, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);
    for (let i2 = 0; i2 < 3; i2++) {
      gl.uniform2f(texelSizeLocation, 0, texelHeight);
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, texture1);
      gl.uniform1i(inputFrameLocation, 2);
      gl.uniform2f(texelSizeLocation, texelWidth, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      gl.bindTexture(gl.TEXTURE_2D, texture2);
    }
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer2);
    gl.deleteFramebuffer(frameBuffer1);
    gl.deleteTexture(texture2);
    gl.deleteTexture(texture1);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return {
    render,
    cleanUp
  };
}
function buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas) {
  const vertexShaderSource = glsl`#version 300 es

    in vec2 a_position;
    in vec2 a_texCoord;

    out vec2 v_texCoord;

    void main() {
      // Flipping Y is required when rendering to canvas
      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_personMask;
    uniform sampler2D u_blurredInputFrame;
    uniform vec2 u_coverage;

    in vec2 v_texCoord;

    out vec4 outColor;

    void main() {
      vec3 color = texture(u_inputFrame, v_texCoord).rgb;
      vec3 blurredColor = texture(u_blurredInputFrame, v_texCoord).rgb;
      float personMask = texture(u_personMask, v_texCoord).a;
      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);
      outColor = vec4(mix(blurredColor, color, personMask), 1.0);
    }
  `;
  const { width: outputWidth, height: outputHeight } = canvas;
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const personMaskLocation = gl.getUniformLocation(program, "u_personMask");
  const blurredInputFrame = gl.getUniformLocation(program, "u_blurredInputFrame");
  const coverageLocation = gl.getUniformLocation(program, "u_coverage");
  gl.useProgram(program);
  gl.uniform1i(inputFrameLocation, 0);
  gl.uniform1i(personMaskLocation, 1);
  gl.uniform1i(blurredInputFrame, 2);
  gl.uniform2f(coverageLocation, 0, 1);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function updateCoverage(coverage) {
    gl.useProgram(program);
    gl.uniform2f(coverageLocation, coverage[0], coverage[1]);
  }
  function cleanUp() {
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
    gl.deleteShader(vertexShader);
  }
  return {
    render,
    updateCoverage,
    cleanUp
  };
}
function buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas) {
  const vertexShaderSource = glsl`#version 300 es

    uniform vec2 u_backgroundScale;
    uniform vec2 u_backgroundOffset;

    in vec2 a_position;
    in vec2 a_texCoord;

    out vec2 v_texCoord;
    out vec2 v_backgroundCoord;

    void main() {
      // Flipping Y is required when rendering to canvas
      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);
      v_texCoord = a_texCoord;
      v_backgroundCoord = a_texCoord * u_backgroundScale + u_backgroundOffset;
    }
  `;
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_personMask;
    uniform sampler2D u_background;
    uniform vec2 u_coverage;
    uniform float u_lightWrapping;
    uniform float u_blendMode;

    in vec2 v_texCoord;
    in vec2 v_backgroundCoord;

    out vec4 outColor;

    vec3 screen(vec3 a, vec3 b) {
      return 1.0 - (1.0 - a) * (1.0 - b);
    }

    vec3 linearDodge(vec3 a, vec3 b) {
      return a + b;
    }

    void main() {
      vec3 frameColor = texture(u_inputFrame, v_texCoord).rgb;
      vec3 backgroundColor = texture(u_background, v_backgroundCoord).rgb;
      float personMask = texture(u_personMask, v_texCoord).a;
      float lightWrapMask = 1.0 - max(0.0, personMask - u_coverage.y) / (1.0 - u_coverage.y);
      vec3 lightWrap = u_lightWrapping * lightWrapMask * backgroundColor;

      frameColor = u_blendMode * linearDodge(frameColor, lightWrap)
        + (1.0 - u_blendMode) * screen(frameColor, lightWrap);
      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);
      outColor = vec4(frameColor * personMask + backgroundColor * (1.0 - personMask), 1.0);
    }
  `;
  const { width: outputWidth, height: outputHeight } = canvas;
  const outputRatio = outputWidth / outputHeight;
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const backgroundScaleLocation = gl.getUniformLocation(program, "u_backgroundScale");
  const backgroundOffsetLocation = gl.getUniformLocation(program, "u_backgroundOffset");
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const personMaskLocation = gl.getUniformLocation(program, "u_personMask");
  const backgroundLocation = gl.getUniformLocation(program, "u_background");
  const coverageLocation = gl.getUniformLocation(program, "u_coverage");
  const lightWrappingLocation = gl.getUniformLocation(program, "u_lightWrapping");
  const blendModeLocation = gl.getUniformLocation(program, "u_blendMode");
  gl.useProgram(program);
  gl.uniform2f(backgroundScaleLocation, 1, 1);
  gl.uniform2f(backgroundOffsetLocation, 0, 0);
  gl.uniform1i(inputFrameLocation, 0);
  gl.uniform1i(personMaskLocation, 1);
  gl.uniform2f(coverageLocation, 0, 1);
  gl.uniform1f(lightWrappingLocation, 0);
  gl.uniform1f(blendModeLocation, 0);
  let backgroundTexture = null;
  if (backgroundImage?.complete) {
    updateBackgroundImage(backgroundImage);
  } else if (backgroundImage) {
    backgroundImage.onload = () => {
      updateBackgroundImage(backgroundImage);
    };
  }
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, personMaskTexture);
    if (backgroundTexture !== null) {
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);
      gl.uniform1i(backgroundLocation, 2);
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function updateBackgroundImage(bgImage) {
    backgroundTexture = createTexture(
      gl,
      gl.RGBA8,
      bgImage.naturalWidth,
      bgImage.naturalHeight,
      // @ts-expect-error types are incomplete
      gl.LINEAR,
      gl.LINEAR
    );
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, bgImage.naturalWidth, bgImage.naturalHeight, gl.RGBA, gl.UNSIGNED_BYTE, bgImage);
    let xOffset = 0;
    let yOffset = 0;
    let backgroundWidth = bgImage.naturalWidth;
    let backgroundHeight = bgImage.naturalHeight;
    const backgroundRatio = backgroundWidth / backgroundHeight;
    if (backgroundRatio < outputRatio) {
      backgroundHeight = backgroundWidth / outputRatio;
      yOffset = (bgImage.naturalHeight - backgroundHeight) / 2;
    } else {
      backgroundWidth = backgroundHeight * outputRatio;
      xOffset = (bgImage.naturalWidth - backgroundWidth) / 2;
    }
    const xScale = backgroundWidth / bgImage.naturalWidth;
    const yScale = backgroundHeight / bgImage.naturalHeight;
    xOffset /= bgImage.naturalWidth;
    yOffset /= bgImage.naturalHeight;
    gl.uniform2f(backgroundScaleLocation, xScale, yScale);
    gl.uniform2f(backgroundOffsetLocation, xOffset, yOffset);
  }
  function updateCoverage(coverage) {
    gl.useProgram(program);
    gl.uniform2f(coverageLocation, coverage[0], coverage[1]);
  }
  function updateLightWrapping(lightWrapping) {
    gl.useProgram(program);
    gl.uniform1f(lightWrappingLocation, lightWrapping);
  }
  function updateBlendMode(blendMode) {
    gl.useProgram(program);
    gl.uniform1f(blendModeLocation, blendMode === "screen" ? 0 : 1);
  }
  function cleanUp() {
    gl.deleteTexture(backgroundTexture);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
    gl.deleteShader(vertexShader);
  }
  return {
    render,
    updateCoverage,
    updateLightWrapping,
    updateBlendMode,
    cleanUp
  };
}
function buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, inputTexture, outputTexture, canvas, segmentationConfig) {
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputFrame;
    uniform sampler2D u_segmentationMask;
    uniform vec2 u_texelSize;
    uniform float u_step;
    uniform float u_radius;
    uniform float u_offset;
    uniform float u_sigmaTexel;
    uniform float u_sigmaColor;

    in vec2 v_texCoord;
    out vec4 outColor;

    float gaussian(float x, float sigma) {
      float coeff = -0.5 / (sigma * sigma * 4.0 + 1.0e-6);
      return exp((x * x) * coeff);
    }

    void main() {
      vec2 centerCoord = v_texCoord;
      vec3 centerColor = texture(u_inputFrame, centerCoord).rgb;
      float newVal = 0.0;

      float spaceWeight = 0.0;
      float colorWeight = 0.0;
      float totalWeight = 0.0;

      // Subsample kernel space.
      for (float i = -u_radius + u_offset; i <= u_radius; i += u_step) {
        for (float j = -u_radius + u_offset; j <= u_radius; j += u_step) {
          vec2 shift = vec2(j, i) * u_texelSize;
          vec2 coord = vec2(centerCoord + shift);
          vec3 frameColor = texture(u_inputFrame, coord).rgb;
          float outVal = texture(u_segmentationMask, coord).a;

          spaceWeight = gaussian(distance(centerCoord, coord), u_sigmaTexel);
          colorWeight = gaussian(distance(centerColor, frameColor), u_sigmaColor);
          totalWeight += spaceWeight * colorWeight;

          newVal += spaceWeight * colorWeight * outVal;
        }
      }
      newVal /= totalWeight;

      outColor = vec4(vec3(0.0), newVal);
    }
  `;
  const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;
  const { width: outputWidth, height: outputHeight } = canvas;
  const texelWidth = 1 / outputWidth;
  const texelHeight = 1 / outputHeight;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const segmentationMaskLocation = gl.getUniformLocation(program, "u_segmentationMask");
  const texelSizeLocation = gl.getUniformLocation(program, "u_texelSize");
  const stepLocation = gl.getUniformLocation(program, "u_step");
  const radiusLocation = gl.getUniformLocation(program, "u_radius");
  const offsetLocation = gl.getUniformLocation(program, "u_offset");
  const sigmaTexelLocation = gl.getUniformLocation(program, "u_sigmaTexel");
  const sigmaColorLocation = gl.getUniformLocation(program, "u_sigmaColor");
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
  gl.useProgram(program);
  gl.uniform1i(inputFrameLocation, 0);
  gl.uniform1i(segmentationMaskLocation, 1);
  gl.uniform2f(texelSizeLocation, texelWidth, texelHeight);
  updateSigmaSpace(0);
  updateSigmaColor(0);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, inputTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function updateSigmaSpace(sigmaSpace) {
    sigmaSpace *= Math.max(outputWidth / segmentationWidth, outputHeight / segmentationHeight);
    const kSparsityFactor = 0.66;
    const step = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor);
    const radius = sigmaSpace;
    const offset2 = step > 1 ? step * 0.5 : 0;
    const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace;
    gl.useProgram(program);
    gl.uniform1f(stepLocation, step);
    gl.uniform1f(radiusLocation, radius);
    gl.uniform1f(offsetLocation, offset2);
    gl.uniform1f(sigmaTexelLocation, sigmaTexel);
  }
  function updateSigmaColor(sigmaColor) {
    gl.useProgram(program);
    gl.uniform1f(sigmaColorLocation, sigmaColor);
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return { render, updateSigmaSpace, updateSigmaColor, cleanUp };
}
function buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig, onError) {
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;
    uniform sampler2D u_inputFrame;
    in vec2 v_texCoord;
    out vec4 outColor;

    void main() {
      outColor = texture(u_inputFrame, v_texCoord);
    }
  `;
  const tfliteInputMemoryOffset = tflite._getInputMemoryOffset() / 4;
  const { width: outputWidth, height: outputHeight } = segmentationConfig;
  const outputPixelCount = outputWidth * outputHeight;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputFrameLocation = gl.getUniformLocation(program, "u_inputFrame");
  const outputTexture = createTexture(gl, gl.RGBA8, outputWidth, outputHeight);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
  const outputPixels = new Uint8Array(outputPixelCount * 4);
  gl.useProgram(program);
  gl.uniform1i(inputFrameLocation, 0);
  function render() {
    gl.viewport(0, 0, outputWidth, outputHeight);
    gl.useProgram(program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    readPixelsAsync(gl, 0, 0, outputWidth, outputHeight, gl.RGBA, gl.UNSIGNED_BYTE, outputPixels).catch((error) => {
    });
    for (let i2 = 0; i2 < outputPixelCount; i2++) {
      const tfliteIndex = tfliteInputMemoryOffset + i2 * 3;
      const outputIndex = i2 * 4;
      tflite.HEAPF32[tfliteIndex] = outputPixels[outputIndex] / 255;
      tflite.HEAPF32[tfliteIndex + 1] = outputPixels[outputIndex + 1] / 255;
      tflite.HEAPF32[tfliteIndex + 2] = outputPixels[outputIndex + 2] / 255;
    }
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer);
    gl.deleteTexture(outputTexture);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return { render, cleanUp };
}
function buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, outputTexture, segmentationConfig) {
  const fragmentShaderSource = glsl`#version 300 es

    precision highp float;

    uniform sampler2D u_inputSegmentation;
    in vec2 v_texCoord;
    out vec4 outColor;

    void main() {
      vec2 segmentation = texture(u_inputSegmentation, v_texCoord).rg;
      float shift = max(segmentation.r, segmentation.g);
      float backgroundExp = exp(segmentation.r - shift);
      float personExp = exp(segmentation.g - shift);
      outColor = vec4(vec3(0.0), personExp / (backgroundExp + personExp));
    }
  `;
  const tfliteOutputMemoryOffset = tflite._getOutputMemoryOffset() / 4;
  const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;
  const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createPipelineStageProgram(gl, vertexShader, fragmentShader, positionBuffer, texCoordBuffer);
  const inputLocation = gl.getUniformLocation(program, "u_inputSegmentation");
  const inputTexture = createTexture(gl, gl.RG32F, segmentationWidth, segmentationHeight);
  const frameBuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
  gl.useProgram(program);
  gl.uniform1i(inputLocation, 1);
  function render() {
    gl.viewport(0, 0, segmentationWidth, segmentationHeight);
    gl.useProgram(program);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, inputTexture);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, segmentationWidth, segmentationHeight, gl.RG, gl.FLOAT, tflite.HEAPF32, tfliteOutputMemoryOffset);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }
  function cleanUp() {
    gl.deleteFramebuffer(frameBuffer);
    gl.deleteTexture(inputTexture);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
  }
  return { render, cleanUp };
}
function buildWebGL2Pipeline(videoSource, backgroundImage, blurLevel, backgroundFilter, canvas, tflite, segmentationConfig, onError) {
  const gl = canvas.getContext("webgl2");
  if (!gl)
    throw new Error("WebGL2 is not supported");
  if (gl.isContextLost())
    throw new Error("WebGL2 context was lost");
  const { width: frameWidth, height: frameHeight } = videoSource;
  const { width: segmentationWidth, height: segmentationHeight } = segmentationConfig;
  const vertexShaderSource = glsl`#version 300 es

    in vec2 a_position;
    in vec2 a_texCoord;
    out vec2 v_texCoord;

    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
      v_texCoord = a_texCoord;
    }
  `;
  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const vertexArray = gl.createVertexArray();
  gl.bindVertexArray(vertexArray);
  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
  const texCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), gl.STATIC_DRAW);
  const inputFrameTexture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  const segmentationTexture = createTexture(gl, gl.RGBA8, segmentationWidth, segmentationHeight);
  const personMaskTexture = createTexture(gl, gl.RGBA8, frameWidth, frameHeight);
  const resizingStage = buildResizingStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationConfig);
  const loadSegmentationStage = buildSoftmaxStage(gl, vertexShader, positionBuffer, texCoordBuffer, tflite, segmentationTexture, segmentationConfig);
  const jointBilateralFilterStage = buildJointBilateralFilterStage(gl, vertexShader, positionBuffer, texCoordBuffer, segmentationTexture, personMaskTexture, canvas, segmentationConfig);
  const backgroundStage = backgroundFilter === "blur" ? buildBackgroundBlurStage(gl, vertexShader, positionBuffer, texCoordBuffer, personMaskTexture, canvas, blurLevel || "high") : buildBackgroundImageStage(gl, positionBuffer, texCoordBuffer, personMaskTexture, backgroundImage, canvas);
  function render() {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoSource);
    gl.bindVertexArray(vertexArray);
    resizingStage.render();
    tflite._runInference();
    loadSegmentationStage.render();
    jointBilateralFilterStage.render();
    backgroundStage.render();
  }
  function updatePostProcessingConfig() {
    jointBilateralFilterStage.updateSigmaSpace(1);
    jointBilateralFilterStage.updateSigmaColor(0.1);
    if (backgroundFilter === "image") {
      const backgroundImageStage = backgroundStage;
      backgroundImageStage.updateCoverage([0.5, 0.75]);
      backgroundImageStage.updateLightWrapping(0.3);
      backgroundImageStage.updateBlendMode("screen");
    } else if (backgroundFilter === "blur") {
      const backgroundBlurStage = backgroundStage;
      backgroundBlurStage.updateCoverage([0.5, 0.75]);
    } else {
      const backgroundImageStage = backgroundStage;
      backgroundImageStage.updateCoverage([0, 0.9999]);
      backgroundImageStage.updateLightWrapping(0);
    }
  }
  function cleanUp() {
    backgroundStage.cleanUp();
    jointBilateralFilterStage.cleanUp();
    loadSegmentationStage.cleanUp();
    resizingStage.cleanUp();
    gl.deleteTexture(personMaskTexture);
    gl.deleteTexture(segmentationTexture);
    gl.deleteTexture(inputFrameTexture);
    gl.deleteBuffer(texCoordBuffer);
    gl.deleteBuffer(positionBuffer);
    gl.deleteVertexArray(vertexArray);
    gl.deleteShader(vertexShader);
  }
  return { render, updatePostProcessingConfig, cleanUp };
}
var SegmentationLevel;
(function(SegmentationLevel2) {
  SegmentationLevel2["LOW"] = "low";
  SegmentationLevel2["HIGH"] = "high";
})(SegmentationLevel || (SegmentationLevel = {}));
var getSegmentationParams = (level) => {
  if (level === SegmentationLevel.HIGH) {
    return { width: 256, height: 144 };
  }
  return { width: 160, height: 96 };
};
function createRenderer(tflite, videoSource, targetCanvas, options, onError) {
  const { backgroundFilter, backgroundImage, backgroundBlurLevel, segmentationLevel = SegmentationLevel.HIGH, fps = 30 } = options;
  if (backgroundFilter === "image" && !backgroundImage) {
    throw new Error(`backgroundImage element is required when backgroundFilter is image`);
  }
  const pipeline = buildWebGL2Pipeline(videoSource, backgroundImage, backgroundBlurLevel, backgroundFilter, targetCanvas, tflite, getSegmentationParams(segmentationLevel));
  const timers = new WorkerTimer({ useWorker: true });
  const id = timers.setInterval(() => {
    try {
      pipeline.render();
      if (backgroundFilter === "image") {
        pipeline.updatePostProcessingConfig();
      }
    } catch (error) {
      onError?.(error);
    }
  }, Math.floor(1e3 / (fps <= 0 ? 30 : fps)));
  return {
    dispose: () => {
      pipeline.cleanUp();
      timers.clearInterval(id);
      timers.destroy();
    }
  };
}
var createTFLiteSIMDModule = (__Module) => {
  __Module = __Module || {};
  var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
  var Module = typeof __Module != "undefined" ? __Module : {};
  var readyPromiseResolve, readyPromiseReject;
  Module["ready"] = new Promise(function(resolve, reject) {
    readyPromiseResolve = resolve;
    readyPromiseReject = reject;
  });
  var moduleOverrides = Object.assign({}, Module);
  var thisProgram = "./this.program";
  var quit_ = (status, toThrow) => {
    throw toThrow;
  };
  var ENVIRONMENT_IS_WEB = true;
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var readBinary;
  {
    if (typeof document != "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (_scriptDir) {
      scriptDirectory = _scriptDir;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(
        0,
        scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1
      );
    } else {
      scriptDirectory = "";
    }
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  Object.assign(Module, moduleOverrides);
  moduleOverrides = null;
  if (Module["arguments"]) Module["arguments"];
  if (Module["thisProgram"]) thisProgram = Module["thisProgram"];
  if (Module["quit"]) quit_ = Module["quit"];
  var wasmBinary;
  if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];
  Module["noExitRuntime"] || true;
  if (typeof WebAssembly != "object") {
    abort("no native wasm support detected");
  }
  var wasmMemory;
  var ABORT = false;
  var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
    if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
      return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
    }
    var str = "";
    while (idx < endPtr) {
      var u0 = heapOrArray[idx++];
      if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
      }
      var u1 = heapOrArray[idx++] & 63;
      if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
      }
      var u2 = heapOrArray[idx++] & 63;
      if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
      } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
      }
      if (u0 < 65536) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
      }
    }
    return str;
  }
  var buffer2, HEAP8, HEAPU8, HEAPU32;
  function updateGlobalBufferAndViews(buf) {
    buffer2 = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = new Int16Array(buf);
    Module["HEAP32"] = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = new Float32Array(buf);
    Module["HEAPF64"] = new Float64Array(buf);
  }
  Module["INITIAL_MEMORY"] || 16777216;
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATPOSTRUN__ = [];
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function")
        Module["preRun"] = [Module["preRun"]];
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function")
        Module["postRun"] = [Module["postRun"]];
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnInit(cb) {
    __ATINIT__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var runDependencies = 0;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  function abort(what) {
    {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }
    }
    what = "Aborted(" + what + ")";
    err(what);
    ABORT = true;
    what += ". Build with -sASSERTIONS for more info.";
    var e2 = new WebAssembly.RuntimeError(what);
    readyPromiseReject(e2);
    throw e2;
  }
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return filename.startsWith(dataURIPrefix);
  }
  var wasmBinaryFile;
  wasmBinaryFile = "tflite-simd.wasm";
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }
  function getBinary(file) {
    try {
      if (file == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      if (readBinary) ;
      throw "both async and sync fetching of the wasm failed";
    } catch (err2) {
      abort(err2);
    }
  }
  function getBinaryPromise() {
    if (!wasmBinary && ENVIRONMENT_IS_WEB) {
      if (typeof fetch == "function") {
        return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
          if (!response["ok"]) {
            throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
          }
          return response["arrayBuffer"]();
        }).catch(function() {
          return getBinary(wasmBinaryFile);
        });
      }
    }
    return Promise.resolve().then(function() {
      return getBinary(wasmBinaryFile);
    });
  }
  function createWasm() {
    var info = {
      env: asmLibraryArg,
      wasi_snapshot_preview1: asmLibraryArg
    };
    function receiveInstance(instance2, module) {
      var exports2 = instance2.exports;
      Module["asm"] = exports2;
      wasmMemory = Module["asm"]["memory"];
      updateGlobalBufferAndViews(wasmMemory.buffer);
      Module["asm"]["__indirect_function_table"];
      addOnInit(Module["asm"]["__wasm_call_ctors"]);
      removeRunDependency();
    }
    addRunDependency();
    function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
    }
    function instantiateArrayBuffer(receiver) {
      return getBinaryPromise().then(function(binary) {
        return WebAssembly.instantiate(binary, info);
      }).then(function(instance2) {
        return instance2;
      }).then(receiver, function(reason) {
        err("failed to asynchronously prepare wasm: " + reason);
        abort(reason);
      });
    }
    function instantiateAsync() {
      if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
        return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(
          function(response) {
            var result = WebAssembly.instantiateStreaming(response, info);
            return result.then(receiveInstantiationResult, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(receiveInstantiationResult);
            });
          }
        );
      } else {
        return instantiateArrayBuffer(receiveInstantiationResult);
      }
    }
    if (Module["instantiateWasm"]) {
      try {
        var exports = Module["instantiateWasm"](info, receiveInstance);
        return exports;
      } catch (e2) {
        err("Module.instantiateWasm callback failed with error: " + e2);
        readyPromiseReject(e2);
      }
    }
    instantiateAsync().catch(readyPromiseReject);
    return {};
  }
  function ExitStatus(status) {
    this.name = "ExitStatus";
    this.message = "Program terminated with exit(" + status + ")";
    this.status = status;
  }
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      callbacks.shift()(Module);
    }
  }
  function __dlinit(main_dso_handle) {
  }
  var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking";
  function __dlopen_js(filename, flag) {
    abort(dlopenMissingError);
  }
  function __dlsym_js(handle, symbol) {
    abort(dlopenMissingError);
  }
  var nowIsMonotonic = true;
  function __emscripten_get_now_is_monotonic() {
    return nowIsMonotonic;
  }
  function __mmap_js(len, prot, flags, fd, off, allocated) {
    return -52;
  }
  function __munmap_js(addr, len, prot, flags, fd, offset2) {
  }
  function _abort() {
    abort("");
  }
  function _emscripten_date_now() {
    return Date.now();
  }
  function getHeapMax() {
    return 2147483648;
  }
  function _emscripten_get_heap_max() {
    return getHeapMax();
  }
  var _emscripten_get_now;
  _emscripten_get_now = () => performance.now();
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.copyWithin(dest, src, src + num);
  }
  function emscripten_realloc_buffer(size2) {
    try {
      wasmMemory.grow(size2 - buffer2.byteLength + 65535 >>> 16);
      updateGlobalBufferAndViews(wasmMemory.buffer);
      return 1;
    } catch (e2) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    var oldSize = HEAPU8.length;
    requestedSize = requestedSize >>> 0;
    var maxHeapSize = getHeapMax();
    if (requestedSize > maxHeapSize) {
      return false;
    }
    let alignUp = (x2, multiple) => x2 + (multiple - x2 % multiple) % multiple;
    for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
      var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
      overGrownHeapSize = Math.min(
        overGrownHeapSize,
        requestedSize + 100663296
      );
      var newSize = Math.min(
        maxHeapSize,
        alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)
      );
      var replacement = emscripten_realloc_buffer(newSize);
      if (replacement) {
        return true;
      }
    }
    return false;
  }
  var ENV = {};
  function getExecutableName() {
    return thisProgram || "./this.program";
  }
  function getEnvStrings() {
    if (!getEnvStrings.strings) {
      var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
        USER: "web_user",
        LOGNAME: "web_user",
        PATH: "/",
        PWD: "/",
        HOME: "/home/web_user",
        LANG: lang,
        _: getExecutableName()
      };
      for (var x2 in ENV) {
        if (ENV[x2] === void 0) delete env[x2];
        else env[x2] = ENV[x2];
      }
      var strings = [];
      for (var x2 in env) {
        strings.push(x2 + "=" + env[x2]);
      }
      getEnvStrings.strings = strings;
    }
    return getEnvStrings.strings;
  }
  function writeAsciiToMemory(str, buffer3, dontAddNull) {
    for (var i2 = 0; i2 < str.length; ++i2) {
      HEAP8[buffer3++ >> 0] = str.charCodeAt(i2);
    }
    HEAP8[buffer3 >> 0] = 0;
  }
  function _environ_get(__environ, environ_buf) {
    var bufSize = 0;
    getEnvStrings().forEach(function(string, i2) {
      var ptr = environ_buf + bufSize;
      HEAPU32[__environ + i2 * 4 >> 2] = ptr;
      writeAsciiToMemory(string, ptr);
      bufSize += string.length + 1;
    });
    return 0;
  }
  function _environ_sizes_get(penviron_count, penviron_buf_size) {
    var strings = getEnvStrings();
    HEAPU32[penviron_count >> 2] = strings.length;
    var bufSize = 0;
    strings.forEach(function(string) {
      bufSize += string.length + 1;
    });
    HEAPU32[penviron_buf_size >> 2] = bufSize;
    return 0;
  }
  function _proc_exit(code) {
    quit_(code, new ExitStatus(code));
  }
  function exitJS(status, implicit) {
    _proc_exit(status);
  }
  var _exit = exitJS;
  function _fd_close(fd) {
    return 52;
  }
  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
    return 70;
  }
  var printCharBuffers = [null, [], []];
  function printChar(stream, curr) {
    var buffer3 = printCharBuffers[stream];
    if (curr === 0 || curr === 10) {
      (stream === 1 ? out : err)(UTF8ArrayToString(buffer3, 0));
      buffer3.length = 0;
    } else {
      buffer3.push(curr);
    }
  }
  function _fd_write(fd, iov, iovcnt, pnum) {
    var num = 0;
    for (var i2 = 0; i2 < iovcnt; i2++) {
      var ptr = HEAPU32[iov >> 2];
      var len = HEAPU32[iov + 4 >> 2];
      iov += 8;
      for (var j2 = 0; j2 < len; j2++) {
        printChar(fd, HEAPU8[ptr + j2]);
      }
      num += len;
    }
    HEAPU32[pnum >> 2] = num;
    return 0;
  }
  function getRandomDevice() {
    if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
      var randomBuffer = new Uint8Array(1);
      return () => {
        crypto.getRandomValues(randomBuffer);
        return randomBuffer[0];
      };
    } else return () => abort("randomDevice");
  }
  function _getentropy(buffer3, size2) {
    if (!_getentropy.randomDevice) {
      _getentropy.randomDevice = getRandomDevice();
    }
    for (var i2 = 0; i2 < size2; i2++) {
      HEAP8[buffer3 + i2 >> 0] = _getentropy.randomDevice();
    }
    return 0;
  }
  var asmLibraryArg = {
    _dlinit: __dlinit,
    _dlopen_js: __dlopen_js,
    _dlsym_js: __dlsym_js,
    _emscripten_get_now_is_monotonic: __emscripten_get_now_is_monotonic,
    _mmap_js: __mmap_js,
    _munmap_js: __munmap_js,
    abort: _abort,
    emscripten_date_now: _emscripten_date_now,
    emscripten_get_heap_max: _emscripten_get_heap_max,
    emscripten_get_now: _emscripten_get_now,
    emscripten_memcpy_big: _emscripten_memcpy_big,
    emscripten_resize_heap: _emscripten_resize_heap,
    environ_get: _environ_get,
    environ_sizes_get: _environ_sizes_get,
    exit: _exit,
    fd_close: _fd_close,
    fd_seek: _fd_seek,
    fd_write: _fd_write,
    getentropy: _getentropy
  };
  createWasm();
  Module["___wasm_call_ctors"] = function() {
    return (Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
  };
  Module["_getModelBufferMemoryOffset"] = function() {
    return (Module["_getModelBufferMemoryOffset"] = Module["asm"]["getModelBufferMemoryOffset"]).apply(null, arguments);
  };
  Module["_getInputMemoryOffset"] = function() {
    return (Module["_getInputMemoryOffset"] = Module["asm"]["getInputMemoryOffset"]).apply(null, arguments);
  };
  Module["_getInputHeight"] = function() {
    return (Module["_getInputHeight"] = Module["asm"]["getInputHeight"]).apply(null, arguments);
  };
  Module["_getInputWidth"] = function() {
    return (Module["_getInputWidth"] = Module["asm"]["getInputWidth"]).apply(null, arguments);
  };
  Module["_getInputChannelCount"] = function() {
    return (Module["_getInputChannelCount"] = Module["asm"]["getInputChannelCount"]).apply(null, arguments);
  };
  Module["_getOutputMemoryOffset"] = function() {
    return (Module["_getOutputMemoryOffset"] = Module["asm"]["getOutputMemoryOffset"]).apply(null, arguments);
  };
  Module["_getOutputHeight"] = function() {
    return (Module["_getOutputHeight"] = Module["asm"]["getOutputHeight"]).apply(null, arguments);
  };
  Module["_getOutputWidth"] = function() {
    return (Module["_getOutputWidth"] = Module["asm"]["getOutputWidth"]).apply(null, arguments);
  };
  Module["_getOutputChannelCount"] = function() {
    return (Module["_getOutputChannelCount"] = Module["asm"]["getOutputChannelCount"]).apply(null, arguments);
  };
  Module["_loadModel"] = function() {
    return (Module["_loadModel"] = Module["asm"]["loadModel"]).apply(null, arguments);
  };
  Module["_runInference"] = function() {
    return (Module["_runInference"] = Module["asm"]["runInference"]).apply(null, arguments);
  };
  Module["_malloc"] = function() {
    return (Module["_malloc"] = Module["asm"]["malloc"]).apply(
      null,
      arguments
    );
  };
  Module["___errno_location"] = function() {
    return (Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
  };
  Module["___dl_seterr"] = function() {
    return (Module["___dl_seterr"] = Module["asm"]["__dl_seterr"]).apply(null, arguments);
  };
  Module["stackSave"] = function() {
    return (Module["stackSave"] = Module["asm"]["stackSave"]).apply(
      null,
      arguments
    );
  };
  Module["stackRestore"] = function() {
    return (Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
  };
  Module["stackAlloc"] = function() {
    return (Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
  };
  Module["dynCall_jjj"] = function() {
    return (Module["dynCall_jjj"] = Module["asm"]["dynCall_jjj"]).apply(null, arguments);
  };
  Module["dynCall_jiii"] = function() {
    return (Module["dynCall_jiii"] = Module["asm"]["dynCall_jiii"]).apply(null, arguments);
  };
  Module["dynCall_iiiijj"] = function() {
    return (Module["dynCall_iiiijj"] = Module["asm"]["dynCall_iiiijj"]).apply(null, arguments);
  };
  Module["dynCall_viijj"] = function() {
    return (Module["dynCall_viijj"] = Module["asm"]["dynCall_viijj"]).apply(null, arguments);
  };
  Module["dynCall_viiijjj"] = function() {
    return (Module["dynCall_viiijjj"] = Module["asm"]["dynCall_viiijjj"]).apply(null, arguments);
  };
  Module["dynCall_iijjiiii"] = function() {
    return (Module["dynCall_iijjiiii"] = Module["asm"]["dynCall_iijjiiii"]).apply(null, arguments);
  };
  Module["dynCall_jiji"] = function() {
    return (Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
  };
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun) run();
    if (!calledRun) dependenciesFulfilled = runCaller;
  };
  function run(args) {
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun) return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT) return;
      initRuntime();
      readyPromiseResolve(Module);
      if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function")
      Module["preInit"] = [Module["preInit"]];
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  return __Module.ready;
};
var version2 = "0.5.1";
var packageName = "@stream-io/video-filters-web";
var createTFLite = createTFLiteSIMDModule;
var loadTFLite = async (options = {}) => {
  const { basePath = `https://unpkg.com/${packageName}@${version2}/tf`, tfFilePath = `${basePath}/tflite/tflite-simd.wasm`, modelFilePath = `${basePath}/models/segm_full_v679.tflite` } = options;
  const [tfLite, model] = await Promise.all([
    createTFLite({ locateFile: () => tfFilePath }),
    fetchModel(modelFilePath)
  ]);
  const modelBufferOffset = tfLite._getModelBufferMemoryOffset();
  tfLite.HEAPU8.set(new Uint8Array(model), modelBufferOffset);
  tfLite._loadModel(model.byteLength);
  return tfLite;
};
var lastModelFilePath$1 = "";
var modelFileCache$1;
var fetchModel = async (modelFilePath) => {
  const model = modelFilePath === lastModelFilePath$1 && modelFileCache$1 ? modelFileCache$1 : await fetch(modelFilePath).then((r2) => r2.arrayBuffer());
  modelFileCache$1 = model;
  lastModelFilePath$1 = modelFilePath;
  return model;
};
var lastModelFilePath = "";
var modelFileCache;
var loadMediaPipe = async (options = {}) => {
  const { basePath = `https://unpkg.com/${packageName}@${version2}/mediapipe`, modelPath = `${basePath}/models/selfie_segmenter.tflite` } = options;
  const model = modelPath === lastModelFilePath && modelFileCache ? modelFileCache : await fetch(modelPath).then((r2) => r2.arrayBuffer());
  modelFileCache = model;
  lastModelFilePath = modelPath;
  return model;
};
var BACKGROUND_BLUR_MAP = {
  low: {
    bgBlur: 15,
    bgBlurRadius: 5
  },
  medium: {
    bgBlur: 20,
    bgBlurRadius: 7
  },
  high: {
    bgBlur: 25,
    bgBlurRadius: 10
  }
};
var WebGLRenderer = class _WebGLRenderer {
  constructor(canvas) {
    this.running = false;
    this.currentStateIndex = 0;
    this.backgroundRenderInfo = null;
    this.activeBackgroundSourceIdentifier = null;
    this.canvas = canvas;
    const gl = this.canvas.getContext("webgl2", {
      alpha: false,
      antialias: false,
      desynchronized: true
    });
    if (!gl)
      throw new Error("WebGL2 not supported");
    this.gl = gl;
    const stateUpdateVertexShaderSource = `attribute vec2 a_position; attribute vec2 a_texCoord; varying vec2 v_texCoord; void main() { gl_Position = vec4(a_position, 0.0, 1.0); v_texCoord = a_texCoord; }`;
    const stateUpdateFragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;
      uniform sampler2D u_categoryTexture;
      uniform sampler2D u_confidenceTexture;
      uniform sampler2D u_prevStateTexture;
      uniform float u_smoothingFactor;
      uniform float u_smoothstepMin;
      uniform float u_smoothstepMax;
      uniform int u_selfieModel;

      void main() {
        vec2 prevCoord = vec2(v_texCoord.x, 1.0 - v_texCoord.y);
        float categoryValue = texture2D(u_categoryTexture, v_texCoord).r;
        float confidenceValue = texture2D(u_confidenceTexture, v_texCoord).r;

        if (u_selfieModel == 1) {
            categoryValue = 1.0 - categoryValue;
            confidenceValue = 1.0 - confidenceValue;
        }

        if (categoryValue > 0.0) {
            categoryValue = 1.0;
            confidenceValue = 1.0 - confidenceValue;
        }

        float nonLinearConfidence = smoothstep(u_smoothstepMin, u_smoothstepMax, confidenceValue);
        float prevCategoryValue = texture2D(u_prevStateTexture, prevCoord).r;
        float alpha = u_smoothingFactor * nonLinearConfidence;
        float newCategoryValue = alpha * categoryValue + (1.0 - alpha) * prevCategoryValue;

        gl_FragColor = vec4(newCategoryValue, 0.0, 0.0, 0.0);
      }
    `;
    this.stateUpdateProgram = this.createAndLinkProgram(stateUpdateVertexShaderSource, stateUpdateFragmentShaderSource);
    this.stateUpdateLocations = {
      position: gl.getAttribLocation(this.stateUpdateProgram, "a_position"),
      texCoord: gl.getAttribLocation(this.stateUpdateProgram, "a_texCoord"),
      categoryTexture: gl.getUniformLocation(this.stateUpdateProgram, "u_categoryTexture"),
      confidenceTexture: gl.getUniformLocation(this.stateUpdateProgram, "u_confidenceTexture"),
      prevStateTexture: gl.getUniformLocation(this.stateUpdateProgram, "u_prevStateTexture"),
      smoothingFactor: gl.getUniformLocation(this.stateUpdateProgram, "u_smoothingFactor"),
      smoothstepMin: gl.getUniformLocation(this.stateUpdateProgram, "u_smoothstepMin"),
      smoothstepMax: gl.getUniformLocation(this.stateUpdateProgram, "u_smoothstepMax"),
      selfieModel: gl.getUniformLocation(this.stateUpdateProgram, "u_selfieModel")
    };
    const maskRefineVertexShaderSource = stateUpdateVertexShaderSource;
    const maskRefineFragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform sampler2D u_maskTexture;
      uniform sampler2D u_frameTexture;
      uniform vec2 u_texelSize;
      uniform float u_sigmaSpatial;
      uniform float u_sigmaRange;

      void main() {
        vec2 flippedCoord = v_texCoord;
        vec3 centerPixelColor = texture2D(u_frameTexture, v_texCoord).rgb;
        float totalWeight = 0.0;
        float weightedMaskSum = 0.0;

        for (int offsetX = -2; offsetX <= 2; offsetX++) {
          for (int offsetY = -2; offsetY <= 2; offsetY++) {
            vec2 shift = vec2(float(offsetX), float(offsetY)) * u_texelSize;
            vec2 frameCoord = v_texCoord + shift;
            vec2 maskCoord = flippedCoord + shift;

            vec3 neighborPixelColor = texture2D(u_frameTexture, frameCoord).rgb;
            float neighborMaskValue = texture2D(u_maskTexture, maskCoord).r;

            float spatialWeight = exp(-dot(shift, shift) / (2.0 * u_sigmaSpatial * u_sigmaSpatial));
            vec3 colorDifference = neighborPixelColor - centerPixelColor;
            float rangeWeight = exp(-(dot(colorDifference, colorDifference)) / (2.0 * u_sigmaRange * u_sigmaRange));

            float combinedWeight = spatialWeight * rangeWeight;
            weightedMaskSum += neighborMaskValue * combinedWeight;
            totalWeight += combinedWeight;
          }
        }

        float refinedMaskValue = weightedMaskSum / max(totalWeight, 1e-6);
        gl_FragColor = vec4(refinedMaskValue, refinedMaskValue, refinedMaskValue, 1.0);
      }
    `;
    this.maskRefineProgram = this.createAndLinkProgram(maskRefineVertexShaderSource, maskRefineFragmentShaderSource);
    this.maskRefineLocations = {
      position: gl.getAttribLocation(this.maskRefineProgram, "a_position"),
      texCoord: gl.getAttribLocation(this.maskRefineProgram, "a_texCoord"),
      maskTexture: gl.getUniformLocation(this.maskRefineProgram, "u_maskTexture"),
      frameTexture: gl.getUniformLocation(this.maskRefineProgram, "u_frameTexture"),
      texelSize: gl.getUniformLocation(this.maskRefineProgram, "u_texelSize"),
      sigmaSpatial: gl.getUniformLocation(this.maskRefineProgram, "u_sigmaSpatial"),
      sigmaRange: gl.getUniformLocation(this.maskRefineProgram, "u_sigmaRange")
    };
    const blurVertexShaderSource = stateUpdateVertexShaderSource;
    const blurFragmentShaderSource = `
      precision highp float;
      varying vec2 v_texCoord;

      uniform sampler2D u_image;
      uniform sampler2D u_personMask;
      uniform vec2 u_texelSize;
      uniform float u_sigma;
      uniform float u_radiusScale;
      uniform vec2 u_direction;

      const int KERNEL_RADIUS = 10;

      float gauss(float x, float s) {
        return exp(-(x * x) / (2.0 * s * s));
      }

      void main() {
        vec2 maskCoord = u_direction.y > 0.5 ? vec2(v_texCoord.x, 1.0 - v_texCoord.y) : v_texCoord;
        float mCenter = texture2D(u_personMask, maskCoord).r;
        float wCenter = gauss(0.0, u_sigma);
        vec4 accum = texture2D(u_image, v_texCoord) * wCenter * (1.0 - mCenter);
        float weightSum = wCenter * (1.0 - mCenter);

        for (int i = 1; i <= KERNEL_RADIUS; i++) {
          float f = float(i);
          float offset = f * u_radiusScale;
          float w = gauss(offset, u_sigma);
          vec2 texOffset = u_direction * offset * u_texelSize;

          vec2 uvPlus = v_texCoord + texOffset;
          vec2 maskCoordPlus = u_direction.y > 0.5 ? vec2(uvPlus.x, 1.0 - uvPlus.y) : uvPlus;
          float mPlus = texture2D(u_personMask, maskCoordPlus).r;
          accum += texture2D(u_image, uvPlus) * w * (1.0 - mPlus);
          weightSum += w * (1.0 - mPlus);

          vec2 uvMinus = v_texCoord - texOffset;
          vec2 maskCoordMinus = u_direction.y > 0.5 ? vec2(uvMinus.x, 1.0 - uvMinus.y) : uvMinus;
          float mMinus = texture2D(u_personMask, maskCoordMinus).r;
          accum += texture2D(u_image, uvMinus) * w * (1.0 - mMinus);
          weightSum += w * (1.0 - mMinus);
        }

        vec4 blurred = accum / max(weightSum, 1e-6);
        gl_FragColor = blurred;
      }
    `;
    this.blurProgram = this.createAndLinkProgram(blurVertexShaderSource, blurFragmentShaderSource);
    this.blurLocations = {
      position: gl.getAttribLocation(this.blurProgram, "a_position"),
      texCoord: gl.getAttribLocation(this.blurProgram, "a_texCoord"),
      image: gl.getUniformLocation(this.blurProgram, "u_image"),
      personMask: gl.getUniformLocation(this.blurProgram, "u_personMask"),
      texelSize: gl.getUniformLocation(this.blurProgram, "u_texelSize"),
      sigma: gl.getUniformLocation(this.blurProgram, "u_sigma"),
      radiusScale: gl.getUniformLocation(this.blurProgram, "u_radiusScale"),
      direction: gl.getUniformLocation(this.blurProgram, "u_direction")
    };
    const blendVertexShaderSource = stateUpdateVertexShaderSource;
    const blendFragmentShaderSource = `
      precision mediump float;
      varying vec2 v_texCoord;

      uniform sampler2D u_frameTexture;
      uniform sampler2D u_currentStateTexture;
      uniform sampler2D u_backgroundTexture;
      uniform vec2 u_bgImageDimensions;
      uniform vec2 u_canvasDimensions;
      uniform float u_borderSmooth;
      uniform float u_bgBlur;
      uniform float u_bgBlurRadius;
      uniform int u_enabled;

      vec4 getMixedFragColor(vec2 bgTexCoord, vec2 categoryCoord, vec2 offset) {
          vec4 backgroundColor = texture2D(u_backgroundTexture, bgTexCoord + offset);
          vec4 frameColor = texture2D(u_frameTexture, v_texCoord + offset);
          float categoryValue = texture2D(u_currentStateTexture, categoryCoord + offset).r;
          return mix(backgroundColor, frameColor, categoryValue);
      }

      void main() {
        if (u_enabled == 0) {
          gl_FragColor = texture2D(u_frameTexture, v_texCoord);
          return;
        }

        vec2 categoryCoord = v_texCoord;
        float categoryValue = texture2D(u_currentStateTexture, categoryCoord).r;

        float canvasAspect = u_canvasDimensions.x / u_canvasDimensions.y;
          float bgAspect = u_bgImageDimensions.x / u_bgImageDimensions.y;

          vec2 bgTexCoord = v_texCoord;
          float scaleX = 1.0;
          float scaleY = 1.0;
          float offsetX = 0.0;
          float offsetY = 0.0;

          if (canvasAspect < bgAspect) {
              scaleY = 1.0;
              scaleX = bgAspect / canvasAspect;
              offsetX = (1.0 - scaleX) / 2.0;
          } else {
              scaleX = 1.0;
              scaleY = canvasAspect / bgAspect;
              offsetY = (1.0 - scaleY) / 2.0;
          }

          bgTexCoord = vec2((v_texCoord.x - offsetX) / scaleX, (v_texCoord.y - offsetY) / scaleY);
          gl_FragColor = getMixedFragColor(bgTexCoord, categoryCoord, vec2(0.0, 0.0));
    }`;
    this.blendProgram = this.createAndLinkProgram(blendVertexShaderSource, blendFragmentShaderSource);
    this.blendLocations = {
      position: gl.getAttribLocation(this.blendProgram, "a_position"),
      texCoord: gl.getAttribLocation(this.blendProgram, "a_texCoord"),
      frameTexture: gl.getUniformLocation(this.blendProgram, "u_frameTexture"),
      currentStateTexture: gl.getUniformLocation(this.blendProgram, "u_currentStateTexture"),
      backgroundTexture: gl.getUniformLocation(this.blendProgram, "u_backgroundTexture"),
      bgImageDimensions: gl.getUniformLocation(this.blendProgram, "u_bgImageDimensions"),
      canvasDimensions: gl.getUniformLocation(this.blendProgram, "u_canvasDimensions"),
      borderSmooth: gl.getUniformLocation(this.blendProgram, "u_borderSmooth"),
      bgBlur: gl.getUniformLocation(this.blendProgram, "u_bgBlur"),
      bgBlurRadius: gl.getUniformLocation(this.blendProgram, "u_bgBlurRadius"),
      enabled: gl.getUniformLocation(this.blendProgram, "u_enabled")
    };
    this.positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    this.texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0]), gl.STATIC_DRAW);
    this.storedStateTextures = Array.from({ length: 2 }, () => {
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      return tex;
    });
    gl.bindTexture(gl.TEXTURE_2D, null);
    this.fbo = gl.createFramebuffer();
    this.refineFbo = gl.createFramebuffer();
    const refinedTex = gl.createTexture();
    this.frameTexture = gl.createTexture();
    if (!refinedTex)
      throw new Error("Failed to create refined mask texture");
    gl.bindTexture(gl.TEXTURE_2D, refinedTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.bindTexture(gl.TEXTURE_2D, null);
    this.refinedMaskTexture = refinedTex;
    const mkColorTex = () => {
      const t2 = gl.createTexture();
      if (!t2)
        throw new Error("Failed to create blur texture");
      gl.bindTexture(gl.TEXTURE_2D, t2);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return t2;
    };
    this.blurTexture1 = mkColorTex();
    this.blurTexture2 = mkColorTex();
    const mkFbo = (tex) => {
      const fb = gl.createFramebuffer();
      if (!fb || !tex)
        throw new Error("Failed to create blur FBO");
      gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return fb;
    };
    this.blurFbo1 = mkFbo(this.blurTexture1);
    this.blurFbo2 = mkFbo(this.blurTexture2);
    this.running = true;
  }
  createAndLinkProgram(vsSource, fsSource) {
    const vs2 = this.createShader(this.gl.VERTEX_SHADER, vsSource);
    const fs2 = this.createShader(this.gl.FRAGMENT_SHADER, fsSource);
    const prog = this.gl.createProgram();
    if (!prog)
      throw new Error("Failed to create program");
    this.gl.attachShader(prog, vs2);
    this.gl.attachShader(prog, fs2);
    this.gl.linkProgram(prog);
    if (!this.gl.getProgramParameter(prog, this.gl.LINK_STATUS)) {
      console.error("Program link error:", this.gl.getProgramInfoLog(prog));
      this.gl.deleteProgram(prog);
      throw new Error("Link fail");
    }
    this.gl.detachShader(prog, vs2);
    this.gl.detachShader(prog, fs2);
    this.gl.deleteShader(vs2);
    this.gl.deleteShader(fs2);
    return prog;
  }
  createShader(type, source) {
    const shader = this.gl.createShader(type);
    if (!shader)
      throw new Error(`Failed to create shader type: ${type}`);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);
    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error("Shader compile error:", this.gl.getShaderInfoLog(shader));
      this.gl.deleteShader(shader);
      throw new Error("Failed to compile shader");
    }
    return shader;
  }
  createColorTexture(r2, g2, b2, a2) {
    const texture = this.gl.createTexture();
    if (!texture)
      throw new Error("Failed to create texture for color");
    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    const pixel = new Uint8Array([r2, g2, b2, a2]);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixel);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    return { texture, color: [r2, g2, b2, a2] };
  }
  updateBackgroundIfNeeded(newSource) {
    const gl = this.gl;
    let newIdentifier;
    if (!newSource) {
      const [r2, g2, b2, a2] = _WebGLRenderer.DEFAULT_BG_COLOR;
      newIdentifier = `color(${r2},${g2},${b2},${a2})`;
    } else {
      newIdentifier = newSource.url;
    }
    if (newIdentifier === this.activeBackgroundSourceIdentifier && this.backgroundRenderInfo) {
      return;
    }
    if (this.backgroundRenderInfo) {
      gl.deleteTexture(this.backgroundRenderInfo.texture);
      this.backgroundRenderInfo = null;
    }
    this.activeBackgroundSourceIdentifier = newIdentifier;
    if (!newSource) {
      const [r2, g2, b2, a2] = _WebGLRenderer.DEFAULT_BG_COLOR;
      const colorTexData = this.createColorTexture(r2, g2, b2, a2);
      this.backgroundRenderInfo = {
        type: "color",
        texture: colorTexData.texture,
        color: colorTexData.color
      };
      this.activeBackgroundSourceIdentifier = `color(${r2},${g2},${b2},${a2})`;
    } else {
      if (newSource.type === "image") {
        const { media, url } = newSource;
        const texture = this.gl.createTexture();
        if (!texture) {
          throw new Error("Failed to create texture object for image.");
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, media);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.backgroundRenderInfo = {
          type: "image",
          texture,
          width: media.width,
          height: media.height,
          url
        };
      } else if (newSource.type === "video") {
        const { media, url } = newSource;
        const canvas = new OffscreenCanvas(1, 1);
        const ctx = canvas.getContext("2d");
        const writer = new WritableStream({
          write(videoFrame) {
            canvas.width = videoFrame.codedWidth;
            canvas.height = videoFrame.codedHeight;
            ctx?.drawImage(videoFrame, 0, 0);
            videoFrame.close();
          },
          close() {
            console.log("[virtual-background] video background close");
          }
        });
        media.pipeTo(writer).catch((err) => {
          console.error("media.pipeTo(writer) error", err);
        });
        const texture = this.gl.createTexture();
        if (!texture)
          throw new Error("Failed to create texture for video");
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        this.backgroundRenderInfo = {
          type: "video",
          texture,
          url,
          media,
          canvas
        };
      }
    }
    if (!this.backgroundRenderInfo) {
      console.error("Critical: backgroundRenderInfo is null after processing new source. Setting default color.");
      const [r2, g2, b2, a2] = _WebGLRenderer.DEFAULT_BG_COLOR;
      const colorTexData = this.createColorTexture(r2, g2, b2, a2);
      this.backgroundRenderInfo = {
        type: "color",
        texture: colorTexData.texture,
        color: colorTexData.color
      };
      this.activeBackgroundSourceIdentifier = `color(${r2},${g2},${b2},${a2})`;
    }
  }
  render(videoFrame, options, categoryTexture, confidenceTexture) {
    if (!this.running)
      return;
    const { gl, fbo, frameTexture, storedStateTextures, stateUpdateProgram, stateUpdateLocations, refineFbo, refinedMaskTexture, maskRefineProgram, maskRefineLocations, blendProgram, blendLocations, blurFbo1, blurFbo2, blurTexture1, blurTexture2 } = this;
    const { displayWidth: width, displayHeight: height } = videoFrame;
    if (this.canvas.width !== width || this.canvas.height !== height) {
      this.canvas.width = width;
      this.canvas.height = height;
    }
    if (!categoryTexture || !confidenceTexture) {
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.useProgram(blendProgram);
      const frame = gl.createTexture();
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, frame);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoFrame);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.uniform1i(blendLocations.frameTexture, 0);
      gl.uniform1i(blendLocations.enabled, 0);
      gl.enableVertexAttribArray(blendLocations.position);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
      gl.vertexAttribPointer(blendLocations.position, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(blendLocations.texCoord);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
      gl.vertexAttribPointer(blendLocations.texCoord, 2, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.deleteTexture(frame);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, null);
      return;
    }
    const readStateIndex = this.currentStateIndex;
    const writeStateIndex = (this.currentStateIndex + 1) % 2;
    const prevStateTexture = storedStateTextures[readStateIndex];
    const newStateTexture = storedStateTextures[writeStateIndex];
    this.updateBackgroundIfNeeded(options.backgroundSource);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, newStateTexture, 0);
    gl.bindTexture(gl.TEXTURE_2D, newStateTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.viewport(0, 0, width, height);
    gl.useProgram(stateUpdateProgram);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, categoryTexture);
    gl.uniform1i(stateUpdateLocations.categoryTexture, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, confidenceTexture);
    gl.uniform1i(stateUpdateLocations.confidenceTexture, 1);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, prevStateTexture);
    gl.uniform1i(stateUpdateLocations.prevStateTexture, 2);
    gl.uniform1f(stateUpdateLocations.smoothingFactor, 0.8);
    gl.uniform1f(stateUpdateLocations.smoothstepMin, 0.6);
    gl.uniform1f(stateUpdateLocations.smoothstepMax, 0.9);
    gl.uniform1i(stateUpdateLocations.selfieModel, options.isSelfieMode ? 1 : 0);
    gl.enableVertexAttribArray(stateUpdateLocations.position);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.vertexAttribPointer(stateUpdateLocations.position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(stateUpdateLocations.texCoord);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
    gl.vertexAttribPointer(stateUpdateLocations.texCoord, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindFramebuffer(gl.FRAMEBUFFER, refineFbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, refinedMaskTexture, 0);
    gl.bindTexture(gl.TEXTURE_2D, refinedMaskTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.viewport(0, 0, width, height);
    gl.useProgram(maskRefineProgram);
    gl.enableVertexAttribArray(maskRefineLocations.position);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.vertexAttribPointer(maskRefineLocations.position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(maskRefineLocations.texCoord);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
    gl.vertexAttribPointer(maskRefineLocations.texCoord, 2, gl.FLOAT, false, 0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, newStateTexture);
    gl.uniform1i(maskRefineLocations.maskTexture, 0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, frameTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoFrame);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.uniform1i(maskRefineLocations.frameTexture, 1);
    gl.uniform2f(maskRefineLocations.texelSize, 1 / width, 1 / height);
    gl.uniform1f(maskRefineLocations.sigmaSpatial, 2);
    gl.uniform1f(maskRefineLocations.sigmaRange, 0.1);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.disableVertexAttribArray(maskRefineLocations.position);
    gl.disableVertexAttribArray(maskRefineLocations.texCoord);
    let backgroundTexToUse;
    let bgWToSend = width;
    let bgHToSend = height;
    if (options.bgBlur > 0 && options.bgBlurRadius > 0) {
      const downscale = 0.5;
      const blurW = Math.floor(width * downscale);
      const blurH = Math.floor(height * downscale);
      gl.bindTexture(gl.TEXTURE_2D, blurTexture1);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, blurW, blurH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.bindTexture(gl.TEXTURE_2D, blurTexture2);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, blurW, blurH, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      const KERNEL_RADIUS = 10;
      const radiusScale = Math.max(0, options.bgBlurRadius) / KERNEL_RADIUS;
      gl.useProgram(this.blurProgram);
      gl.enableVertexAttribArray(this.blurLocations.position);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
      gl.vertexAttribPointer(this.blurLocations.position, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(this.blurLocations.texCoord);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
      gl.vertexAttribPointer(this.blurLocations.texCoord, 2, gl.FLOAT, false, 0, 0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, refinedMaskTexture);
      gl.uniform1i(this.blurLocations.personMask, 1);
      gl.uniform1f(this.blurLocations.sigma, options.bgBlur * 0.7);
      gl.uniform1f(this.blurLocations.radiusScale, radiusScale);
      const blurPasses = [
        {
          direction: [1, 0],
          input: frameTexture,
          output: blurFbo1,
          texelSize: [1 / width, 1 / height]
        },
        {
          direction: [0, 1],
          input: blurTexture1,
          output: blurFbo2,
          texelSize: [1 / blurW, 1 / blurH]
        },
        {
          direction: [1, 0],
          input: blurTexture2,
          output: blurFbo1,
          texelSize: [1 / blurW, 1 / blurH]
        },
        {
          direction: [0, 1],
          input: blurTexture1,
          output: blurFbo2,
          texelSize: [1 / blurW, 1 / blurH]
        }
      ];
      for (const pass of blurPasses) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, pass.output);
        gl.viewport(0, 0, blurW, blurH);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, pass.input);
        gl.uniform1i(this.blurLocations.image, 0);
        gl.uniform2f(this.blurLocations.texelSize, pass.texelSize[0], pass.texelSize[1]);
        gl.uniform2f(this.blurLocations.direction, pass.direction[0], pass.direction[1]);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }
      backgroundTexToUse = blurTexture2;
      bgWToSend = blurW;
      bgHToSend = blurH;
    } else if (options.backgroundSource && this.backgroundRenderInfo) {
      backgroundTexToUse = this.backgroundRenderInfo.texture;
      if (this.backgroundRenderInfo.type === "video") {
        const { canvas } = this.backgroundRenderInfo;
        bgWToSend = canvas.width || width;
        bgHToSend = canvas.height || height;
      } else if (this.backgroundRenderInfo.type === "image") {
        bgWToSend = this.backgroundRenderInfo.width;
        bgHToSend = this.backgroundRenderInfo.height;
      } else {
        bgWToSend = width;
        bgHToSend = height;
      }
    } else {
      backgroundTexToUse = this.backgroundRenderInfo?.texture ?? null;
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.useProgram(blendProgram);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, frameTexture);
    gl.uniform1i(blendLocations.frameTexture, 0);
    gl.uniform1f(blendLocations.borderSmooth, 0);
    gl.uniform1f(blendLocations.bgBlur, options.bgBlur);
    gl.uniform1f(blendLocations.bgBlurRadius, options.bgBlurRadius);
    gl.uniform1i(blendLocations.enabled, 1);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, refinedMaskTexture);
    gl.uniform1i(blendLocations.currentStateTexture, 1);
    if (backgroundTexToUse) {
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, backgroundTexToUse);
      gl.uniform1i(blendLocations.backgroundTexture, 2);
      gl.uniform2f(blendLocations.bgImageDimensions, bgWToSend, bgHToSend);
      gl.uniform2f(blendLocations.canvasDimensions, width, height);
    } else {
      gl.uniform2f(blendLocations.bgImageDimensions, width, height);
      gl.uniform2f(blendLocations.canvasDimensions, width, height);
    }
    gl.enableVertexAttribArray(blendLocations.position);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.vertexAttribPointer(blendLocations.position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(blendLocations.texCoord);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
    gl.vertexAttribPointer(blendLocations.texCoord, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    for (let i2 = 0; i2 < 3; ++i2) {
      gl.activeTexture(gl.TEXTURE0 + i2);
      gl.bindTexture(gl.TEXTURE_2D, null);
    }
    this.currentStateIndex = writeStateIndex;
  }
  close() {
    if (!this.running)
      return;
    this.running = false;
    const { gl, fbo, refineFbo, refinedMaskTexture, blurFbo1, blurFbo2 } = this;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (fbo)
      gl.deleteFramebuffer(fbo);
    if (refineFbo)
      gl.deleteFramebuffer(refineFbo);
    if (blurFbo1)
      gl.deleteFramebuffer(blurFbo1);
    if (blurFbo2)
      gl.deleteFramebuffer(blurFbo2);
    gl.deleteProgram(this.stateUpdateProgram);
    gl.deleteProgram(this.maskRefineProgram);
    gl.deleteProgram(this.blurProgram);
    gl.deleteProgram(this.blendProgram);
    if (this.positionBuffer)
      gl.deleteBuffer(this.positionBuffer);
    if (this.texCoordBuffer)
      gl.deleteBuffer(this.texCoordBuffer);
    if (refinedMaskTexture)
      gl.deleteTexture(refinedMaskTexture);
    if (this.blurTexture1)
      gl.deleteTexture(this.blurTexture1);
    if (this.blurTexture2)
      gl.deleteTexture(this.blurTexture2);
    this.storedStateTextures.forEach((t2) => t2 && gl.deleteTexture(t2));
    this.storedStateTextures.splice(0, this.storedStateTextures.length);
    if (this.backgroundRenderInfo?.texture) {
      gl.deleteTexture(this.backgroundRenderInfo.texture);
      this.backgroundRenderInfo = null;
    }
    this.activeBackgroundSourceIdentifier = null;
  }
};
WebGLRenderer.DEFAULT_BG_COLOR = [33, 150, 243, 255];
var FallbackGenerator = class {
  constructor({ kind, signalTarget }) {
    if (kind !== "video") {
      throw new Error("Only video tracks are supported");
    }
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { desynchronized: true });
    if (!ctx) {
      throw new Error("Failed to get 2D context from canvas");
    }
    const mediaStream = canvas.captureStream();
    const track = mediaStream.getVideoTracks()[0];
    const height = signalTarget?.getSettings().height;
    const width = signalTarget?.getSettings().width;
    if (height && width) {
      canvas.height = height;
      canvas.width = width;
    }
    if (!track) {
      throw new Error("Failed to create canvas track");
    }
    if (signalTarget) {
      signalTarget.addEventListener("ended", () => {
        track.stop();
      });
    }
    track.writable = new WritableStream({
      write: (frame) => {
        if (canvas.width !== frame.displayWidth || canvas.height !== frame.displayHeight) {
          canvas.width = frame.displayWidth;
          canvas.height = frame.displayHeight;
        }
        ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
        frame.close();
      },
      abort: () => {
        track.stop();
      },
      close: () => {
        track.stop();
      }
    });
    return track;
  }
};
var TrackGenerator = typeof MediaStreamTrackGenerator !== "undefined" ? MediaStreamTrackGenerator : FallbackGenerator;
var FallbackProcessor = class {
  constructor({ track }) {
    this.close = () => {
      this.video.pause();
      this.video.srcObject = null;
      this.video.src = "";
      this.workerTimer.destroy();
    };
    if (!track)
      throw new Error("MediaStreamTrack is required");
    if (track.kind !== "video") {
      throw new Error("MediaStreamTrack must be video");
    }
    let running = true;
    this.video = document.createElement("video");
    this.video.muted = true;
    this.video.playsInline = true;
    this.video.srcObject = new MediaStream([track]);
    const canvas = new OffscreenCanvas(1, 1);
    const ctx = canvas.getContext("2d");
    if (!ctx)
      throw new Error("Failed to get 2D context from OffscreenCanvas");
    let timestamp2 = 0;
    const frameRate = track.getSettings().frameRate || 30;
    let frameDuration = 1e3 / frameRate;
    let lastVideoTime = -1;
    this.workerTimer = new WorkerTimer({ useWorker: true });
    this.readable = new ReadableStream({
      start: async () => {
        await Promise.all([
          this.video.play(),
          new Promise((r2) => this.video.addEventListener("loadeddata", r2, { once: true }))
        ]);
        frameDuration = 1e3 / (track.getSettings().frameRate || 30);
        timestamp2 = performance.now();
      },
      pull: async (controller) => {
        if (!running) {
          controller.close();
          this.close();
          return;
        }
        const delta = performance.now() - timestamp2;
        if (delta <= frameDuration) {
          await new Promise((r2) => this.workerTimer.setTimeout(r2, frameDuration - delta));
        }
        timestamp2 = performance.now();
        const currentTime = this.video.currentTime;
        const hasNewFrame = currentTime !== lastVideoTime;
        if (!hasNewFrame) {
          await new Promise((r2) => this.workerTimer.setTimeout(r2, frameDuration));
          return;
        }
        lastVideoTime = currentTime;
        if (canvas.width !== this.video.videoWidth || canvas.height !== this.video.videoHeight) {
          canvas.width = this.video.videoWidth;
          canvas.height = this.video.videoHeight;
        }
        ctx.drawImage(this.video, 0, 0);
        try {
          const frame = new VideoFrame(canvas, { timestamp: timestamp2 });
          controller.enqueue(frame);
        } catch (err) {
          running = false;
          controller.error(err);
          this.close();
        }
      },
      cancel: () => {
        running = false;
        this.close();
      }
    });
  }
};
var TrackProcessor = typeof MediaStreamTrackProcessor !== "undefined" ? MediaStreamTrackProcessor : FallbackProcessor;
var VirtualBackground = class {
  constructor(track, options = {}, hooks = {}) {
    this.track = track;
    this.options = options;
    this.hooks = hooks;
    this.segmenter = null;
    this.isSegmenterReady = false;
    this.segmenterDelayTotal = 0;
    this.frames = 0;
    this.lastStatsTime = 0;
    this.processor = new TrackProcessor({ track });
    this.generator = new TrackGenerator({
      kind: "video",
      signalTarget: track
    });
    this.abortController = new AbortController();
  }
  async start() {
    const { onError } = this.hooks;
    const { readable } = this.processor;
    const { writable } = this.generator;
    const displayWidth = this.track.getSettings().width ?? 1280;
    const displayHeight = this.track.getSettings().height ?? 720;
    this.canvas = new OffscreenCanvas(displayWidth, displayHeight);
    this.webGlRenderer = new WebGLRenderer(this.canvas);
    await this.initializeSegmenter();
    const opts = await this.initializeSegmenterOptions();
    const transformStream = new TransformStream({
      transform: async (frame, controller) => {
        try {
          if (this.abortController.signal.aborted) {
            return frame.close();
          }
          const processed = await this.transform(frame, opts);
          controller.enqueue(processed);
        } catch (e2) {
          console.error("[virtual-background] error processing frame:", e2);
          this.hooks.onError?.(e2);
          if (!this.abortController.signal.aborted) {
            controller.enqueue(frame);
          }
        } finally {
          frame.close();
        }
      },
      flush: () => {
        if (this.segmenter) {
          this.segmenter.close();
          this.segmenter = null;
        }
        this.isSegmenterReady = false;
      }
    });
    const signal = this.abortController.signal;
    readable.pipeThrough(transformStream, { signal }).pipeTo(writable, { signal }).catch((e2) => {
      if (e2.name !== "AbortError") {
        console.error("[virtual-background] Error processing track:", e2);
        onError?.(e2);
      }
    });
    return this.generator;
  }
  /**
   * Loads and initializes the MediaPipe `ImageSegmenter`.
   */
  async initializeSegmenter() {
    try {
      const basePath = this.options?.basePath || `https://unpkg.com/${packageName}@${version2}/mediapipe`;
      const defaultModelPath = `${basePath}/models/selfie_segmenter.tflite`;
      const model = this.options?.modelPath || defaultModelPath;
      const wasmPath = `${basePath}/wasm`;
      const fileset = await Uo.forVisionTasks(wasmPath);
      this.segmenter = await Rc.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath: model,
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        outputCategoryMask: true,
        outputConfidenceMasks: true,
        canvas: this.canvas
      });
      this.isSegmenterReady = true;
    } catch (error) {
      console.error("[virtual-background] Failed to initialize MediaPipe segmenter:", error);
      this.isSegmenterReady = false;
    }
  }
  /**
   * Processes a single video frame.
   *
   * Performs segmentation via MediaPipe and then composites the frame
   * through the WebGL renderer to apply background effects.
   *
   * @param frame - The incoming frame from the processor.
   * @param opts - The segmentation options to use.
   *
   * @returns A new `VideoFrame` containing the processed image.
   */
  async transform(frame, opts) {
    if (this.isSegmenterReady && this.segmenter) {
      try {
        const start = performance.now();
        await new Promise((resolve) => {
          this.segmenter.segmentForVideo(frame, frame.timestamp, (result) => {
            const categoryMask = result.categoryMask.getAsWebGLTexture();
            const confidenceMask = result.confidenceMasks[0].getAsWebGLTexture();
            this.webGlRenderer.render(frame, opts, categoryMask, confidenceMask);
            const now = performance.now();
            this.segmenterDelayTotal += now - start;
            this.frames++;
            if (this.lastStatsTime === 0) {
              this.lastStatsTime = now;
            }
            if (now - this.lastStatsTime > 1e3) {
              const delay3 = Math.round(this.segmenterDelayTotal / this.frames * 100) / 100;
              const fps = Math.round(1e3 * this.frames / (now - this.lastStatsTime));
              this.hooks.onStats?.({ delay: delay3, fps, timestamp: now });
              this.lastStatsTime = now;
              this.segmenterDelayTotal = 0;
              this.frames = 0;
            }
            resolve();
          });
        });
      } catch (error) {
        console.error("[virtual-background] Error during segmentation:", error);
      }
    }
    return new VideoFrame(this.canvas, { timestamp: frame.timestamp });
  }
  async loadBackground(url) {
    if (!url) {
      return;
    }
    const response = await fetch(url);
    if (!response.ok) {
      console.error(`[virtual-background] Failed to fetch background source ${url} (status: ${response.status})`);
      return;
    }
    const blob = await response.blob();
    const imageBitmap = await createImageBitmap(blob);
    return { type: "image", media: imageBitmap, url };
  }
  async initializeSegmenterOptions() {
    const isSelfieMode = this.options.modelPath ? this.options.modelPath?.includes("selfie_segmenter") : true;
    if (this.options.backgroundFilter === "image") {
      return {
        backgroundSource: await this.loadBackground(this.options.backgroundImage),
        bgBlur: 0,
        bgBlurRadius: 0,
        isSelfieMode
      };
    }
    const blurLevel = this.options.backgroundBlurLevel;
    if (typeof blurLevel === "string") {
      return {
        ...BACKGROUND_BLUR_MAP[blurLevel],
        backgroundSource: void 0,
        isSelfieMode
      };
    }
    const numeric = blurLevel ?? 5;
    const bgBlur = Math.min(numeric * 3, 30);
    const bgBlurRadius = Math.min(numeric, 10);
    return {
      backgroundSource: void 0,
      bgBlur,
      bgBlurRadius,
      isSelfieMode
    };
  }
  stop() {
    this.abortController.abort();
    this.webGlRenderer.close();
    this.generator.stop();
    if (this.segmenter) {
      this.segmenter.close();
      this.segmenter = null;
    }
    this.isSegmenterReady = false;
  }
};

// node_modules/@stream-io/video-react-sdk/dist/index.es.js
var Audio = ({ participant, trackType = "audioTrack", ...rest }) => {
  const call = useCall();
  const [audioElement, setAudioElement] = (0, import_react2.useState)(null);
  const { userId, sessionId } = participant;
  (0, import_react2.useEffect)(() => {
    if (!call || !audioElement)
      return;
    const cleanup = call.bindAudioElement(audioElement, sessionId, trackType);
    return () => {
      cleanup?.();
    };
  }, [call, sessionId, audioElement, trackType]);
  return (0, import_jsx_runtime2.jsx)("audio", { autoPlay: true, ...rest, ref: setAudioElement, "data-user-id": userId, "data-session-id": sessionId, "data-track-type": trackType });
};
Audio.displayName = "Audio";
var ParticipantsAudio = (props) => {
  const { participants, audioProps } = props;
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: participants.map((participant) => {
    if (participant.isLocalParticipant)
      return null;
    const { audioStream, screenShareAudioStream, sessionId } = participant;
    const hasAudioTrack = hasAudio(participant);
    const audioTrackElement = hasAudioTrack && audioStream && (0, import_jsx_runtime2.jsx)(Audio, { ...audioProps, trackType: "audioTrack", participant });
    const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
    const screenShareAudioTrackElement = hasScreenShareAudioTrack && screenShareAudioStream && (0, import_jsx_runtime2.jsx)(Audio, { ...audioProps, trackType: "screenShareAudioTrack", participant });
    return (0, import_jsx_runtime2.jsxs)(import_react2.Fragment, { children: [audioTrackElement, screenShareAudioTrackElement] }, sessionId);
  }) });
};
ParticipantsAudio.displayName = "ParticipantsAudio";
var ParticipantViewContext = (0, import_react2.createContext)(void 0);
var useParticipantViewContext = () => (0, import_react2.useContext)(ParticipantViewContext);
var useFloatingUIPreset = ({ middleware = [], placement, strategy, offset: offsetInPx = 10 }) => {
  const { refs, x: x2, y: y2, update, elements: { domReference, floating }, context: context2 } = useFloating({
    placement,
    strategy,
    middleware: [
      offset(offsetInPx),
      shift(),
      flip(),
      size({
        padding: 10,
        apply: ({ availableHeight, elements }) => {
          Object.assign(elements.floating.style, {
            maxHeight: `${availableHeight}px`
          });
        }
      }),
      ...middleware
    ]
  });
  (0, import_react2.useEffect)(() => {
    if (!domReference || !floating)
      return;
    const cleanup = autoUpdate(domReference, floating, update);
    return () => cleanup();
  }, [domReference, floating, update]);
  return { refs, x: x2, y: y2, domReference, floating, strategy, context: context2 };
};
var defaultDevice = "default";
var usePersistedDevicePreferences = (key = "@stream-io/device-preferences") => {
  const { useCallSettings: useCallSettings2, useCallCallingState: useCallCallingState2, useMicrophoneState: useMicrophoneState2, useCameraState: useCameraState2, useSpeakerState: useSpeakerState2 } = useCallStateHooks();
  const settings = useCallSettings2();
  const callingState = useCallCallingState2();
  const microphoneState = useMicrophoneState2();
  const cameraState = useCameraState2();
  const speakerState = useSpeakerState2();
  const [applyingState, setApplyingState] = (0, import_react2.useState)("idle");
  const cameraDevices = settings?.video?.enabled ? cameraState.devices : false;
  (0, import_react2.useEffect)(function apply() {
    if (callingState === CallingState.LEFT || microphoneState.devices.length === 0 || Array.isArray(cameraDevices) && cameraDevices.length === 0 || speakerState.devices.length === 0 || !settings || applyingState !== "idle") {
      return;
    }
    setApplyingState("applying");
    (async () => {
      const { audio, video } = settings;
      for (const [deviceKey, state, defaultMuted, enabledInCallType] of [
        ["microphone", microphoneState, !audio.mic_default_on, true],
        ["camera", cameraState, !video.camera_default_on, video.enabled],
        ["speaker", speakerState, false, true]
      ]) {
        const preferences = parseLocalDevicePreferences(key);
        const preference = preferences[deviceKey];
        const manager = state[deviceKey];
        const applyPromise = preference ? applyLocalDevicePreference(manager, [preference].flat(), deviceKey === "camera" ? cameraDevices || [] : state.devices, enabledInCallType) : applyMutedState(manager, defaultMuted, enabledInCallType);
        await applyPromise.catch((err) => {
          console.warn(`Failed to apply ${deviceKey} device preferences`, err);
        });
      }
    })().finally(() => setApplyingState((state) => state === "applying" ? "applied" : state));
  }, [
    applyingState,
    callingState,
    cameraState,
    cameraDevices,
    key,
    microphoneState,
    microphoneState.devices,
    settings,
    speakerState,
    speakerState.devices
  ]);
  (0, import_react2.useEffect)(function persist() {
    if (callingState === CallingState.LEFT || applyingState !== "applied") {
      return;
    }
    for (const [deviceKey, devices, selectedDevice, isMute] of [
      [
        "camera",
        cameraDevices || [],
        cameraState.selectedDevice,
        cameraState.isMute
      ],
      [
        "microphone",
        microphoneState.devices,
        microphoneState.selectedDevice,
        microphoneState.isMute
      ],
      [
        "speaker",
        speakerState.devices,
        speakerState.selectedDevice,
        speakerState.isMute
      ]
    ]) {
      try {
        patchLocalDevicePreference(key, deviceKey, {
          devices,
          selectedDevice,
          isMute
        });
      } catch (err) {
        console.warn(`Failed to save ${deviceKey} device preferences`, err);
      }
    }
  }, [
    applyingState,
    callingState,
    cameraDevices,
    cameraState.isMute,
    cameraState.selectedDevice,
    key,
    microphoneState.devices,
    microphoneState.isMute,
    microphoneState.selectedDevice,
    speakerState.devices,
    speakerState.isMute,
    speakerState.selectedDevice
  ]);
};
var parseLocalDevicePreferences = (key) => {
  const preferencesStr = window.localStorage.getItem(key);
  let preferences = {};
  if (preferencesStr) {
    try {
      preferences = JSON.parse(preferencesStr);
      if (Object.hasOwn(preferences, "mic")) {
        preferences.microphone = preferences.mic;
      }
    } catch {
    }
  }
  return preferences;
};
var patchLocalDevicePreference = (key, deviceKey, state) => {
  const preferences = parseLocalDevicePreferences(key);
  const nextPreference = getSelectedDevicePreference(state.devices, state.selectedDevice);
  const preferenceHistory = [preferences[deviceKey] ?? []].flat().filter((p2) => p2.selectedDeviceId !== nextPreference.selectedDeviceId && (p2.selectedDeviceLabel === "" || p2.selectedDeviceLabel !== nextPreference.selectedDeviceLabel));
  window.localStorage.setItem(key, JSON.stringify({
    ...preferences,
    mic: void 0,
    // for backwards compatibility
    [deviceKey]: [
      {
        ...nextPreference,
        muted: state.isMute
      },
      ...preferenceHistory
    ].slice(0, 3)
  }));
};
var applyLocalDevicePreference = async (manager, preference, devices, enabledInCallType) => {
  let muted;
  for (const p2 of preference) {
    muted ?? (muted = p2.muted);
    if (p2.selectedDeviceId === defaultDevice) {
      break;
    }
    const device = devices.find((d) => d.deviceId === p2.selectedDeviceId) ?? devices.find((d) => d.label === p2.selectedDeviceLabel);
    if (device) {
      if (!manager.state.selectedDevice) {
        await manager.select(device.deviceId);
      }
      muted = p2.muted;
      break;
    }
  }
  if (typeof muted === "boolean") {
    await applyMutedState(manager, muted, enabledInCallType);
  }
};
var applyMutedState = async (manager, muted, enabledInCallType) => {
  if (enabledInCallType && !manager.state.status) {
    await manager[muted ? "disable" : "enable"]?.();
  }
};
var getSelectedDevicePreference = (devices, selectedDevice) => ({
  selectedDeviceId: selectedDevice || defaultDevice,
  selectedDeviceLabel: devices?.find((d) => d.deviceId === selectedDevice)?.label ?? ""
});
var SCROLL_THRESHOLD = 10;
var useVerticalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
  const [scrollPosition, setScrollPosition] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (!scrollElement)
      return;
    const scrollHandler = () => {
      const element = scrollElement;
      const hasVerticalScrollbar = element.scrollHeight > element.clientHeight;
      if (!hasVerticalScrollbar)
        return setScrollPosition(null);
      const isAtTheTop = element.scrollTop <= threshold;
      if (isAtTheTop)
        return setScrollPosition("top");
      const isAtTheBottom = Math.abs(element.scrollHeight - element.scrollTop - element.clientHeight) <= threshold;
      if (isAtTheBottom)
        return setScrollPosition("bottom");
      setScrollPosition("between");
    };
    const resizeObserver = new ResizeObserver(scrollHandler);
    resizeObserver.observe(scrollElement);
    scrollElement.addEventListener("scroll", scrollHandler);
    return () => {
      scrollElement.removeEventListener("scroll", scrollHandler);
      resizeObserver.disconnect();
    };
  }, [scrollElement, threshold]);
  return scrollPosition;
};
var useHorizontalScrollPosition = (scrollElement, threshold = SCROLL_THRESHOLD) => {
  const [scrollPosition, setScrollPosition] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (!scrollElement)
      return;
    const scrollHandler = () => {
      const element = scrollElement;
      const hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
      if (!hasHorizontalScrollbar)
        return setScrollPosition(null);
      const isAtTheStart = element.scrollLeft <= threshold;
      if (isAtTheStart)
        return setScrollPosition("start");
      const isAtTheEnd = Math.abs(element.scrollWidth - element.scrollLeft - element.clientWidth) <= threshold;
      if (isAtTheEnd)
        return setScrollPosition("end");
      setScrollPosition("between");
    };
    const resizeObserver = new ResizeObserver(scrollHandler);
    resizeObserver.observe(scrollElement);
    scrollElement.addEventListener("scroll", scrollHandler);
    return () => {
      scrollElement.removeEventListener("scroll", scrollHandler);
      resizeObserver.disconnect();
    };
  }, [scrollElement, threshold]);
  return scrollPosition;
};
var useRequestPermission = (permission) => {
  const call = useCall();
  const { useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const hasPermission = useHasPermissions2(permission);
  const [isAwaitingPermission, setIsAwaitingPermission] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    const reset = () => setIsAwaitingPermission(false);
    if (hasPermission)
      reset();
  }, [hasPermission]);
  const requestPermission = (0, import_react2.useCallback)(async () => {
    if (hasPermission)
      return true;
    const canRequestPermission = !!call?.permissionsContext.canRequest(permission);
    if (isAwaitingPermission || !canRequestPermission)
      return false;
    setIsAwaitingPermission(true);
    try {
      await call?.requestPermissions({
        permissions: [permission]
      });
    } catch (error) {
      setIsAwaitingPermission(false);
      throw new Error(`requestPermission failed: ${error}`);
    }
    return false;
  }, [call, hasPermission, isAwaitingPermission, permission]);
  return {
    requestPermission,
    hasPermission,
    canRequestPermission: !!call?.permissionsContext.canRequest(permission),
    isAwaitingPermission
  };
};
function useDeviceList(devices, selectedDeviceId) {
  const { t: t2 } = useI18n();
  return (0, import_react2.useMemo)(() => {
    let selectedDeviceInfo = null;
    let selectedIndex = null;
    const deviceList = devices.map((d, i2) => {
      const isSelected = d.deviceId === selectedDeviceId;
      const device = { deviceId: d.deviceId, label: d.label, isSelected };
      if (isSelected) {
        selectedDeviceInfo = device;
        selectedIndex = i2;
      }
      return device;
    });
    if (selectedDeviceInfo === null || selectedIndex === null) {
      const defaultDevice2 = {
        deviceId: "default",
        label: t2("Default"),
        isSelected: true
      };
      selectedDeviceInfo = defaultDevice2;
      selectedIndex = 0;
      deviceList.unshift(defaultDevice2);
    }
    return { deviceList, selectedDeviceInfo, selectedIndex };
  }, [devices, selectedDeviceId, t2]);
}
var MenuVisualType;
(function(MenuVisualType2) {
  MenuVisualType2["PORTAL"] = "portal";
  MenuVisualType2["MENU"] = "menu";
})(MenuVisualType || (MenuVisualType = {}));
var MenuContext = (0, import_react2.createContext)({});
var useMenuContext = () => {
  return (0, import_react2.useContext)(MenuContext);
};
var MenuPortal = ({ children, refs }) => {
  const portalId = (0, import_react2.useMemo)(() => `str-video-portal-${Math.random().toString(36).substring(2, 9)}`, []);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)("div", { id: portalId, className: "str-video__portal" }), (0, import_jsx_runtime2.jsx)(FloatingOverlay, { children: (0, import_jsx_runtime2.jsx)(FloatingPortal, { id: portalId, children: (0, import_jsx_runtime2.jsx)("div", { className: "str-video__portal-content", ref: refs.setFloating, children }) }) })] });
};
var MenuToggle = ({ ToggleButton: ToggleButton5, placement = "top-start", strategy = "absolute", offset: offset2, visualType = MenuVisualType.MENU, children, onToggle }) => {
  const [menuShown, setMenuShown] = (0, import_react2.useState)(false);
  const toggleHandler = (0, import_react2.useRef)(onToggle);
  toggleHandler.current = onToggle;
  const { floating, domReference, refs, x: x2, y: y2 } = useFloatingUIPreset({
    placement,
    strategy,
    offset: offset2
  });
  (0, import_react2.useEffect)(() => {
    const parentDocument = domReference?.ownerDocument;
    const handleClick = (event) => {
      if (!floating && domReference?.contains(event.target)) {
        setMenuShown(true);
        toggleHandler.current?.(true);
      } else if (floating && !floating?.contains(event.target)) {
        setMenuShown(false);
        toggleHandler.current?.(false);
      }
    };
    const handleKeyDown = (event) => {
      if (event.key && // key can be undefined in some browsers
      event.key.toLowerCase() === "escape" && !event.altKey && !event.ctrlKey) {
        setMenuShown(false);
        toggleHandler.current?.(false);
      }
    };
    parentDocument?.addEventListener("click", handleClick, { capture: true });
    parentDocument?.addEventListener("keydown", handleKeyDown);
    return () => {
      parentDocument?.removeEventListener("click", handleClick, {
        capture: true
      });
      parentDocument?.removeEventListener("keydown", handleKeyDown);
    };
  }, [floating, domReference]);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [menuShown && (0, import_jsx_runtime2.jsx)(MenuContext.Provider, { value: { close: () => setMenuShown(false) }, children: visualType === MenuVisualType.PORTAL ? (0, import_jsx_runtime2.jsx)(MenuPortal, { refs, children }) : visualType === MenuVisualType.MENU ? (0, import_jsx_runtime2.jsx)("div", { className: "str-video__menu-container", ref: refs.setFloating, style: {
    position: strategy,
    top: y2 ?? 0,
    left: x2 ?? 0,
    overflowY: "auto"
  }, role: "menu", children }) : null }), (0, import_jsx_runtime2.jsx)(ToggleButton5, { menuShown, ref: refs.setReference })] });
};
var GenericMenu = ({ children, onItemClick }) => {
  const ref = (0, import_react2.useRef)(null);
  return (0, import_jsx_runtime2.jsx)("ul", { className: "str-video__generic-menu", ref, onClick: (e2) => {
    if (onItemClick && e2.target !== ref.current && ref.current?.contains(e2.target)) {
      onItemClick(e2);
    }
  }, children });
};
var GenericMenuButtonItem = ({ children, ...rest }) => {
  return (0, import_jsx_runtime2.jsx)("li", { className: "str-video__generic-menu--item", children: (0, import_jsx_runtime2.jsx)("button", { ...rest, children }) });
};
var Icon = ({ className, icon }) => (0, import_jsx_runtime2.jsx)("span", { className: clsx_default("str-video__icon", icon && `str-video__icon--${icon}`, className) });
function usePictureInPictureState(videoElement) {
  const [isPiP, setIsPiP] = (0, import_react2.useState)(document.pictureInPictureElement === videoElement);
  if (!videoElement && isPiP)
    setIsPiP(false);
  (0, import_react2.useEffect)(() => {
    if (!videoElement)
      return;
    const handlePiP = () => {
      setIsPiP(document.pictureInPictureElement === videoElement);
    };
    videoElement.addEventListener("enterpictureinpicture", handlePiP);
    videoElement.addEventListener("leavepictureinpicture", handlePiP);
    return () => {
      videoElement.removeEventListener("enterpictureinpicture", handlePiP);
      videoElement.removeEventListener("leavepictureinpicture", handlePiP);
    };
  }, [videoElement]);
  return isPiP;
}
var ParticipantActionsContextMenu = () => {
  const { participant, participantViewElement, videoElement } = useParticipantViewContext();
  const [fullscreenModeOn, setFullscreenModeOn] = (0, import_react2.useState)(!!document.fullscreenElement);
  const call = useCall();
  const isPiP = usePictureInPictureState(videoElement ?? void 0);
  const { t: t2 } = useI18n();
  const { pin, sessionId, userId } = participant;
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const hasScreenShareTrack = hasScreenShare(participant);
  const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
  const blockUser = () => call?.blockUser(userId);
  const kickUser = () => call?.kickUser({ user_id: userId });
  const muteAudio = () => call?.muteUser(userId, "audio");
  const muteVideo = () => call?.muteUser(userId, "video");
  const muteScreenShare = () => call?.muteUser(userId, "screenshare");
  const muteScreenShareAudio = () => call?.muteUser(userId, "screenshare_audio");
  const grantPermission = (permission) => () => {
    call?.updateUserPermissions({
      user_id: userId,
      grant_permissions: [permission]
    });
  };
  const revokePermission = (permission) => () => {
    call?.updateUserPermissions({
      user_id: userId,
      revoke_permissions: [permission]
    });
  };
  const toggleParticipantPin = () => {
    if (pin) {
      call?.unpin(sessionId);
    } else {
      call?.pin(sessionId);
    }
  };
  const pinForEveryone = () => {
    call?.pinForEveryone({ user_id: userId, session_id: sessionId }).catch((err) => {
      console.error(`Failed to pin participant ${userId}`, err);
    });
  };
  const unpinForEveryone = () => {
    call?.unpinForEveryone({ user_id: userId, session_id: sessionId }).catch((err) => {
      console.error(`Failed to unpin participant ${userId}`, err);
    });
  };
  const toggleFullscreenMode = () => {
    if (!fullscreenModeOn) {
      return participantViewElement?.requestFullscreen().catch(console.error);
    }
    return document.exitFullscreen().catch(console.error);
  };
  (0, import_react2.useEffect)(() => {
    const handleFullscreenChange = () => {
      setFullscreenModeOn(!!document.fullscreenElement);
    };
    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, []);
  const togglePictureInPicture = () => {
    if (videoElement && !isPiP) {
      return videoElement.requestPictureInPicture().catch(console.error);
    }
    return document.exitPictureInPicture().catch(console.error);
  };
  const { close } = useMenuContext() || {};
  return (0, import_jsx_runtime2.jsxs)(GenericMenu, { onItemClick: close, children: [(0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: toggleParticipantPin, disabled: pin && !pin.isLocalPin, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "pin" }), pin ? t2("Unpin") : t2("Pin")] }), (0, import_jsx_runtime2.jsxs)(Restricted, { requiredGrants: [OwnCapability.PIN_FOR_EVERYONE], children: [(0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: pinForEveryone, disabled: pin && !pin.isLocalPin, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "pin" }), t2("Pin for everyone")] }), (0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: unpinForEveryone, disabled: !pin || pin.isLocalPin, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "pin" }), t2("Unpin for everyone")] })] }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: (0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: blockUser, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "not-allowed" }), t2("Block")] }) }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.KICK_USER], children: (0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: kickUser, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "kick-user" }), t2("Kick")] }) }), (0, import_jsx_runtime2.jsxs)(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], children: [hasVideoTrack && (0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: muteVideo, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "camera-off-outline" }), t2("Turn off video")] }), hasScreenShareTrack && (0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShare, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "screen-share-off" }), t2("Turn off screen share")] }), hasAudioTrack && (0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: muteAudio, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "no-audio" }), t2("Mute audio")] }), hasScreenShareAudioTrack && (0, import_jsx_runtime2.jsxs)(GenericMenuButtonItem, { onClick: muteScreenShareAudio, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "no-audio" }), t2("Mute screen share audio")] })] }), participantViewElement && typeof participantViewElement.requestFullscreen !== "undefined" && (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: toggleFullscreenMode, children: t2("{{ direction }} fullscreen", {
    direction: fullscreenModeOn ? t2("Leave") : t2("Enter")
  }) }), videoElement && document.pictureInPictureEnabled && (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: togglePictureInPicture, children: t2("{{ direction }} picture-in-picture", {
    direction: isPiP ? t2("Leave") : t2("Enter")
  }) }), (0, import_jsx_runtime2.jsxs)(Restricted, { requiredGrants: [OwnCapability.UPDATE_CALL_PERMISSIONS], children: [(0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_AUDIO), children: t2("Allow audio") }), (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SEND_VIDEO), children: t2("Allow video") }), (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: grantPermission(OwnCapability.SCREENSHARE), children: t2("Allow screen sharing") }), (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_AUDIO), children: t2("Disable audio") }), (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SEND_VIDEO), children: t2("Disable video") }), (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { onClick: revokePermission(OwnCapability.SCREENSHARE), children: t2("Disable screen sharing") })] })] });
};
var isComponentType = (elementOrComponent) => {
  return elementOrComponent === null ? false : !(0, import_react2.isValidElement)(elementOrComponent);
};
var chunk = (array, size2) => {
  const chunkCount = Math.ceil(array.length / size2);
  return Array.from({ length: chunkCount }, (_2, index) => array.slice(size2 * index, size2 * index + size2));
};
var applyElementToRef = (ref, element) => {
  if (!ref)
    return;
  if (typeof ref === "function")
    return ref(element);
  ref.current = element;
};
var BaseVideo = (0, import_react2.forwardRef)(function BaseVideo2({ stream, ...rest }, ref) {
  const [videoElement, setVideoElement] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (!videoElement || !stream)
      return;
    if (stream === videoElement.srcObject)
      return;
    videoElement.srcObject = stream;
    if (browsers.isSafari() || browsers.isFirefox()) {
      setTimeout(() => {
        videoElement.srcObject = stream;
        videoElement.play().catch((e2) => {
          console.error(`Failed to play stream`, e2);
        });
      }, 0);
    }
    return () => {
      videoElement.pause();
      videoElement.srcObject = null;
    };
  }, [stream, videoElement]);
  return (0, import_jsx_runtime2.jsx)("video", { autoPlay: true, playsInline: true, ...rest, ref: (element) => {
    applyElementToRef(ref, element);
    setVideoElement(element);
  } });
});
var BaseVideoPlaceholder = (0, import_react2.forwardRef)(function DefaultVideoPlaceholder({ participant, style, children }, ref) {
  const [error, setError] = (0, import_react2.useState)(false);
  const name2 = participant.name || participant.userId;
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__video-placeholder", style, ref, children: [(!participant.image || error) && (name2 ? (0, import_jsx_runtime2.jsx)(InitialsFallback, { name: name2 }) : (0, import_jsx_runtime2.jsx)("div", { className: "str-video__video-placeholder__no-video-label", children })), participant.image && !error && (0, import_jsx_runtime2.jsx)("img", { onError: () => setError(true), alt: name2, className: "str-video__video-placeholder__avatar", src: participant.image })] });
});
var InitialsFallback = (props) => {
  const { name: name2 } = props;
  const initials = name2.split(" ").slice(0, 2).map((n2) => n2[0]).join("");
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__video-placeholder__initials-fallback", children: initials });
};
var DefaultVideoPlaceholder2 = (0, import_react2.forwardRef)(function DefaultVideoPlaceholder3(props, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)(BaseVideoPlaceholder, { ref, ...props, children: t2("Video is disabled") });
});
var DefaultPictureInPicturePlaceholder = (0, import_react2.forwardRef)(function DefaultPictureInPicturePlaceholder2(props, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)(BaseVideoPlaceholder, { ref, ...props, children: t2("Video is playing in a popup") });
});
var Video$1 = ({ enabled = true, mirror, trackType, participant, className, VideoPlaceholder = DefaultVideoPlaceholder2, PictureInPicturePlaceholder = DefaultPictureInPicturePlaceholder, refs, ...rest }) => {
  const { sessionId, videoStream, screenShareStream, viewportVisibilityState, isLocalParticipant, userId } = participant;
  const call = useCall();
  const [videoElement, setVideoElement] = (0, import_react2.useState)(null);
  const [isVideoPaused, setIsVideoPaused] = (0, import_react2.useState)(true);
  const [isWideMode, setIsWideMode] = (0, import_react2.useState)(true);
  const isPiP = usePictureInPictureState(videoElement ?? void 0);
  const stream = trackType === "videoTrack" ? videoStream : trackType === "screenShareTrack" ? screenShareStream : void 0;
  (0, import_react2.useLayoutEffect)(() => {
    if (!call || !videoElement || trackType === "none")
      return;
    const cleanup = call.bindVideoElement(videoElement, sessionId, trackType);
    return () => {
      cleanup?.();
    };
  }, [call, trackType, sessionId, videoElement]);
  (0, import_react2.useEffect)(() => {
    if (!stream || !videoElement)
      return;
    const [track] = stream.getVideoTracks();
    if (!track)
      return;
    const handlePlayPause = () => {
      setIsVideoPaused(videoElement.paused);
      const { width = 0, height = 0 } = track.getSettings();
      setIsWideMode(width >= height);
    };
    setIsVideoPaused(videoElement.paused);
    videoElement.addEventListener("play", handlePlayPause);
    videoElement.addEventListener("pause", handlePlayPause);
    track.addEventListener("unmute", handlePlayPause);
    return () => {
      videoElement.removeEventListener("play", handlePlayPause);
      videoElement.removeEventListener("pause", handlePlayPause);
      track.removeEventListener("unmute", handlePlayPause);
      setIsVideoPaused(true);
    };
  }, [stream, videoElement]);
  if (!call)
    return null;
  const isPublishingTrack = trackType === "videoTrack" ? hasVideo(participant) : trackType === "screenShareTrack" ? hasScreenShare(participant) : false;
  const isInvisible = trackType === "none" || viewportVisibilityState?.[trackType] === VisibilityState.INVISIBLE;
  const hasNoVideoOrInvisible = !enabled || !isPublishingTrack || isInvisible || hasPausedTrack(participant, trackType);
  const mirrorVideo = mirror === void 0 ? isLocalParticipant && trackType === "videoTrack" : mirror;
  const isScreenShareTrack = trackType === "screenShareTrack";
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [!hasNoVideoOrInvisible && (0, import_jsx_runtime2.jsx)("video", { ...rest, className: clsx_default("str-video__video", className, {
    "str-video__video--not-playing": isVideoPaused,
    "str-video__video--tall": !isWideMode,
    "str-video__video--mirror": mirrorVideo,
    "str-video__video--screen-share": isScreenShareTrack
  }), "data-user-id": userId, "data-session-id": sessionId, ref: (element) => {
    setVideoElement(element);
    refs?.setVideoElement?.(element);
  } }), isPiP && PictureInPicturePlaceholder && (0, import_jsx_runtime2.jsx)(PictureInPicturePlaceholder, { style: { position: "absolute" }, participant }), (hasNoVideoOrInvisible || isVideoPaused) && VideoPlaceholder && (0, import_jsx_runtime2.jsx)(VideoPlaceholder, { style: { position: "absolute" }, participant, ref: refs?.setVideoPlaceholderElement })] });
};
Video$1.displayName = "Video";
var useTrackElementVisibility = ({ trackedElement, dynascaleManager: propsDynascaleManager, sessionId, trackType }) => {
  const call = useCall();
  const manager = propsDynascaleManager ?? call?.dynascaleManager;
  (0, import_react2.useEffect)(() => {
    if (!trackedElement || !manager || !call || trackType === "none")
      return;
    const unobserve = manager.trackElementVisibility(trackedElement, sessionId, trackType);
    return () => {
      unobserve();
    };
  }, [trackedElement, manager, call, sessionId, trackType]);
};
var Avatar = ({ imageSrc, name: name2, style, className, ...rest }) => {
  const [error, setError] = (0, import_react2.useState)(false);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(!imageSrc || error) && name2 && (0, import_jsx_runtime2.jsx)(AvatarFallback, { className, style, names: [name2] }), imageSrc && !error && (0, import_jsx_runtime2.jsx)("img", { onError: () => setError(true), alt: "avatar", className: clsx_default("str-video__avatar", className), src: imageSrc, style, ...rest })] });
};
var AvatarFallback = ({ className, names, style }) => {
  return (0, import_jsx_runtime2.jsx)("div", { className: clsx_default("str-video__avatar--initials-fallback", className), style, children: (0, import_jsx_runtime2.jsxs)("div", { children: [names[0][0], names[1]?.[0]] }) });
};
var ALPHA = 0.2;
var FPS_WARNING_THRESHOLD_LOWER = 23;
var FPS_WARNING_THRESHOLD_UPPER = 25;
var DEFAULT_FPS = 30;
var DEVIATION_LIMIT = 0.5;
var OUTLIER_PERSISTENCE = 5;
var FilterEngine;
(function(FilterEngine2) {
  FilterEngine2[FilterEngine2["TF"] = 0] = "TF";
  FilterEngine2[FilterEngine2["MEDIA_PIPE"] = 1] = "MEDIA_PIPE";
  FilterEngine2[FilterEngine2["NONE"] = 2] = "NONE";
})(FilterEngine || (FilterEngine = {}));
var PerformanceDegradationReason;
(function(PerformanceDegradationReason2) {
  PerformanceDegradationReason2["FRAME_DROP"] = "frame-drop";
  PerformanceDegradationReason2["CPU_THROTTLING"] = "cpu-throttling";
})(PerformanceDegradationReason || (PerformanceDegradationReason = {}));
var BackgroundFiltersContext = (0, import_react2.createContext)(void 0);
var useBackgroundFilters = () => {
  const context2 = (0, import_react2.useContext)(BackgroundFiltersContext);
  if (!context2) {
    throw new Error("useBackgroundFilters must be used within a BackgroundFiltersProvider");
  }
  return context2;
};
var determineEngine = async (useLegacyFilter, forceSafariSupport, forceMobileSupport) => {
  const isTfPlatformSupported = await isPlatformSupported({
    forceSafariSupport,
    forceMobileSupport
  });
  if (useLegacyFilter) {
    return isTfPlatformSupported ? FilterEngine.TF : FilterEngine.NONE;
  }
  const isMediaPipeSupported = await isMediaPipePlatformSupported({
    forceSafariSupport,
    forceMobileSupport
  });
  return isMediaPipeSupported ? FilterEngine.MEDIA_PIPE : FilterEngine.NONE;
};
var BackgroundFiltersProvider = (props) => {
  const { children, backgroundImages = [], backgroundFilter: bgFilterFromProps = void 0, backgroundImage: bgImageFromProps = void 0, backgroundBlurLevel: bgBlurLevelFromProps = void 0, tfFilePath, modelFilePath, useLegacyFilter, basePath, onError, performanceThresholds, forceSafariSupport, forceMobileSupport } = props;
  const call = useCall();
  const { useCallStatsReport: useCallStatsReport2 } = useCallStateHooks();
  const callStatsReport = useCallStatsReport2();
  const [backgroundFilter, setBackgroundFilter] = (0, import_react2.useState)(bgFilterFromProps);
  const [backgroundImage, setBackgroundImage] = (0, import_react2.useState)(bgImageFromProps);
  const [backgroundBlurLevel, setBackgroundBlurLevel] = (0, import_react2.useState)(bgBlurLevelFromProps);
  const [showLowFpsWarning, setShowLowFpsWarning] = (0, import_react2.useState)(false);
  const fpsWarningThresholdLower = performanceThresholds?.fpsWarningThresholdLower ?? FPS_WARNING_THRESHOLD_LOWER;
  const fpsWarningThresholdUpper = performanceThresholds?.fpsWarningThresholdUpper ?? FPS_WARNING_THRESHOLD_UPPER;
  const defaultFps = performanceThresholds?.defaultFps ?? DEFAULT_FPS;
  const emaRef = (0, import_react2.useRef)(defaultFps);
  const outlierStreakRef = (0, import_react2.useRef)(0);
  const handleStats = (0, import_react2.useCallback)((stats) => {
    const fps = stats?.fps;
    if (fps === void 0 || fps === null) {
      emaRef.current = defaultFps;
      outlierStreakRef.current = 0;
      setShowLowFpsWarning(false);
      return;
    }
    const prevEma = emaRef.current;
    const deviation = Math.abs(fps - prevEma) / prevEma;
    const isOutlier = fps < prevEma && deviation > DEVIATION_LIMIT;
    outlierStreakRef.current = isOutlier ? outlierStreakRef.current + 1 : 0;
    if (isOutlier && outlierStreakRef.current < OUTLIER_PERSISTENCE)
      return;
    emaRef.current = ALPHA * fps + (1 - ALPHA) * prevEma;
    setShowLowFpsWarning((prev) => {
      if (prev && emaRef.current > fpsWarningThresholdUpper)
        return false;
      if (!prev && emaRef.current < fpsWarningThresholdLower)
        return true;
      return prev;
    });
  }, [fpsWarningThresholdLower, fpsWarningThresholdUpper, defaultFps]);
  const performance2 = (0, import_react2.useMemo)(() => {
    if (!backgroundFilter) {
      return { degraded: false };
    }
    const reasons = [];
    if (showLowFpsWarning) {
      reasons.push(PerformanceDegradationReason.FRAME_DROP);
    }
    const qualityLimitationReasons = callStatsReport?.publisherStats?.qualityLimitationReasons;
    if (showLowFpsWarning && qualityLimitationReasons && qualityLimitationReasons?.includes("cpu")) {
      reasons.push(PerformanceDegradationReason.CPU_THROTTLING);
    }
    return {
      degraded: reasons.length > 0,
      reason: reasons.length > 0 ? reasons : void 0
    };
  }, [
    showLowFpsWarning,
    callStatsReport?.publisherStats?.qualityLimitationReasons,
    backgroundFilter
  ]);
  const prevDegradedRef = (0, import_react2.useRef)(void 0);
  (0, import_react2.useEffect)(() => {
    const currentDegraded = performance2.degraded;
    const prevDegraded = prevDegradedRef.current;
    if (!!backgroundFilter && prevDegraded !== void 0 && prevDegraded !== currentDegraded) {
      call?.tracer.trace("backgroundFilters.performance", {
        degraded: currentDegraded,
        reason: performance2?.reason,
        fps: emaRef.current
      });
    }
    prevDegradedRef.current = currentDegraded;
  }, [
    performanceThresholds,
    performance2.degraded,
    performance2.reason,
    backgroundFilter,
    call?.tracer
  ]);
  const applyBackgroundImageFilter = (0, import_react2.useCallback)((imageUrl) => {
    setBackgroundFilter("image");
    setBackgroundImage(imageUrl);
  }, []);
  const applyBackgroundBlurFilter = (0, import_react2.useCallback)((blurLevel = "high") => {
    setBackgroundFilter("blur");
    setBackgroundBlurLevel(blurLevel);
  }, []);
  const disableBackgroundFilter = (0, import_react2.useCallback)(() => {
    setBackgroundFilter(void 0);
    setBackgroundImage(void 0);
    setBackgroundBlurLevel(void 0);
    emaRef.current = defaultFps;
    outlierStreakRef.current = 0;
    setShowLowFpsWarning(false);
  }, [defaultFps]);
  const [engine, setEngine] = (0, import_react2.useState)(FilterEngine.NONE);
  const [isSupported, setIsSupported] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    determineEngine(useLegacyFilter, forceSafariSupport, forceMobileSupport).then((determinedEngine) => {
      setEngine(determinedEngine);
      setIsSupported(determinedEngine !== FilterEngine.NONE);
    });
  }, [forceMobileSupport, forceSafariSupport, useLegacyFilter]);
  const [tfLite, setTfLite] = (0, import_react2.useState)();
  (0, import_react2.useEffect)(() => {
    if (engine !== FilterEngine.TF)
      return;
    loadTFLite({ basePath, modelFilePath, tfFilePath }).then(setTfLite).catch((err) => console.error("Failed to load TFLite", err));
  }, [basePath, engine, modelFilePath, tfFilePath]);
  const [mediaPipe, setMediaPipe] = (0, import_react2.useState)();
  (0, import_react2.useEffect)(() => {
    if (engine !== FilterEngine.MEDIA_PIPE)
      return;
    loadMediaPipe({
      basePath,
      modelPath: modelFilePath
    }).then(setMediaPipe).catch((err) => console.error("Failed to preload MediaPipe", err));
  }, [engine, modelFilePath, basePath]);
  const handleError = (0, import_react2.useCallback)((error) => {
    console.warn("[filters] Filter encountered an error and will be disabled");
    disableBackgroundFilter();
    onError?.(error);
  }, [disableBackgroundFilter, onError]);
  const isReady = useLegacyFilter ? !!tfLite : !!mediaPipe;
  return (0, import_jsx_runtime2.jsxs)(BackgroundFiltersContext.Provider, { value: {
    isSupported,
    performance: performance2,
    isReady,
    backgroundImage,
    backgroundBlurLevel,
    backgroundFilter,
    disableBackgroundFilter,
    applyBackgroundBlurFilter,
    applyBackgroundImageFilter,
    backgroundImages,
    tfFilePath,
    modelFilePath,
    basePath,
    onError: handleError
  }, children: [children, isReady && (0, import_jsx_runtime2.jsx)(BackgroundFilters, { tfLite, engine, onStats: handleStats })] });
};
var BackgroundFilters = (props) => {
  const call = useCall();
  const { children, start } = useRenderer(props.tfLite, call, props.engine);
  const { onError, backgroundFilter } = useBackgroundFilters();
  const handleErrorRef = (0, import_react2.useRef)(void 0);
  handleErrorRef.current = onError;
  const handleStatsRef = (0, import_react2.useRef)(void 0);
  handleStatsRef.current = props.onStats;
  (0, import_react2.useEffect)(() => {
    if (!call || !backgroundFilter)
      return;
    const { unregister } = call.camera.registerFilter((ms2) => {
      return start(ms2, (error) => handleErrorRef.current?.(error), (stats) => handleStatsRef.current?.(stats));
    });
    return () => {
      unregister().catch((err) => console.warn(`Can't unregister filter`, err));
    };
  }, [call, start, backgroundFilter]);
  return children;
};
var useRenderer = (tfLite, call, engine) => {
  const { backgroundFilter, backgroundBlurLevel, backgroundImage, modelFilePath, basePath } = useBackgroundFilters();
  const videoRef = (0, import_react2.useRef)(null);
  const canvasRef = (0, import_react2.useRef)(null);
  const bgImageRef = (0, import_react2.useRef)(null);
  const [videoSize, setVideoSize] = (0, import_react2.useState)({
    width: 1920,
    height: 1080
  });
  const start = (0, import_react2.useCallback)((ms2, onError, onStats) => {
    let outputStream;
    let processor;
    let renderer;
    const output = new Promise((resolve, reject) => {
      if (!backgroundFilter) {
        reject(new Error("No filter specified"));
        return;
      }
      const videoEl = videoRef.current;
      const canvasEl = canvasRef.current;
      const bgImageEl = bgImageRef.current;
      const [track] = ms2.getVideoTracks();
      if (!track) {
        reject(new Error("No video tracks in input media stream"));
        return;
      }
      if (engine === FilterEngine.MEDIA_PIPE) {
        call?.tracer.trace("backgroundFilters.enable", {
          backgroundFilter,
          backgroundBlurLevel,
          backgroundImage,
          engine
        });
        if (!videoEl) {
          reject(new Error("Renderer started before elements are ready"));
          return;
        }
        const trackSettings = track.getSettings();
        (0, import_react_dom.flushSync)(() => setVideoSize({
          width: trackSettings.width ?? 0,
          height: trackSettings.height ?? 0
        }));
        processor = new VirtualBackground(track, {
          basePath,
          modelPath: modelFilePath,
          backgroundBlurLevel,
          backgroundImage,
          backgroundFilter
        }, { onError, onStats });
        processor.start().then((processedTrack) => {
          outputStream = new MediaStream([processedTrack]);
          resolve(outputStream);
        }).catch((error) => {
          reject(error);
        });
        return;
      }
      if (engine === FilterEngine.TF) {
        if (!videoEl || !canvasEl || backgroundImage && !bgImageEl) {
          reject(new Error("Renderer started before elements are ready"));
          return;
        }
        videoEl.srcObject = ms2;
        videoEl.play().then(() => {
          const trackSettings = track.getSettings();
          (0, import_react_dom.flushSync)(() => setVideoSize({
            width: trackSettings.width ?? 0,
            height: trackSettings.height ?? 0
          }));
          call?.tracer.trace("backgroundFilters.enable", {
            backgroundFilter,
            backgroundBlurLevel,
            backgroundImage,
            engine
          });
          if (!tfLite) {
            reject(new Error("TensorFlow Lite not loaded"));
            return;
          }
          renderer = createRenderer(tfLite, videoEl, canvasEl, {
            backgroundFilter,
            backgroundBlurLevel,
            backgroundImage: bgImageEl ?? void 0
          }, onError);
          outputStream = canvasEl.captureStream();
          resolve(outputStream);
        }, () => {
          reject(new Error("Could not play the source video stream"));
        });
        return;
      }
      reject(new Error("No supported engine available"));
    });
    return {
      output,
      stop: () => {
        call?.tracer.trace("backgroundFilters.disable", null);
        processor?.stop();
        renderer?.dispose();
        if (videoRef.current)
          videoRef.current.srcObject = null;
        if (outputStream)
          disposeOfMediaStream(outputStream);
      }
    };
  }, [
    backgroundBlurLevel,
    backgroundFilter,
    backgroundImage,
    call?.tracer,
    tfLite,
    engine,
    modelFilePath,
    basePath
  ]);
  const children = (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__background-filters", children: [(0, import_jsx_runtime2.jsx)("video", { className: clsx_default("str-video__background-filters__video", videoSize.height > videoSize.width && "str-video__background-filters__video--tall"), ref: videoRef, playsInline: true, muted: true, controls: false, ...videoSize }), backgroundImage && (0, import_jsx_runtime2.jsx)("img", { className: "str-video__background-filters__background-image", alt: "Background", ref: bgImageRef, crossOrigin: "anonymous", src: backgroundImage, ...videoSize }), (0, import_jsx_runtime2.jsx)("canvas", { className: "str-video__background-filters__target-canvas", ...videoSize, ref: canvasRef })] });
  return { start, children };
};
var IconButton = (0, import_react2.forwardRef)(function IconButton2(props, ref) {
  const { icon, enabled, variant, onClick, className, ...rest } = props;
  return (0, import_jsx_runtime2.jsx)("button", { className: clsx_default("str-video__call-controls__button", className, {
    [`str-video__call-controls__button--variant-${variant}`]: variant,
    "str-video__call-controls__button--enabled": enabled
  }), onClick: (e2) => {
    e2.preventDefault();
    onClick?.(e2);
  }, ref, ...rest, children: (0, import_jsx_runtime2.jsx)(Icon, { icon }) });
});
var CompositeButton = (0, import_react2.forwardRef)(function CompositeButton2({ disabled, caption, children, className, active, Menu: Menu2, menuPlacement, menuOffset, title, ToggleMenuButton: ToggleMenuButton3 = DefaultToggleMenuButton, variant, onClick, onMenuToggle, ...restButtonProps }, ref) {
  return (0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__composite-button", className, {
    "str-video__composite-button--caption": caption,
    "str-video__composite-button--menu": Menu2
  }), title, ref, children: [(0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__composite-button__button-group", {
    "str-video__composite-button__button-group--active": active,
    "str-video__composite-button__button-group--active-primary": active && variant === "primary",
    "str-video__composite-button__button-group--active-secondary": active && variant === "secondary",
    "str-video__composite-button__button-group--disabled": disabled
  }), children: [(0, import_jsx_runtime2.jsx)("button", { type: "button", className: "str-video__composite-button__button", onClick: (e2) => {
    e2.preventDefault();
    onClick?.(e2);
  }, disabled, ...restButtonProps, children }), Menu2 && (0, import_jsx_runtime2.jsx)(MenuToggle, { offset: menuOffset, placement: menuPlacement, ToggleButton: ToggleMenuButton3, onToggle: onMenuToggle, children: isComponentType(Menu2) ? (0, import_jsx_runtime2.jsx)(Menu2, {}) : Menu2 })] }), caption && (0, import_jsx_runtime2.jsx)("div", { className: "str-video__composite-button__caption", children: caption })] });
});
var DefaultToggleMenuButton = (0, import_react2.forwardRef)(function DefaultToggleMenuButton2({ menuShown }, ref) {
  return (0, import_jsx_runtime2.jsx)(IconButton, { className: clsx_default("str-video__menu-toggle-button", {
    "str-video__menu-toggle-button--active": menuShown
  }), icon: menuShown ? "caret-down" : "caret-up", ref });
});
var TextButton = ({ children, ...rest }) => {
  return (0, import_jsx_runtime2.jsx)("button", { ...rest, className: "str-video__text-button", children });
};
var AcceptCallButton = ({ disabled, onAccept, onClick }) => {
  const call = useCall();
  const handleClick = (0, import_react2.useCallback)(async (e2) => {
    if (onClick) {
      onClick(e2);
    } else if (call) {
      await call.join();
      onAccept?.();
    }
  }, [onClick, onAccept, call]);
  return (0, import_jsx_runtime2.jsx)(IconButton, { disabled, icon: "call-accept", variant: "success", "data-testid": "accept-call-button", onClick: handleClick });
};
var Notification2 = (props) => {
  const { isVisible, message, children, visibilityTimeout, resetIsVisible, placement = "top", className, iconClassName = "str-video__notification__icon", close } = props;
  const { refs, x: x2, y: y2, strategy } = useFloatingUIPreset({
    placement,
    strategy: "absolute"
  });
  (0, import_react2.useEffect)(() => {
    if (!isVisible || !visibilityTimeout || !resetIsVisible)
      return;
    const timeout2 = setTimeout(() => {
      resetIsVisible();
    }, visibilityTimeout);
    return () => clearTimeout(timeout2);
  }, [isVisible, resetIsVisible, visibilityTimeout]);
  return (0, import_jsx_runtime2.jsxs)("div", { ref: refs.setReference, children: [isVisible && (0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__notification", className), ref: refs.setFloating, style: {
    position: strategy,
    top: y2 ?? 0,
    left: x2 ?? 0,
    overflowY: "auto"
  }, children: [iconClassName && (0, import_jsx_runtime2.jsx)("i", { className: iconClassName }), (0, import_jsx_runtime2.jsx)("span", { className: "str-video__notification__message", children: message }), close ? (0, import_jsx_runtime2.jsx)("i", { className: "str-video__icon str-video__icon--close str-video__notification__close", onClick: close }) : null] }), children] });
};
var PermissionNotification = (props) => {
  const { permission, isAwaitingApproval, messageApproved, messageAwaitingApproval, messageRevoked, visibilityTimeout = 3500, children } = props;
  const { useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const hasPermission = useHasPermissions2(permission);
  const prevHasPermission = (0, import_react2.useRef)(hasPermission);
  const [showNotification, setShowNotification] = (0, import_react2.useState)();
  (0, import_react2.useEffect)(() => {
    if (prevHasPermission.current === hasPermission)
      return;
    if (hasPermission) {
      setShowNotification("granted");
      prevHasPermission.current = true;
    } else {
      setShowNotification("revoked");
      prevHasPermission.current = false;
    }
  }, [hasPermission]);
  const resetIsVisible = (0, import_react2.useCallback)(() => setShowNotification(void 0), []);
  if (isAwaitingApproval) {
    return (0, import_jsx_runtime2.jsx)(Notification2, { isVisible: isAwaitingApproval && !hasPermission, message: messageAwaitingApproval, children });
  }
  return (0, import_jsx_runtime2.jsx)(Notification2, { isVisible: !!showNotification, visibilityTimeout, resetIsVisible, message: showNotification === "granted" ? messageApproved : messageRevoked, children });
};
var SpeakingWhileMutedNotification = ({ children, text, placement }) => {
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { isSpeakingWhileMuted } = useMicrophoneState2();
  const { t: t2 } = useI18n();
  const message = text ?? t2("You are muted. Unmute to speak.");
  return (0, import_jsx_runtime2.jsx)(Notification2, { message, isVisible: isSpeakingWhileMuted, placement: placement || "top-start", children });
};
var RecordingInProgressNotification = ({ children, text }) => {
  const { t: t2 } = useI18n();
  const { isCallRecordingInProgress } = useToggleCallRecording();
  const [isVisible, setVisible] = (0, import_react2.useState)(false);
  const message = text ?? t2("Recording in progress...");
  (0, import_react2.useEffect)(() => {
    if (isCallRecordingInProgress) {
      setVisible(true);
    } else {
      setVisible(false);
    }
  }, [isCallRecordingInProgress]);
  return (0, import_jsx_runtime2.jsx)(Notification2, { message, iconClassName: "str-video__icon str-video__icon--recording-on", isVisible, placement: "top-start", close: () => setVisible(false), children });
};
var LoadingIndicator = ({ className, type = "spinner", text, tooltip }) => {
  return (0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__loading-indicator", className), title: tooltip, children: [(0, import_jsx_runtime2.jsx)("div", { className: clsx_default("str-video__loading-indicator__icon", type) }), text && (0, import_jsx_runtime2.jsx)("p", { className: "str-video__loading-indicator-text", children: text })] });
};
var Tooltip = ({ children, referenceElement, tooltipClassName, tooltipPlacement = "top", visible = false }) => {
  const arrowRef = (0, import_react2.useRef)(null);
  const { refs, x: x2, y: y2, strategy, context: context2 } = useFloatingUIPreset({
    placement: tooltipPlacement,
    strategy: "absolute",
    middleware: [arrow({ element: arrowRef })]
  });
  (0, import_react2.useEffect)(() => {
    refs.setReference(referenceElement);
  }, [referenceElement, refs]);
  if (!visible)
    return null;
  return (0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__tooltip", tooltipClassName), ref: refs.setFloating, style: {
    position: strategy,
    top: y2 ?? 0,
    left: x2 ?? 0
  }, children: [(0, import_jsx_runtime2.jsx)(FloatingArrow, { ref: arrowRef, context: context2, fill: "var(--str-video__tooltip--background-color)" }), children] });
};
var useEnterLeaveHandlers = ({ onMouseEnter, onMouseLeave } = {}) => {
  const [tooltipVisible, setTooltipVisible] = (0, import_react2.useState)(false);
  const handleMouseEnter = (0, import_react2.useCallback)((e2) => {
    setTooltipVisible(true);
    onMouseEnter?.(e2);
  }, [onMouseEnter]);
  const handleMouseLeave = (0, import_react2.useCallback)((e2) => {
    setTooltipVisible(false);
    onMouseLeave?.(e2);
  }, [onMouseLeave]);
  return { handleMouseEnter, handleMouseLeave, tooltipVisible };
};
var WithTooltip = ({ title, tooltipClassName, tooltipPlacement, tooltipDisabled, ...props }) => {
  const { handleMouseEnter, handleMouseLeave, tooltipVisible } = useEnterLeaveHandlers();
  const [tooltipAnchor, setTooltipAnchor] = (0, import_react2.useState)(null);
  const tooltipActuallyVisible = !tooltipDisabled && Boolean(title) && tooltipVisible;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(Tooltip, { referenceElement: tooltipAnchor, visible: tooltipActuallyVisible, tooltipClassName, tooltipPlacement, children: title || "" }), (0, import_jsx_runtime2.jsx)("div", { ref: setTooltipAnchor, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ...props })] });
};
var RecordEndConfirmation = () => {
  const { t: t2 } = useI18n();
  const { toggleCallRecording, isAwaitingResponse } = useToggleCallRecording();
  const { close } = useMenuContext();
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__end-recording__confirmation", children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__end-recording__header", children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "recording-on" }), (0, import_jsx_runtime2.jsx)("h2", { className: "str-video__end-recording__heading", children: t2("End recording") })] }), (0, import_jsx_runtime2.jsx)("p", { className: "str-video__end-recording__description", children: t2("Are you sure you want end the recording?") }), (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__end-recording__actions", children: [(0, import_jsx_runtime2.jsx)(CompositeButton, { variant: "secondary", onClick: close, children: t2("Cancel") }), (0, import_jsx_runtime2.jsx)(CompositeButton, { variant: "primary", onClick: toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime2.jsx)(LoadingIndicator, {}) : t2("End recording") })] })] });
};
var ToggleEndRecordingMenuButton = (0, import_react2.forwardRef)(function ToggleEndRecordingMenuButton2(props, ref) {
  return (0, import_jsx_runtime2.jsx)(CompositeButton, { ref, active: true, variant: "secondary", "data-testid": "recording-stop-button", children: (0, import_jsx_runtime2.jsx)(Icon, { icon: "recording-off" }) });
});
var RecordCallConfirmationButton = ({ caption }) => {
  const { t: t2 } = useI18n();
  const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
  if (isCallRecordingInProgress) {
    return (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [
      OwnCapability.START_RECORD_CALL,
      OwnCapability.STOP_RECORD_CALL
    ], children: (0, import_jsx_runtime2.jsx)(MenuToggle, { ToggleButton: ToggleEndRecordingMenuButton, visualType: MenuVisualType.PORTAL, children: (0, import_jsx_runtime2.jsx)(RecordEndConfirmation, {}) }) });
  }
  const title = isAwaitingResponse ? t2("Waiting for recording to start...") : caption ?? t2("Record call");
  return (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [
    OwnCapability.START_RECORD_CALL,
    OwnCapability.STOP_RECORD_CALL
  ], children: (0, import_jsx_runtime2.jsx)(WithTooltip, { title, children: (0, import_jsx_runtime2.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption, variant: "secondary", "data-testid": "recording-start-button", onClick: isAwaitingResponse ? void 0 : toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime2.jsx)(LoadingIndicator, {}) : (0, import_jsx_runtime2.jsx)(Icon, { icon: "recording-off" }) }) }) });
};
var RecordCallButton = ({ caption }) => {
  const { t: t2 } = useI18n();
  const { toggleCallRecording, isAwaitingResponse, isCallRecordingInProgress } = useToggleCallRecording();
  let title = caption ?? t2("Record call");
  if (isAwaitingResponse) {
    title = isCallRecordingInProgress ? t2("Waiting for recording to stop...") : t2("Waiting for recording to start...");
  }
  return (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [
    OwnCapability.START_RECORD_CALL,
    OwnCapability.STOP_RECORD_CALL
  ], children: (0, import_jsx_runtime2.jsx)(CompositeButton, { active: isCallRecordingInProgress, caption, variant: "secondary", "data-testid": isCallRecordingInProgress ? "recording-stop-button" : "recording-start-button", title, onClick: isAwaitingResponse ? void 0 : toggleCallRecording, children: isAwaitingResponse ? (0, import_jsx_runtime2.jsx)(LoadingIndicator, {}) : (0, import_jsx_runtime2.jsx)(Icon, { icon: isCallRecordingInProgress ? "recording-on" : "recording-off" }) }) });
};
var defaultEmojiReactionMap = {
  ":like:": "",
  ":raise-hand:": "",
  ":fireworks:": "",
  ":dislike:": "",
  ":heart:": "",
  ":smile:": ""
};
var Reaction = ({ participant: { reaction, sessionId }, hideAfterTimeoutInMs = 5500, emojiReactionMap = defaultEmojiReactionMap }) => {
  const call = useCall();
  (0, import_react2.useEffect)(() => {
    if (!call || !reaction)
      return;
    const timeoutId = setTimeout(() => {
      call.resetReaction(sessionId);
    }, hideAfterTimeoutInMs);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [call, hideAfterTimeoutInMs, reaction, sessionId]);
  if (!reaction)
    return null;
  const { emoji_code: emojiCode } = reaction;
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__reaction", children: (0, import_jsx_runtime2.jsx)("span", { className: "str-video__reaction__emoji", children: emojiCode && emojiReactionMap[emojiCode] }) });
};
var defaultReactions = [
  {
    type: "reaction",
    emoji_code: ":like:"
  },
  {
    // TODO OL: use `prompt` type?
    type: "raised-hand",
    emoji_code: ":raise-hand:"
  },
  {
    type: "reaction",
    emoji_code: ":fireworks:"
  },
  {
    type: "reaction",
    emoji_code: ":dislike:"
  },
  {
    type: "reaction",
    emoji_code: ":heart:"
  },
  {
    type: "reaction",
    emoji_code: ":smile:"
  }
];
var ReactionsButton = ({ reactions = defaultReactions }) => {
  return (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: (0, import_jsx_runtime2.jsx)(MenuToggle, { placement: "top", ToggleButton: ToggleReactionsMenuButton, visualType: MenuVisualType.MENU, children: (0, import_jsx_runtime2.jsx)(DefaultReactionsMenu, { reactions }) }) });
};
var ToggleReactionsMenuButton = (0, import_react2.forwardRef)(function ToggleReactionsMenuButton2({ menuShown }, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)(WithTooltip, { title: t2("Reactions"), tooltipDisabled: menuShown, children: (0, import_jsx_runtime2.jsx)(CompositeButton, { ref, active: menuShown, variant: "primary", children: (0, import_jsx_runtime2.jsx)(Icon, { icon: "reactions" }) }) });
});
var DefaultReactionsMenu = ({ reactions, layout = "horizontal" }) => {
  const call = useCall();
  const { close } = useMenuContext();
  return (0, import_jsx_runtime2.jsx)("div", { className: clsx_default("str-video__reactions-menu", {
    "str-video__reactions-menu--horizontal": layout === "horizontal",
    "str-video__reactions-menu--vertical": layout === "vertical"
  }), children: reactions.map((reaction) => (0, import_jsx_runtime2.jsx)("button", { type: "button", className: "str-video__reactions-menu__button", onClick: () => {
    call?.sendReaction(reaction);
    close?.();
  }, children: reaction.emoji_code && defaultEmojiReactionMap[reaction.emoji_code] }, reaction.emoji_code)) });
};
var createCallControlHandler = (props, handler) => {
  return async () => {
    try {
      await handler();
    } catch (error) {
      if (props.onError) {
        props.onError(error);
        return;
      }
      if (!isNotAllowedError(error)) {
        console.error("Call control handler failed", error);
      }
    }
  };
};
function isNotAllowedError(error) {
  return error instanceof DOMException && error.name === "NotAllowedError";
}
var ScreenShareButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption, optimisticUpdates } = props;
  const { useHasOngoingScreenShare: useHasOngoingScreenShare2, useScreenShareState: useScreenShareState2, useCallSettings: useCallSettings2 } = useCallStateHooks();
  const isSomeoneScreenSharing = useHasOngoingScreenShare2();
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SCREENSHARE);
  const callSettings = useCallSettings2();
  const isScreenSharingAllowed = callSettings?.screensharing.enabled;
  const { screenShare, optionsAwareIsMute, isTogglePending } = useScreenShareState2({
    optimisticUpdates
  });
  const amIScreenSharing = !optionsAwareIsMute;
  const disableScreenShareButton = !amIScreenSharing && (isSomeoneScreenSharing || isScreenSharingAllowed === false) || !optimisticUpdates && isTogglePending;
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await screenShare.toggle();
    }
  });
  return (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: (0, import_jsx_runtime2.jsx)(PermissionNotification, { permission: OwnCapability.SCREENSHARE, isAwaitingApproval: isAwaitingPermission, messageApproved: t2("You can now share your screen."), messageAwaitingApproval: t2("Awaiting for an approval to share screen."), messageRevoked: t2("You can no longer share your screen."), children: (0, import_jsx_runtime2.jsx)(WithTooltip, { title: caption ?? t2("Share screen"), children: (0, import_jsx_runtime2.jsx)(CompositeButton, { active: isSomeoneScreenSharing || amIScreenSharing, caption, variant: "primary", "data-testid": isSomeoneScreenSharing ? "screen-share-stop-button" : "screen-share-start-button", disabled: disableScreenShareButton, onClick: handleClick, children: (0, import_jsx_runtime2.jsx)(Icon, { icon: isSomeoneScreenSharing ? "screen-share-on" : "screen-share-off" }) }) }) }) });
};
var AudioVolumeIndicator = () => {
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { isEnabled, mediaStream } = useMicrophoneState2();
  const [audioLevel, setAudioLevel] = (0, import_react2.useState)(0);
  (0, import_react2.useEffect)(() => {
    if (!isEnabled || !mediaStream)
      return;
    const disposeSoundDetector = createSoundDetector(mediaStream, ({ audioLevel: al }) => setAudioLevel(al), { detectionFrequencyInMs: 80, destroyStreamOnStop: false });
    return () => {
      disposeSoundDetector().catch(console.error);
    };
  }, [isEnabled, mediaStream]);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__audio-volume-indicator", children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: isEnabled ? "mic" : "mic-off" }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__audio-volume-indicator__bar", children: (0, import_jsx_runtime2.jsx)("div", { className: "str-video__audio-volume-indicator__bar-value", style: { transform: `scaleX(${audioLevel / 100})` } }) })] });
};
var SelectContext = (0, import_react2.createContext)({});
var Select = (props) => {
  const { children, icon, defaultSelectedLabel, defaultSelectedIndex, handleSelect: handleSelectProp } = props;
  const [isOpen, setIsOpen] = (0, import_react2.useState)(false);
  const [activeIndex, setActiveIndex] = (0, import_react2.useState)(null);
  const [selectedIndex, setSelectedIndex] = (0, import_react2.useState)(defaultSelectedIndex);
  const [selectedLabel, setSelectedLabel] = (0, import_react2.useState)(defaultSelectedLabel);
  const { refs, context: context2 } = useFloating({
    placement: "bottom-start",
    open: isOpen,
    onOpenChange: setIsOpen,
    whileElementsMounted: autoUpdate,
    middleware: [flip()]
  });
  const elementsRef = (0, import_react2.useRef)([]);
  const labelsRef = (0, import_react2.useRef)([]);
  const handleSelect = (0, import_react2.useCallback)((index) => {
    setSelectedIndex(index);
    handleSelectProp(index || 0);
    setIsOpen(false);
    if (index !== null) {
      setSelectedLabel(labelsRef.current[index]);
    }
  }, [handleSelectProp]);
  const handleTypeaheadMatch = (index) => {
    if (isOpen) {
      setActiveIndex(index);
    } else {
      handleSelect(index);
    }
  };
  const listNav = useListNavigation(context2, {
    listRef: elementsRef,
    activeIndex,
    selectedIndex,
    onNavigate: setActiveIndex
  });
  const typeahead = useTypeahead(context2, {
    listRef: labelsRef,
    activeIndex,
    selectedIndex,
    onMatch: handleTypeaheadMatch
  });
  const click = useClick(context2);
  const dismiss = useDismiss(context2);
  const role2 = useRole(context2, { role: "listbox" });
  const { getReferenceProps, getFloatingProps, getItemProps } = useInteractions([listNav, typeahead, click, dismiss, role2]);
  const selectContext = (0, import_react2.useMemo)(() => ({
    activeIndex,
    selectedIndex,
    getItemProps,
    handleSelect
  }), [activeIndex, selectedIndex, getItemProps, handleSelect]);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__dropdown", children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__dropdown-selected", ref: refs.setReference, tabIndex: 0, ...getReferenceProps(), children: [(0, import_jsx_runtime2.jsxs)("label", { className: "str-video__dropdown-selected__label", children: [icon && (0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__dropdown-selected__icon", icon }), selectedLabel] }), (0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__dropdown-selected__chevron", icon: isOpen ? "chevron-up" : "chevron-down" })] }), (0, import_jsx_runtime2.jsx)(SelectContext.Provider, { value: selectContext, children: isOpen && (0, import_jsx_runtime2.jsx)(FloatingFocusManager, { context: context2, modal: false, children: (0, import_jsx_runtime2.jsx)("div", { className: "str-video__dropdown-list", ref: refs.setFloating, ...getFloatingProps(), children: (0, import_jsx_runtime2.jsx)(FloatingList, { elementsRef, labelsRef, children }) }) }) })] });
};
var DropDownSelectOption = (props) => {
  const { selected, label, icon } = props;
  const { getItemProps, handleSelect } = (0, import_react2.useContext)(SelectContext);
  const { ref, index } = useListItem();
  return (0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__dropdown-option", {
    "str-video__dropdown-option--selected": selected
  }), ref, ...getItemProps({
    onClick: () => handleSelect(index)
  }), children: [icon && (0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__dropdown-icon", icon }), (0, import_jsx_runtime2.jsx)("span", { className: "str-video__dropdown-label", children: label })] });
};
var DropDownSelect = (props) => {
  const { children, icon, handleSelect, defaultSelectedLabel, defaultSelectedIndex } = props;
  return (0, import_jsx_runtime2.jsx)(Select, { icon, handleSelect, defaultSelectedIndex, defaultSelectedLabel, children });
};
var DeviceSelectorOption = ({ disabled, id, label, onChange, name: name2, selected, defaultChecked, value }) => {
  return (0, import_jsx_runtime2.jsxs)("label", { className: clsx_default("str-video__device-settings__option", {
    "str-video__device-settings__option--selected": selected,
    "str-video__device-settings__option--disabled": disabled
  }), htmlFor: id, children: [(0, import_jsx_runtime2.jsx)("input", { type: "radio", name: name2, onChange, value, id, checked: selected, defaultChecked, disabled }), label] });
};
var DeviceSelectorList = (props) => {
  const { devices = [], selectedDeviceId, title, type, onChange, children } = props;
  const { close } = useMenuContext();
  const { deviceList } = useDeviceList(devices, selectedDeviceId);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__device-settings__device-kind", children: [title && (0, import_jsx_runtime2.jsx)("div", { className: "str-video__device-settings__device-selector-title", children: title }), deviceList.map((device) => {
    return (0, import_jsx_runtime2.jsx)(DeviceSelectorOption, { id: `${type}--${device.deviceId}`, value: device.deviceId, label: device.label, onChange: (e2) => {
      const deviceId = e2.target.value;
      if (deviceId !== "default") {
        onChange?.(deviceId);
      }
      close?.();
    }, name: type, selected: device.isSelected }, device.deviceId);
  }), children] });
};
var DeviceSelectorDropdown = (props) => {
  const { devices = [], selectedDeviceId, title, onChange, icon } = props;
  const { deviceList, selectedDeviceInfo, selectedIndex } = useDeviceList(devices, selectedDeviceId);
  const handleSelect = (0, import_react2.useCallback)((index) => {
    const deviceId = deviceList[index].deviceId;
    if (deviceId !== "default") {
      onChange?.(deviceId);
    }
  }, [deviceList, onChange]);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__device-settings__device-kind", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__device-settings__device-selector-title", children: title }), (0, import_jsx_runtime2.jsx)(DropDownSelect, { icon, defaultSelectedIndex: selectedIndex, defaultSelectedLabel: selectedDeviceInfo.label, handleSelect, children: deviceList.map((device) => (0, import_jsx_runtime2.jsx)(DropDownSelectOption, { icon, label: device.label, selected: device.isSelected }, device.deviceId)) })] });
};
var DeviceSelector = (props) => {
  const { visualType = "list", icon, ...rest } = props;
  if (visualType === "list") {
    return (0, import_jsx_runtime2.jsx)(DeviceSelectorList, { ...rest });
  }
  return (0, import_jsx_runtime2.jsx)(DeviceSelectorDropdown, { ...rest, icon });
};
var SpeakerTest = (props) => {
  const { useSpeakerState: useSpeakerState2 } = useCallStateHooks();
  const { selectedDevice } = useSpeakerState2();
  const audioElementRef = (0, import_react2.useRef)(null);
  const [isPlaying, setIsPlaying] = (0, import_react2.useState)(false);
  const { t: t2 } = useI18n();
  const { audioUrl = `https://unpkg.com/${"@stream-io/video-react-sdk"}@${"1.27.2"}/assets/piano.mp3` } = props;
  (0, import_react2.useEffect)(() => {
    const audio = audioElementRef.current;
    if (!audio || !selectedDevice)
      return;
    if ("setSinkId" in audio) {
      audio.setSinkId(selectedDevice).catch((err) => {
        console.error("Failed to set audio output device:", err);
      });
    }
  }, [selectedDevice]);
  const handleStartTest = (0, import_react2.useCallback)(async () => {
    const audio = audioElementRef.current;
    if (!audio)
      return;
    audio.src = audioUrl;
    try {
      if (isPlaying) {
        audio.pause();
        audio.currentTime = 0;
        setIsPlaying(false);
      } else {
        await audio.play();
        setIsPlaying(true);
      }
    } catch (err) {
      console.error("Failed to play test audio:", err);
      setIsPlaying(false);
    }
  }, [isPlaying, audioUrl]);
  const handleAudioEnded = (0, import_react2.useCallback)(() => setIsPlaying(false), []);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__speaker-test", children: [(0, import_jsx_runtime2.jsx)("audio", { ref: audioElementRef, onEnded: handleAudioEnded, onPause: handleAudioEnded }), (0, import_jsx_runtime2.jsx)(CompositeButton, { className: "str-video__speaker-test__button", onClick: handleStartTest, type: "button", children: (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__speaker-test__button-content", children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "speaker" }), isPlaying ? t2("Stop test") : t2("Test speaker")] }) })] });
};
var DeviceSelectorAudioInput = ({ title, visualType, volumeIndicatorVisible = true }) => {
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { microphone, selectedDevice, devices } = useMicrophoneState2();
  return (0, import_jsx_runtime2.jsx)(DeviceSelector, { devices: devices || [], selectedDeviceId: selectedDevice, type: "audioinput", onChange: async (deviceId) => {
    await microphone.select(deviceId);
  }, title, visualType, icon: "mic", children: volumeIndicatorVisible && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)("hr", { className: "str-video__device-settings__separator" }), (0, import_jsx_runtime2.jsx)(AudioVolumeIndicator, {})] }) });
};
var DeviceSelectorAudioOutput = ({ title, visualType, speakerTestVisible = true, speakerTestAudioUrl }) => {
  const { useSpeakerState: useSpeakerState2 } = useCallStateHooks();
  const { speaker, selectedDevice, devices, isDeviceSelectionSupported } = useSpeakerState2();
  if (!isDeviceSelectionSupported)
    return null;
  return (0, import_jsx_runtime2.jsx)(DeviceSelector, { devices, type: "audiooutput", selectedDeviceId: selectedDevice, onChange: (deviceId) => {
    speaker.select(deviceId);
  }, title, visualType, icon: "speaker", children: speakerTestVisible && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)("hr", { className: "str-video__device-settings__separator" }), (0, import_jsx_runtime2.jsx)(SpeakerTest, { audioUrl: speakerTestAudioUrl })] }) });
};
var DeviceSelectorVideo = ({ title, visualType }) => {
  const { useCameraState: useCameraState2 } = useCallStateHooks();
  const { camera, devices, selectedDevice } = useCameraState2();
  return (0, import_jsx_runtime2.jsx)(DeviceSelector, { devices: devices || [], type: "videoinput", selectedDeviceId: selectedDevice, onChange: async (deviceId) => {
    await camera.select(deviceId);
  }, title, visualType, icon: "camera" });
};
var DeviceSettings = ({ visualType = MenuVisualType.MENU }) => {
  return (0, import_jsx_runtime2.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleDeviceSettingsMenuButton, visualType, children: (0, import_jsx_runtime2.jsx)(Menu, {}) });
};
var Menu = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__device-settings", children: [(0, import_jsx_runtime2.jsx)(DeviceSelectorVideo, { title: t2("Select a Camera") }), (0, import_jsx_runtime2.jsx)(DeviceSelectorAudioInput, { title: t2("Select a Mic") }), (0, import_jsx_runtime2.jsx)(DeviceSelectorAudioOutput, { title: t2("Select Speakers") })] });
};
var ToggleDeviceSettingsMenuButton = (0, import_react2.forwardRef)(function ToggleDeviceSettingsMenuButton2({ menuShown }, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)(IconButton, { className: clsx_default("str-video__device-settings__button", {
    "str-video__device-settings__button--active": menuShown
  }), title: t2("Toggle device menu"), icon: "device-settings", ref });
});
var ToggleAudioPreviewButton = (props) => {
  const { caption, Menu: Menu2 = DeviceSelectorAudioInput, menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { t: t2 } = useI18n();
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { microphone, hasBrowserPermission, isPromptingPermission, optionsAwareIsMute, isTogglePending } = useMicrophoneState2({ optimisticUpdates });
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react2.useState)(false);
  const handleClick = createCallControlHandler(props, () => microphone.toggle());
  return (0, import_jsx_runtime2.jsx)(WithTooltip, { title: !hasBrowserPermission ? t2("Check your browser audio permissions") : caption ?? t2("Mic"), tooltipDisabled, children: (0, import_jsx_runtime2.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, className: clsx_default(!hasBrowserPermission && "str-video__device-unavailable"), variant: "secondary", disabled: !hasBrowserPermission || !optimisticUpdates && isTogglePending, "data-testid": optionsAwareIsMute ? "preview-audio-unmute-button" : "preview-audio-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: !optionsAwareIsMute ? "mic" : "mic-off" }), !hasBrowserPermission && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__no-media-permission", title: t2("Check your browser audio permissions"), children: "!" }), isPromptingPermission && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) });
};
var ToggleAudioPublishingButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption, Menu: Menu2 = (0, import_jsx_runtime2.jsx)(DeviceSelectorAudioInput, { visualType: "list" }), menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_AUDIO);
  const { useMicrophoneState: useMicrophoneState2 } = useCallStateHooks();
  const { microphone, hasBrowserPermission, isPromptingPermission, isTogglePending, optionsAwareIsMute } = useMicrophoneState2({ optimisticUpdates });
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react2.useState)(false);
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await microphone.toggle();
    }
  });
  return (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: (0, import_jsx_runtime2.jsx)(PermissionNotification, { permission: OwnCapability.SEND_AUDIO, isAwaitingApproval: isAwaitingPermission, messageApproved: t2("You can now speak."), messageAwaitingApproval: t2("Awaiting for an approval to speak."), messageRevoked: t2("You can no longer speak."), children: (0, import_jsx_runtime2.jsx)(WithTooltip, { title: !hasPermission ? t2("You have no permission to share your audio") : !hasBrowserPermission ? t2("Check your browser mic permissions") : caption ?? t2("Mic"), tooltipDisabled, children: (0, import_jsx_runtime2.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, variant: "secondary", disabled: !hasBrowserPermission || !hasPermission || // disable button while the toggle action is pending when not using optimistic updates
  !optimisticUpdates && isTogglePending, "data-testid": optionsAwareIsMute ? "audio-unmute-button" : "audio-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: optionsAwareIsMute ? "mic-off" : "mic" }), (!hasBrowserPermission || !hasPermission) && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__no-media-permission", children: "!" }), isPromptingPermission && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) }) }) });
};
var ToggleVideoPreviewButton = (props) => {
  const { caption, Menu: Menu2 = DeviceSelectorVideo, menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { t: t2 } = useI18n();
  const { useCameraState: useCameraState2 } = useCallStateHooks();
  const { camera, hasBrowserPermission, isPromptingPermission, isTogglePending, optionsAwareIsMute } = useCameraState2({ optimisticUpdates });
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react2.useState)(false);
  const handleClick = createCallControlHandler(props, () => camera.toggle());
  return (0, import_jsx_runtime2.jsx)(WithTooltip, { title: !hasBrowserPermission ? t2("Check your browser video permissions") : caption ?? t2("Video"), tooltipDisabled, children: (0, import_jsx_runtime2.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, className: clsx_default(!hasBrowserPermission && "str-video__device-unavailable"), variant: "secondary", "data-testid": optionsAwareIsMute ? "preview-video-unmute-button" : "preview-video-mute-button", onClick: handleClick, disabled: !hasBrowserPermission || !optimisticUpdates && isTogglePending, Menu: Menu2, menuPlacement, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: !optionsAwareIsMute ? "camera" : "camera-off" }), !hasBrowserPermission && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__no-media-permission", title: t2("Check your browser video permissions"), children: "!" }), isPromptingPermission && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) });
};
var ToggleVideoPublishingButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption, Menu: Menu2 = (0, import_jsx_runtime2.jsx)(DeviceSelectorVideo, { visualType: "list" }), menuPlacement = "top", onMenuToggle, optimisticUpdates, ...restCompositeButtonProps } = props;
  const { hasPermission, requestPermission, isAwaitingPermission } = useRequestPermission(OwnCapability.SEND_VIDEO);
  const { useCameraState: useCameraState2, useCallSettings: useCallSettings2 } = useCallStateHooks();
  const { camera, optionsAwareIsMute, hasBrowserPermission, isPromptingPermission, isTogglePending } = useCameraState2({ optimisticUpdates });
  const callSettings = useCallSettings2();
  const isPublishingVideoAllowed = callSettings?.video.enabled;
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react2.useState)(false);
  const handleClick = createCallControlHandler(props, async () => {
    if (!hasPermission) {
      await requestPermission();
    } else {
      await camera.toggle();
    }
  });
  return (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: (0, import_jsx_runtime2.jsx)(PermissionNotification, { permission: OwnCapability.SEND_VIDEO, isAwaitingApproval: isAwaitingPermission, messageApproved: t2("You can now share your video."), messageAwaitingApproval: t2("Awaiting for an approval to share your video."), messageRevoked: t2("You can no longer share your video."), children: (0, import_jsx_runtime2.jsx)(WithTooltip, { title: !hasPermission ? t2("You have no permission to share your video") : !hasBrowserPermission ? t2("Check your browser video permissions") : !isPublishingVideoAllowed ? t2("Video publishing is disabled by the system") : caption || t2("Video"), tooltipDisabled, children: (0, import_jsx_runtime2.jsxs)(CompositeButton, { active: optionsAwareIsMute, caption, variant: "secondary", disabled: !hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed || !optimisticUpdates && isTogglePending, "data-testid": optionsAwareIsMute ? "video-unmute-button" : "video-mute-button", onClick: handleClick, Menu: Menu2, menuPlacement, menuOffset: 16, ...restCompositeButtonProps, onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: optionsAwareIsMute ? "camera-off" : "camera" }), (!hasBrowserPermission || !hasPermission || !isPublishingVideoAllowed) && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__no-media-permission", children: "!" }), isPromptingPermission && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__pending-permission", title: t2("Waiting for permission"), children: "?" })] }) }) }) });
};
var EndCallMenu = (props) => {
  const { onLeave, onEnd } = props;
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__end-call__confirmation", children: [(0, import_jsx_runtime2.jsxs)("button", { className: "str-video__button str-video__end-call__leave", type: "button", "data-testid": "leave-call-button", onClick: onLeave, children: [(0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__button__icon str-video__end-call__leave-icon", icon: "logout" }), t2("Leave call")] }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.END_CALL], children: (0, import_jsx_runtime2.jsxs)("button", { className: "str-video__button str-video__end-call__end", type: "button", "data-testid": "end-call-for-all-button", onClick: onEnd, children: [(0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__button__icon str-video__end-call__end-icon", icon: "call-end" }), t2("End call for all")] }) })] });
};
var CancelCallToggleMenuButton = (0, import_react2.forwardRef)(function CancelCallToggleMenuButton2({ menuShown }, ref) {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)(WithTooltip, { title: t2("Leave call"), tooltipDisabled: menuShown, children: (0, import_jsx_runtime2.jsx)(IconButton, { icon: menuShown ? "close" : "call-end", variant: menuShown ? "active" : "danger", "data-testid": "leave-call-button", ref }) });
});
var CancelCallConfirmButton = ({ onClick, onLeave }) => {
  const call = useCall();
  const handleLeave = (0, import_react2.useCallback)(async (e2) => {
    if (onClick) {
      onClick(e2);
    } else if (call) {
      await call.leave();
      onLeave?.();
    }
  }, [onClick, onLeave, call]);
  const handleEndCall = (0, import_react2.useCallback)(async (e2) => {
    if (onClick) {
      onClick(e2);
    } else if (call) {
      await call.endCall();
      onLeave?.();
    }
  }, [onClick, onLeave, call]);
  return (0, import_jsx_runtime2.jsx)(MenuToggle, { placement: "top-start", ToggleButton: CancelCallToggleMenuButton, children: (0, import_jsx_runtime2.jsx)(EndCallMenu, { onEnd: handleEndCall, onLeave: handleLeave }) });
};
var CancelCallButton = ({ disabled, caption, onClick, onLeave }) => {
  const call = useCall();
  const { t: t2 } = useI18n();
  const handleClick = (0, import_react2.useCallback)(async (e2) => {
    if (onClick) {
      onClick(e2);
    } else if (call) {
      await call.leave();
      onLeave?.();
    }
  }, [onClick, onLeave, call]);
  return (0, import_jsx_runtime2.jsx)(IconButton, { disabled, icon: "call-end", variant: "danger", title: caption ?? t2("Leave call"), "data-testid": "cancel-call-button", onClick: handleClick });
};
var CallControls = ({ onLeave }) => (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-controls", children: [(0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_AUDIO], children: (0, import_jsx_runtime2.jsx)(SpeakingWhileMutedNotification, { children: (0, import_jsx_runtime2.jsx)(ToggleAudioPublishingButton, {}) }) }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.SEND_VIDEO], children: (0, import_jsx_runtime2.jsx)(ToggleVideoPublishingButton, {}) }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.CREATE_REACTION], children: (0, import_jsx_runtime2.jsx)(ReactionsButton, {}) }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.SCREENSHARE], children: (0, import_jsx_runtime2.jsx)(ScreenShareButton, {}) }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [
  OwnCapability.START_RECORD_CALL,
  OwnCapability.STOP_RECORD_CALL
], children: (0, import_jsx_runtime2.jsx)(RecordCallButton, {}) }), (0, import_jsx_runtime2.jsx)(CancelCallButton, { onLeave })] });
var CallStatsLatencyChart = (0, import_react2.lazy)(() => import("./latency-chart-Bj5OSYzg.es-YBZPFPRN.js"));
var Status;
(function(Status2) {
  Status2["GOOD"] = "Good";
  Status2["OK"] = "Ok";
  Status2["BAD"] = "Bad";
})(Status || (Status = {}));
var CallStats = (props) => {
  const { latencyLowBound = 75, latencyHighBound = 400, showCodecInfo = false, LatencyChartSuspenseFallback = null } = props;
  const [latencyBuffer, setLatencyBuffer] = (0, import_react2.useState)(() => {
    const now = Date.now();
    return Array.from({ length: 20 }, (_2, i2) => ({ x: now + i2, y: 0 }));
  });
  const { t: t2 } = useI18n();
  const [publishBitrate, setPublishBitrate] = (0, import_react2.useState)("-");
  const [subscribeBitrate, setSubscribeBitrate] = (0, import_react2.useState)("-");
  const previousStats = (0, import_react2.useRef)(void 0);
  const { useCallStatsReport: useCallStatsReport2 } = useCallStateHooks();
  const callStatsReport = useCallStatsReport2();
  (0, import_react2.useEffect)(() => {
    if (!callStatsReport)
      return;
    if (!previousStats.current) {
      previousStats.current = callStatsReport;
      return;
    }
    const previousCallStatsReport = previousStats.current;
    setPublishBitrate(() => {
      return calculatePublishBitrate(previousCallStatsReport, callStatsReport);
    });
    setSubscribeBitrate(() => {
      return calculateSubscribeBitrate(previousCallStatsReport, callStatsReport);
    });
    setLatencyBuffer((latencyBuf) => {
      const newLatencyBuffer = latencyBuf.slice(-19);
      newLatencyBuffer.push({
        x: callStatsReport.timestamp,
        y: callStatsReport.publisherStats.averageRoundTripTimeInMs
      });
      return newLatencyBuffer;
    });
    previousStats.current = callStatsReport;
  }, [callStatsReport]);
  const latencyComparison = {
    lowBound: latencyLowBound,
    highBound: latencyHighBound,
    value: callStatsReport?.publisherStats.averageRoundTripTimeInMs || 0
  };
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-stats", children: callStatsReport && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-stats__header", children: [(0, import_jsx_runtime2.jsxs)("h3", { className: "str-video__call-stats__heading", children: [(0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__call-stats__icon", icon: "call-latency" }), t2("Call Latency")] }), (0, import_jsx_runtime2.jsx)("p", { className: "str-video__call-stats__description", children: t2("Very high latency values may reduce call quality, cause lag, and make the call less enjoyable.") })] }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-stats__latencychart", children: (0, import_jsx_runtime2.jsx)(import_react2.Suspense, { fallback: LatencyChartSuspenseFallback, children: (0, import_jsx_runtime2.jsx)(CallStatsLatencyChart, { values: latencyBuffer }) }) }), (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-stats__header", children: [(0, import_jsx_runtime2.jsxs)("h3", { className: "str-video__call-stats__heading", children: [(0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__call-stats__icon", icon: "network-quality" }), t2("Call performance")] }), (0, import_jsx_runtime2.jsx)("p", { className: "str-video__call-stats__description", children: t2("Review the key data points below to assess call performance") })] }), (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-stats__card-container", children: [(0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Region"), value: callStatsReport.datacenter }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Latency"), value: `${callStatsReport.publisherStats.averageRoundTripTimeInMs} ms.`, comparison: latencyComparison }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Receive jitter"), value: `${callStatsReport.subscriberStats.averageJitterInMs} ms.`, comparison: {
    ...latencyComparison,
    value: callStatsReport.subscriberStats.averageJitterInMs
  } }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Publish jitter"), value: `${callStatsReport.publisherStats.averageJitterInMs} ms.`, comparison: {
    ...latencyComparison,
    value: callStatsReport.publisherStats.averageJitterInMs
  } }), (0, import_jsx_runtime2.jsx)(StatCard, { label: `${t2("Publish resolution")}${showCodecInfo ? formatCodec(callStatsReport) : ""}`, value: toFrameSize(callStatsReport.publisherStats) }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Publish quality drop reason"), value: callStatsReport.publisherStats.qualityLimitationReasons }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Receiving resolution"), value: toFrameSize(callStatsReport.subscriberStats) }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Receive quality drop reason"), value: callStatsReport.subscriberStats.qualityLimitationReasons }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Publish bitrate"), value: publishBitrate }), (0, import_jsx_runtime2.jsx)(StatCard, { label: t2("Receiving bitrate"), value: subscribeBitrate })] })] }) });
};
var StatCardExplanation = (props) => {
  const { description } = props;
  const [isOpen, setIsOpen] = (0, import_react2.useState)(false);
  const { refs, floatingStyles, context: context2 } = useFloating({
    open: isOpen,
    onOpenChange: setIsOpen
  });
  const hover = useHover(context2);
  const { getReferenceProps, getFloatingProps } = useInteractions([hover]);
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-explanation", ref: refs.setReference, ...getReferenceProps(), children: (0, import_jsx_runtime2.jsx)(Icon, { className: "str-video__call-explanation__icon", icon: "info" }) }), isOpen && (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-explanation__description", ref: refs.setFloating, style: floatingStyles, ...getFloatingProps(), children: description })] });
};
var StatsTag = (props) => {
  const { children, status } = props;
  return (0, import_jsx_runtime2.jsx)("div", { className: clsx_default("str-video__call-stats__tag", {
    "str-video__call-stats__tag--good": status === Status.GOOD,
    "str-video__call-stats__tag--ok": status === Status.OK,
    "str-video__call-stats__tag--bad": status === Status.BAD
  }), children: (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-stats__tag__text", children }) });
};
var StatCard = (props) => {
  const { label, value, description, comparison } = props;
  const { t: t2 } = useI18n();
  const status = comparison ? toStatus(comparison) : void 0;
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-stats__card", children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-stats__card-content", children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-stats__card-label", children: [label, description && (0, import_jsx_runtime2.jsx)(StatCardExplanation, { description })] }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-stats__card-value", children: value })] }), status && (0, import_jsx_runtime2.jsx)(StatsTag, { status, children: t2(status) })] });
};
var toStatus = (config2) => {
  const { value, lowBound, highBound } = config2;
  if (value <= lowBound)
    return Status.GOOD;
  if (value >= lowBound && value <= highBound)
    return Status.OK;
  if (value >= highBound)
    return Status.BAD;
  return Status.GOOD;
};
var toFrameSize = (stats) => {
  const { highestFrameWidth: w2, highestFrameHeight: h2, highestFramesPerSecond: fps } = stats;
  let size2 = `-`;
  if (w2 && h2) {
    size2 = `${w2}x${h2}`;
    if (fps) {
      size2 += `@${fps}fps.`;
    }
  }
  return size2;
};
var formatCodec = (callStatsReport) => {
  const { codecPerTrackType } = callStatsReport.publisherStats;
  if (!codecPerTrackType || !codecPerTrackType[models.TrackType.VIDEO]) {
    return "";
  }
  const [, name2] = codecPerTrackType[models.TrackType.VIDEO].split("/");
  return name2 ? ` (${name2})` : "";
};
var calculatePublishBitrate = (previousCallStatsReport, callStatsReport) => {
  const { publisherStats: { totalBytesSent: previousTotalBytesSent, timestamp: previousTimestamp } } = previousCallStatsReport;
  const { publisherStats: { totalBytesSent, timestamp: timestamp2 } } = callStatsReport;
  const bytesSent = totalBytesSent - previousTotalBytesSent;
  const timeElapsed = timestamp2 - previousTimestamp;
  return `${(bytesSent * 8 / timeElapsed).toFixed(2)} kbps`;
};
var calculateSubscribeBitrate = (previousCallStatsReport, callStatsReport) => {
  const { subscriberStats: { totalBytesReceived: previousTotalBytesReceived, timestamp: previousTimestamp } } = previousCallStatsReport;
  const { subscriberStats: { totalBytesReceived, timestamp: timestamp2 } } = callStatsReport;
  const bytesReceived = totalBytesReceived - previousTotalBytesReceived;
  const timeElapsed = timestamp2 - previousTimestamp;
  return `${(bytesReceived * 8 / timeElapsed).toFixed(2)} kbps`;
};
var CallStatsButton = () => (0, import_jsx_runtime2.jsx)(MenuToggle, { placement: "top-end", ToggleButton: ToggleMenuButton, children: (0, import_jsx_runtime2.jsx)(CallStats, {}) });
var ToggleMenuButton = (0, import_react2.forwardRef)(function ToggleMenuButton2(props, ref) {
  const { t: t2 } = useI18n();
  const { caption, menuShown } = props;
  return (0, import_jsx_runtime2.jsx)(CompositeButton, { ref, active: menuShown, caption, title: caption || t2("Statistics"), "data-testid": "stats-button", children: (0, import_jsx_runtime2.jsx)(Icon, { icon: "stats" }) });
});
var ToggleAudioOutputButton = (props) => {
  const { t: t2 } = useI18n();
  const { caption, Menu: Menu2 = DeviceSelectorAudioOutput, menuPlacement = "top", onMenuToggle } = props;
  const [tooltipDisabled, setTooltipDisabled] = (0, import_react2.useState)(false);
  return (0, import_jsx_runtime2.jsx)(WithTooltip, { title: caption || t2("Speakers"), tooltipDisabled, children: (0, import_jsx_runtime2.jsx)(CompositeButton, { Menu: Menu2, menuPlacement, caption, "data-testid": "audio-output-button", onMenuToggle: (shown) => {
    setTooltipDisabled(shown);
    onMenuToggle?.(shown);
  }, children: (0, import_jsx_runtime2.jsx)(Icon, { icon: "speaker" }) }) });
};
var BlockedUserListing = ({ data }) => {
  if (!data.length)
    return null;
  return (0, import_jsx_runtime2.jsx)(import_jsx_runtime2.Fragment, { children: (0, import_jsx_runtime2.jsx)("div", { className: "str-video__participant-listing", children: data.map((userId) => (0, import_jsx_runtime2.jsx)(BlockedUserListingItem, { userId }, userId)) }) });
};
var BlockedUserListingItem = ({ userId }) => {
  const call = useCall();
  const unblockUserClickHandler = () => {
    if (userId)
      call?.unblockUser(userId);
  };
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-listing-item", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__participant-listing-item__display-name", children: userId }), (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.BLOCK_USERS], children: (0, import_jsx_runtime2.jsx)(TextButton, { onClick: unblockUserClickHandler, children: "Unblock" }) })] });
};
var CallParticipantListHeader = ({ onClose }) => {
  const { useParticipants: useParticipants2, useAnonymousParticipantCount: useAnonymousParticipantCount2 } = useCallStateHooks();
  const participants = useParticipants2();
  const anonymousParticipantCount = useAnonymousParticipantCount2();
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-list-header", children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-list-header__title", children: [t2("Participants"), " ", (0, import_jsx_runtime2.jsxs)("span", { className: "str-video__participant-list-header__title-count", children: ["[", participants.length, "]"] }), anonymousParticipantCount > 0 && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__participant-list-header__title-anonymous", children: t2("Anonymous", { count: anonymousParticipantCount }) })] }), (0, import_jsx_runtime2.jsx)(IconButton, { onClick: onClose, className: "str-video__participant-list-header__close-button", icon: "close" })] });
};
var CallParticipantListingItem = ({ participant, DisplayName = DefaultDisplayName }) => {
  const isAudioOn = hasAudio(participant);
  const isVideoOn = hasVideo(participant);
  const isPinnedOn = isPinned(participant);
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-listing-item", children: [(0, import_jsx_runtime2.jsx)(Avatar, { name: participant.name, imageSrc: participant.image }), (0, import_jsx_runtime2.jsx)(DisplayName, { participant }), (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-listing-item__media-indicator-group", children: [(0, import_jsx_runtime2.jsx)(MediaIndicator, { title: isAudioOn ? t2("Microphone on") : t2("Microphone off"), className: clsx_default("str-video__participant-listing-item__icon", `str-video__participant-listing-item__icon-${isAudioOn ? "mic" : "mic-off"}`) }), (0, import_jsx_runtime2.jsx)(MediaIndicator, { title: isVideoOn ? t2("Camera on") : t2("Camera off"), className: clsx_default("str-video__participant-listing-item__icon", `str-video__participant-listing-item__icon-${isVideoOn ? "camera" : "camera-off"}`) }), isPinnedOn && (0, import_jsx_runtime2.jsx)(MediaIndicator, { title: t2("Pinned"), className: clsx_default("str-video__participant-listing-item__icon", "str-video__participant-listing-item__icon-pinned") }), (0, import_jsx_runtime2.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$2, children: (0, import_jsx_runtime2.jsx)(ParticipantViewContext.Provider, { value: { participant, trackType: "none" }, children: (0, import_jsx_runtime2.jsx)(ParticipantActionsContextMenu, {}) }) })] })] });
};
var MediaIndicator = (props) => (0, import_jsx_runtime2.jsx)(WithTooltip, { ...props });
var DefaultDisplayName = ({ participant }) => {
  const connectedUser = useConnectedUser();
  const { t: t2 } = useI18n();
  const meFlag = participant.userId === connectedUser?.id ? t2("Me") : "";
  const nameOrId = participant.name || participant.userId || t2("Unknown");
  let displayName;
  if (!participant.name) {
    displayName = meFlag || nameOrId || t2("Unknown");
  } else if (meFlag) {
    displayName = `${nameOrId} (${meFlag})`;
  } else {
    displayName = nameOrId;
  }
  return (0, import_jsx_runtime2.jsx)(WithTooltip, { className: "str-video__participant-listing-item__display-name", title: displayName, children: displayName });
};
var ToggleButton$2 = (0, import_react2.forwardRef)(function ToggleButton(props, ref) {
  return (0, import_jsx_runtime2.jsx)(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref });
});
var CallParticipantListing = ({ data }) => (0, import_jsx_runtime2.jsx)("div", { className: "str-video__participant-listing", children: data.map((participant) => (0, import_jsx_runtime2.jsx)(CallParticipantListingItem, { participant }, participant.sessionId)) });
var EmptyParticipantSearchList = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__participant-list--empty", children: t2("No participants found") });
};
var SearchInput = ({ exitSearch, isActive, ...rest }) => {
  const [inputElement, setInputElement] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (!inputElement)
      return;
    const handleKeyDown = (e2) => {
      if (e2.key.toLowerCase() === "escape")
        exitSearch();
    };
    inputElement.addEventListener("keydown", handleKeyDown);
    return () => {
      inputElement.removeEventListener("keydown", handleKeyDown);
    };
  }, [exitSearch, inputElement]);
  return (0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__search-input__container", {
    "str-video__search-input__container--active": isActive
  }), children: [(0, import_jsx_runtime2.jsx)("input", { placeholder: "Search", ...rest, ref: setInputElement }), isActive ? (0, import_jsx_runtime2.jsx)("button", { className: "str-video__search-input__clear-btn", onClick: exitSearch, children: (0, import_jsx_runtime2.jsx)("span", { className: "str-video__search-input__icon--active" }) }) : (0, import_jsx_runtime2.jsx)("span", { className: "str-video__search-input__icon" })] });
};
function SearchResults({ EmptySearchResultComponent, LoadingIndicator: LoadingIndicator$1 = LoadingIndicator, searchQueryInProgress, searchResults, SearchResultList }) {
  if (searchQueryInProgress) {
    return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__search-results--loading", children: (0, import_jsx_runtime2.jsx)(LoadingIndicator$1, {}) });
  }
  if (!searchResults.length) {
    return (0, import_jsx_runtime2.jsx)(EmptySearchResultComponent, {});
  }
  return (0, import_jsx_runtime2.jsx)(SearchResultList, { data: searchResults });
}
var useSearch = ({ debounceInterval = 200, searchFn, searchQuery = "" }) => {
  const [searchResults, setSearchResults] = (0, import_react2.useState)([]);
  const [searchQueryInProgress, setSearchQueryInProgress] = (0, import_react2.useState)(false);
  const searchFnRef = (0, import_react2.useRef)(searchFn);
  searchFnRef.current = searchFn;
  (0, import_react2.useEffect)(() => {
    if (!searchQuery.length) {
      setSearchQueryInProgress(false);
      setSearchResults([]);
      return;
    }
    setSearchQueryInProgress(true);
    const timeout2 = setTimeout(async () => {
      try {
        const results = await searchFnRef.current(searchQuery);
        setSearchResults(results);
      } catch (error) {
        console.error(error);
      } finally {
        setSearchQueryInProgress(false);
      }
    }, debounceInterval);
    return () => {
      clearTimeout(timeout2);
    };
  }, [debounceInterval, searchQuery]);
  return {
    searchQueryInProgress,
    searchResults
  };
};
var UserListTypes = {
  active: "Active users",
  blocked: "Blocked users"
};
var CallParticipantsList = ({ onClose, activeUsersSearchFn, blockedUsersSearchFn, debounceSearchInterval }) => {
  const [searchQuery, setSearchQuery] = (0, import_react2.useState)("");
  const [userListType, setUserListType] = (0, import_react2.useState)("active");
  const exitSearch = (0, import_react2.useCallback)(() => setSearchQuery(""), []);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-list", children: [(0, import_jsx_runtime2.jsx)(CallParticipantListHeader, { onClose }), (0, import_jsx_runtime2.jsx)(SearchInput, { value: searchQuery, onChange: ({ currentTarget }) => setSearchQuery(currentTarget.value), exitSearch, isActive: !!searchQuery }), (0, import_jsx_runtime2.jsx)(CallParticipantListContentHeader, { userListType, setUserListType }), (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-list__content", children: [userListType === "active" && (0, import_jsx_runtime2.jsx)(ActiveUsersSearchResults, { searchQuery, activeUsersSearchFn, debounceSearchInterval }), userListType === "blocked" && (0, import_jsx_runtime2.jsx)(BlockedUsersSearchResults, { searchQuery, blockedUsersSearchFn, debounceSearchInterval })] })] });
};
var CallParticipantListContentHeader = ({ userListType, setUserListType }) => {
  const call = useCall();
  const { t: t2 } = useI18n();
  const muteAll = (0, import_react2.useCallback)(() => {
    call?.muteAllUsers("audio");
  }, [call]);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__participant-list__content-header", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__participant-list__content-header-title", children: userListType === "active" && (0, import_jsx_runtime2.jsx)(Restricted, { requiredGrants: [OwnCapability.MUTE_USERS], hasPermissionsOnly: true, children: (0, import_jsx_runtime2.jsx)(TextButton, { onClick: muteAll, children: t2("Mute all") }) }) }), (0, import_jsx_runtime2.jsx)(MenuToggle, { placement: "bottom-end", ToggleButton: ToggleButton$1, children: (0, import_jsx_runtime2.jsx)(GenericMenu, { children: Object.keys(UserListTypes).map((lt2) => (0, import_jsx_runtime2.jsx)(GenericMenuButtonItem, { "aria-selected": lt2 === userListType, onClick: () => setUserListType(lt2), children: UserListTypes[lt2] }, lt2)) }) })] });
};
var ActiveUsersSearchResults = ({ searchQuery, activeUsersSearchFn: activeUsersSearchFnFromProps, debounceSearchInterval }) => {
  const { useParticipants: useParticipants2 } = useCallStateHooks();
  const participants = useParticipants2({ sortBy: name });
  const activeUsersSearchFn = (0, import_react2.useCallback)(async (queryString) => {
    const queryRegExp = new RegExp(queryString, "i");
    return participants.filter((p2) => p2.name.match(queryRegExp));
  }, [participants]);
  const { searchQueryInProgress, searchResults } = useSearch({
    searchFn: activeUsersSearchFnFromProps ?? activeUsersSearchFn,
    debounceInterval: debounceSearchInterval,
    searchQuery
  });
  return (0, import_jsx_runtime2.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator, searchQueryInProgress, searchResults: searchQuery ? searchResults : participants, SearchResultList: CallParticipantListing });
};
var BlockedUsersSearchResults = ({ blockedUsersSearchFn: blockedUsersSearchFnFromProps, debounceSearchInterval, searchQuery }) => {
  const { useCallBlockedUserIds: useCallBlockedUserIds2 } = useCallStateHooks();
  const blockedUsers = useCallBlockedUserIds2();
  const blockedUsersSearchFn = (0, import_react2.useCallback)(async (queryString) => {
    const queryRegExp = new RegExp(queryString, "i");
    return blockedUsers.filter((userId) => userId.match(queryRegExp));
  }, [blockedUsers]);
  const { searchQueryInProgress, searchResults } = useSearch({
    searchFn: blockedUsersSearchFnFromProps ?? blockedUsersSearchFn,
    debounceInterval: debounceSearchInterval,
    searchQuery
  });
  return (0, import_jsx_runtime2.jsx)(SearchResults, { EmptySearchResultComponent: EmptyParticipantSearchList, LoadingIndicator, searchQueryInProgress, searchResults: searchQuery ? searchResults : blockedUsers, SearchResultList: BlockedUserListing });
};
var ToggleButton$1 = (0, import_react2.forwardRef)(function ToggleButton2(props, ref) {
  return (0, import_jsx_runtime2.jsx)(IconButton, { enabled: props.menuShown, icon: "filter", ref });
});
var CallPreview = (props) => {
  const { className, style } = props;
  const call = useCall();
  const { useCallThumbnail: useCallThumbnail2 } = useCallStateHooks();
  const thumbnail = useCallThumbnail2();
  const [imageRef, setImageRef] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (!imageRef || !call)
      return;
    const cleanup = call.bindCallThumbnailElement(imageRef);
    return () => cleanup();
  }, [imageRef, call]);
  if (!thumbnail)
    return null;
  return (0, import_jsx_runtime2.jsx)("img", { className: clsx_default("str-video__call-preview", className), style, alt: "Call Preview Thumbnail", ref: setImageRef });
};
var CallRecordingListHeader = ({ callRecordings, onRefresh }) => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-recording-list__header", children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-recording-list__title", children: [(0, import_jsx_runtime2.jsx)("span", { children: t2("Call Recordings") }), callRecordings.length ? (0, import_jsx_runtime2.jsxs)("span", { children: ["(", callRecordings.length, ")"] }) : null] }), onRefresh && (0, import_jsx_runtime2.jsx)(IconButton, { icon: "refresh", title: t2("Refresh"), onClick: onRefresh })] });
};
var dateFormat = (date) => {
  const format = new Date(date);
  return format.toTimeString().split(" ")[0];
};
var CallRecordingListItem = ({ recording }) => {
  return (0, import_jsx_runtime2.jsxs)("li", { className: "str-video__call-recording-list__item", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__filename", children: recording.filename }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.start_time) }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__time", children: dateFormat(recording.end_time) }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__table-cell str-video__call-recording-list__download", children: (0, import_jsx_runtime2.jsx)("a", { className: clsx_default("str-video__call-recording-list-item__action-button", "str-video__call-recording-list-item__action-button--download"), role: "button", href: recording.url, download: recording.filename, title: "Download the recording", children: (0, import_jsx_runtime2.jsx)(Icon, { icon: "download" }) }) })] });
};
var EmptyCallRecordingListing = () => {
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-recording-list__listing str-video__call-recording-list__listing--empty", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__listing--icon-empty" }), (0, import_jsx_runtime2.jsx)("p", { className: "str-video__call-recording-list__listing--text-empty", children: "No recordings available" })] });
};
var LoadingCallRecordingListing = ({ callRecordings }) => {
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [callRecordings.map((recording) => (0, import_jsx_runtime2.jsx)(CallRecordingListItem, { recording }, recording.filename)), (0, import_jsx_runtime2.jsx)(LoadingIndicator, { text: "Recording getting ready" })] });
};
var CallRecordingList = ({ callRecordings, CallRecordingListHeader: CallRecordingListHeader$1 = CallRecordingListHeader, CallRecordingListItem: CallRecordingListItem$1 = CallRecordingListItem, EmptyCallRecordingList = EmptyCallRecordingListing, loading, LoadingCallRecordingList = LoadingCallRecordingListing, onRefresh }) => {
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-recording-list", children: [(0, import_jsx_runtime2.jsx)(CallRecordingListHeader$1, { callRecordings, onRefresh }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__listing", children: loading ? (0, import_jsx_runtime2.jsx)(LoadingCallRecordingList, { callRecordings }) : callRecordings.length ? (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)("ul", { className: "str-video__call-recording-list__list", children: (0, import_jsx_runtime2.jsxs)("li", { className: "str-video__call-recording-list__item", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__filename", children: "Name" }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__time", children: "Start time" }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__time", children: "End time" }), (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-recording-list__download" })] }) }), (0, import_jsx_runtime2.jsx)("ul", { className: "str-video__call-recording-list__list", children: callRecordings.map((recording) => (0, import_jsx_runtime2.jsx)(CallRecordingListItem$1, { recording }, recording.filename)) })] }) : (0, import_jsx_runtime2.jsx)(EmptyCallRecordingList, {}) })] });
};
var NoiseCancellationContext = (0, import_react2.createContext)(null);
var useNoiseCancellation = () => {
  const context2 = (0, import_react2.useContext)(NoiseCancellationContext);
  if (!context2) {
    throw new Error("useNoiseCancellation must be used within a NoiseCancellationProvider");
  }
  return context2;
};
var NoiseCancellationProvider = (props) => {
  const { children, noiseCancellation } = props;
  const call = useCall();
  const { useCallSettings: useCallSettings2, useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const settings = useCallSettings2();
  const noiseCancellationAllowed = !!(settings && settings.audio.noise_cancellation && settings.audio.noise_cancellation.mode !== NoiseCancellationSettingsModeEnum.DISABLED);
  const hasCapability = useHasPermissions2(OwnCapability.ENABLE_NOISE_CANCELLATION);
  const [isSupportedByBrowser, setIsSupportedByBrowser] = (0, import_react2.useState)();
  (0, import_react2.useEffect)(() => {
    const result = noiseCancellation.isSupported();
    if (typeof result === "boolean") {
      setIsSupportedByBrowser(result);
    } else {
      result.then((s2) => setIsSupportedByBrowser(s2)).catch((err) => console.error(`Can't determine if noise cancellation is supported`, err));
    }
  }, [noiseCancellation]);
  const isSupported = isSupportedByBrowser && hasCapability && noiseCancellationAllowed;
  const [isEnabled, setIsEnabled] = (0, import_react2.useState)(false);
  const deinit = (0, import_react2.useRef)(void 0);
  (0, import_react2.useEffect)(() => {
    if (!call || !isSupported)
      return;
    noiseCancellation.isEnabled().then((e2) => setIsEnabled(e2));
    const unsubscribe = noiseCancellation.on("change", (v2) => setIsEnabled(v2));
    const init = (deinit.current || Promise.resolve()).then(() => noiseCancellation.init({ tracer: call.tracer })).then(() => call.microphone.enableNoiseCancellation(noiseCancellation)).catch((e2) => console.error(`Can't initialize noise cancellation`, e2));
    return () => {
      deinit.current = init.then(() => call.microphone.disableNoiseCancellation()).then(() => noiseCancellation.dispose()).then(() => unsubscribe());
    };
  }, [call, isSupported, noiseCancellation]);
  const contextValue = (0, import_react2.useMemo)(() => ({
    isSupported,
    isEnabled,
    setSuppressionLevel: (level) => {
      if (!noiseCancellation)
        return;
      noiseCancellation.setSuppressionLevel(level);
    },
    setEnabled: (enabledOrSetter) => {
      if (!noiseCancellation)
        return;
      const enable = typeof enabledOrSetter === "function" ? enabledOrSetter(isEnabled) : enabledOrSetter;
      if (enable) {
        noiseCancellation.enable().catch((err) => {
          console.error("Failed to enable noise cancellation", err);
        });
      } else {
        noiseCancellation.disable().catch((err) => {
          console.error("Failed to disable noise cancellation", err);
        });
      }
    }
  }), [isEnabled, isSupported, noiseCancellation]);
  return (0, import_jsx_runtime2.jsx)(NoiseCancellationContext.Provider, { value: contextValue, children });
};
var RingingCallControls = () => {
  const call = useCall();
  const { useCallCallingState: useCallCallingState2 } = useCallStateHooks();
  const callCallingState = useCallCallingState2();
  if (!call)
    return null;
  const buttonsDisabled = callCallingState !== CallingState.RINGING;
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__pending-call-controls", children: call.isCreatedByMe ? (0, import_jsx_runtime2.jsx)(CancelCallButton, { disabled: buttonsDisabled }) : (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(AcceptCallButton, { disabled: buttonsDisabled }), (0, import_jsx_runtime2.jsx)(CancelCallButton, { onClick: () => {
    const reason = call.isCreatedByMe ? "cancel" : "decline";
    call.leave({ reject: true, reason });
  }, disabled: buttonsDisabled })] }) });
};
var CALLING_STATE_TO_LABEL = {
  [CallingState.JOINING]: "Joining",
  [CallingState.RINGING]: "Ringing",
  [CallingState.MIGRATING]: "Migrating",
  [CallingState.RECONNECTING]: "Re-connecting",
  [CallingState.RECONNECTING_FAILED]: "Failed",
  [CallingState.OFFLINE]: "No internet connection",
  [CallingState.IDLE]: "",
  [CallingState.UNKNOWN]: "",
  [CallingState.JOINED]: "Joined",
  [CallingState.LEFT]: "Left call"
};
var RingingCall = (props) => {
  const { includeSelf = false, totalMembersToShow = 3 } = props;
  const call = useCall();
  const { t: t2 } = useI18n();
  const { useCallCallingState: useCallCallingState2, useCallMembers: useCallMembers2 } = useCallStateHooks();
  const callingState = useCallCallingState2();
  const members = useCallMembers2();
  const connectedUser = useConnectedUser();
  if (!call)
    return null;
  const membersToShow = (members || []).slice(0, totalMembersToShow).map(({ user }) => user).filter((user) => user.id !== connectedUser?.id || includeSelf);
  if (includeSelf && !membersToShow.find((user) => user.id === connectedUser?.id)) {
    const self2 = members.find(({ user }) => user.id === connectedUser?.id);
    if (self2) {
      membersToShow.splice(0, 1, self2.user);
    }
  }
  const callingStateLabel = CALLING_STATE_TO_LABEL[callingState];
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-panel str-video__call-panel--ringing", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-panel__members-list", children: membersToShow.map((user) => (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__call-panel__member-box", children: [(0, import_jsx_runtime2.jsx)(Avatar, { name: user.name, imageSrc: user.image }), user.name && (0, import_jsx_runtime2.jsx)("div", { className: "str-video__member_details", children: (0, import_jsx_runtime2.jsx)("span", { className: "str-video__member_name", children: user.name }) })] }, user.id)) }), callingStateLabel && (0, import_jsx_runtime2.jsx)("div", { className: "str-video__call-panel__calling-state-label", children: t2(callingStateLabel) }), [CallingState.RINGING, CallingState.JOINING].includes(callingState) && (0, import_jsx_runtime2.jsx)(RingingCallControls, {})] });
};
var byNameOrId = (a2, b2) => {
  if (a2.name && b2.name && a2.name < b2.name)
    return -1;
  if (a2.name && b2.name && a2.name > b2.name)
    return 1;
  if (a2.id < b2.id)
    return -1;
  if (a2.id > b2.id)
    return 1;
  return 0;
};
var PermissionRequests = () => {
  const call = useCall();
  const { useLocalParticipant: useLocalParticipant2, useHasPermissions: useHasPermissions2 } = useCallStateHooks();
  const localParticipant = useLocalParticipant2();
  const [expanded, setExpanded] = (0, import_react2.useState)(false);
  const [permissionRequests, setPermissionRequests] = (0, import_react2.useState)([]);
  const canUpdateCallPermissions = useHasPermissions2(OwnCapability.UPDATE_CALL_PERMISSIONS);
  const localUserId = localParticipant?.userId;
  (0, import_react2.useEffect)(() => {
    if (!call || !canUpdateCallPermissions)
      return;
    return call.on("call.permission_request", (event) => {
      if (event.user.id !== localUserId) {
        setPermissionRequests((requests) => [...requests, event].sort((a2, b2) => byNameOrId(a2.user, b2.user)));
      }
    });
  }, [call, canUpdateCallPermissions, localUserId]);
  const handleUpdatePermission = (request, type) => {
    return async () => {
      const { user, permissions } = request;
      switch (type) {
        case "grant":
          await call?.grantPermissions(user.id, permissions);
          break;
        case "revoke":
          await call?.revokePermissions(user.id, permissions);
          break;
      }
      setPermissionRequests((requests) => requests.filter((r2) => r2 !== request));
    };
  };
  const { refs, x: x2, y: y2, strategy } = useFloatingUIPreset({
    placement: "bottom",
    strategy: "absolute"
  });
  if (permissionRequests.length === 0)
    return null;
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__permission-requests", ref: refs.setReference, children: [(0, import_jsx_runtime2.jsxs)("div", { className: "str-video__permission-requests__notification", children: [(0, import_jsx_runtime2.jsxs)("span", { className: "str-video__permission-requests__notification__message", children: [permissionRequests.length, " pending permission requests"] }), (0, import_jsx_runtime2.jsx)(Button, { type: "button", onClick: () => {
    setExpanded((e2) => !e2);
  }, children: expanded ? "Hide requests" : "Show requests" })] }), expanded && (0, import_jsx_runtime2.jsx)(PermissionRequestList, { ref: refs.setFloating, style: {
    position: strategy,
    top: y2 ?? 0,
    left: x2 ?? 0,
    overflowY: "auto"
  }, permissionRequests, handleUpdatePermission })] });
};
var PermissionRequestList = (0, import_react2.forwardRef)(function PermissionRequestList2(props, ref) {
  const { permissionRequests, handleUpdatePermission, ...rest } = props;
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__permission-requests-list", ref, ...rest, children: permissionRequests.map((request, reqIndex) => {
    const { user, permissions } = request;
    return (0, import_jsx_runtime2.jsx)(import_react2.Fragment, { children: permissions.map((permission) => (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__permission-request", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__permission-request__message", children: messageForPermission(user.name || user.id, permission, t2) }), (0, import_jsx_runtime2.jsx)(Button, { className: "str-video__permission-request__button--allow", type: "button", onClick: handleUpdatePermission(request, "grant"), children: t2("Allow") }), (0, import_jsx_runtime2.jsx)(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, "revoke"), children: t2("Revoke") }), (0, import_jsx_runtime2.jsx)(Button, { className: "str-video__permission-request__button--reject", type: "button", onClick: handleUpdatePermission(request, "dismiss"), children: t2("Dismiss") })] }, permission)) }, `${user.id}/${reqIndex}`);
  }) });
});
var Button = (props) => {
  const { className, ...rest } = props;
  return (0, import_jsx_runtime2.jsx)("button", { className: clsx_default("str-video__permission-request__button", className), ...rest });
};
var messageForPermission = (userName, permission, t2) => {
  switch (permission) {
    case OwnCapability.SEND_AUDIO:
      return t2("{{ userName }} is requesting to speak", { userName });
    case OwnCapability.SEND_VIDEO:
      return t2("{{ userName }} is requesting to share their camera", {
        userName
      });
    case OwnCapability.SCREENSHARE:
      return t2("{{ userName }} is requesting to present their screen", {
        userName
      });
    default:
      return t2("{{ userName }} is requesting permission: {{ permission }}", {
        userName,
        permission
      });
  }
};
var StreamTheme = ({ as: Component = "div", className, children, ...props }) => {
  return (0, import_jsx_runtime2.jsx)(Component, { ...props, className: clsx_default("str-video", className), children });
};
var DefaultDisabledVideoPreview = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)("div", { className: "str_video__video-preview__disabled-video-preview", children: t2("Video is disabled") });
};
var DefaultNoCameraPreview = () => {
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)("div", { className: "str_video__video-preview__no-camera-preview", children: t2("No camera found") });
};
var VideoPreview = ({ className, mirror = true, DisabledVideoPreview = DefaultDisabledVideoPreview, NoCameraPreview = DefaultNoCameraPreview, StartingCameraPreview = LoadingIndicator }) => {
  const { useCameraState: useCameraState2 } = useCallStateHooks();
  const { devices, status, isMute, mediaStream } = useCameraState2();
  let contents;
  if (isMute && devices?.length === 0) {
    contents = (0, import_jsx_runtime2.jsx)(NoCameraPreview, {});
  } else if (status === "enabled") {
    const loading = !mediaStream;
    contents = (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [mediaStream && (0, import_jsx_runtime2.jsx)(BaseVideo, { stream: mediaStream, className: clsx_default("str-video__video-preview", {
      "str-video__video-preview--mirror": mirror,
      "str-video__video-preview--loading": loading
    }) }), loading && (0, import_jsx_runtime2.jsx)(StartingCameraPreview, {})] });
  } else {
    contents = (0, import_jsx_runtime2.jsx)(DisabledVideoPreview, {});
  }
  return (0, import_jsx_runtime2.jsx)("div", { className: clsx_default("str-video__video-preview-container", className), children: contents });
};
var ToggleButton3 = (0, import_react2.forwardRef)(function ToggleButton4(props, ref) {
  return (0, import_jsx_runtime2.jsx)(IconButton, { enabled: props.menuShown, icon: "ellipsis", ref });
});
var DefaultScreenShareOverlay = () => {
  const call = useCall();
  const { t: t2 } = useI18n();
  const stopScreenShare = () => {
    call?.screenShare.disable().catch((err) => {
      console.error("Failed to stop screen sharing:", err);
    });
  };
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__screen-share-overlay", children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "screen-share-off" }), (0, import_jsx_runtime2.jsx)("span", { className: "str-video__screen-share-overlay__title", children: t2("You are presenting your screen") }), (0, import_jsx_runtime2.jsxs)("button", { onClick: stopScreenShare, type: "button", className: "str-video__screen-share-overlay__button", children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "close" }), " ", t2("Stop Screen Sharing")] })] });
};
var DefaultParticipantViewUI = ({ indicatorsVisible = true, menuPlacement = "bottom-start", showMenuButton = true, ParticipantActionsContextMenu: ParticipantActionsContextMenu$1 = ParticipantActionsContextMenu }) => {
  const { participant, trackType } = useParticipantViewContext();
  const isScreenSharing = hasScreenShare(participant);
  if (participant.isLocalParticipant && isScreenSharing && trackType === "screenShareTrack") {
    return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)(DefaultScreenShareOverlay, {}), (0, import_jsx_runtime2.jsx)(ParticipantDetails, { indicatorsVisible })] });
  }
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [showMenuButton && (0, import_jsx_runtime2.jsx)(MenuToggle, { strategy: "fixed", placement: menuPlacement, ToggleButton: ToggleButton3, children: (0, import_jsx_runtime2.jsx)(ParticipantActionsContextMenu$1, {}) }), (0, import_jsx_runtime2.jsx)(Reaction, { participant }), (0, import_jsx_runtime2.jsx)(ParticipantDetails, { indicatorsVisible })] });
};
var ParticipantDetails = ({ indicatorsVisible = true }) => {
  const { participant, trackType } = useParticipantViewContext();
  const { isLocalParticipant, connectionQuality, pin, sessionId, name: name2, userId } = participant;
  const call = useCall();
  const { t: t2 } = useI18n();
  const connectionQualityAsString = !!connectionQuality && models.ConnectionQuality[connectionQuality].toLowerCase();
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const canUnpin = !!pin && pin.isLocalPin;
  const isTrackPaused = trackType !== "none" ? hasPausedTrack(participant, trackType) : false;
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__participant-details", children: (0, import_jsx_runtime2.jsxs)("span", { className: "str-video__participant-details__name", children: [name2 || userId, indicatorsVisible && !hasAudioTrack && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__participant-details__name--audio-muted" }), indicatorsVisible && !hasVideoTrack && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__participant-details__name--video-muted" }), indicatorsVisible && isTrackPaused && (0, import_jsx_runtime2.jsx)("span", { title: t2("Video paused due to insufficient bandwidth"), className: "str-video__participant-details__name--track-paused" }), indicatorsVisible && canUnpin && // TODO: remove this monstrosity once we have a proper design
  (0, import_jsx_runtime2.jsx)("span", { title: t2("Unpin"), onClick: () => call?.unpin(sessionId), className: "str-video__participant-details__name--pinned" }), indicatorsVisible && (0, import_jsx_runtime2.jsx)(SpeechIndicator, {})] }) }), indicatorsVisible && (0, import_jsx_runtime2.jsx)(Notification2, { isVisible: isLocalParticipant && connectionQuality === models.ConnectionQuality.POOR, message: t2("Poor connection quality"), children: connectionQualityAsString && (0, import_jsx_runtime2.jsx)("span", { className: clsx_default("str-video__participant-details__connection-quality", `str-video__participant-details__connection-quality--${connectionQualityAsString}`), title: connectionQualityAsString }) })] });
};
var SpeechIndicator = () => {
  const { participant } = useParticipantViewContext();
  const { isSpeaking, isDominantSpeaker } = participant;
  return (0, import_jsx_runtime2.jsxs)("span", { className: clsx_default("str-video__speech-indicator", isSpeaking && "str-video__speech-indicator--speaking", isDominantSpeaker && "str-video__speech-indicator--dominant"), children: [(0, import_jsx_runtime2.jsx)("span", { className: "str-video__speech-indicator__bar" }), (0, import_jsx_runtime2.jsx)("span", { className: "str-video__speech-indicator__bar" }), (0, import_jsx_runtime2.jsx)("span", { className: "str-video__speech-indicator__bar" })] });
};
var ParticipantView = (0, import_react2.forwardRef)(function ParticipantView2({ participant, trackType = "videoTrack", mirror, muteAudio, refs: { setVideoElement, setVideoPlaceholderElement } = {}, className, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI = DefaultParticipantViewUI }, ref) {
  const { isLocalParticipant, isSpeaking, isDominantSpeaker, sessionId } = participant;
  const hasAudioTrack = hasAudio(participant);
  const hasVideoTrack = hasVideo(participant);
  const hasScreenShareAudioTrack = hasScreenShareAudio(participant);
  const [trackedElement, setTrackedElement] = (0, import_react2.useState)(null);
  const [contextVideoElement, setContextVideoElement] = (0, import_react2.useState)(null);
  const [contextVideoPlaceholderElement, setContextVideoPlaceholderElement] = (0, import_react2.useState)(null);
  useTrackElementVisibility({
    sessionId,
    trackedElement,
    trackType
  });
  const { useIncomingVideoSettings: useIncomingVideoSettings2 } = useCallStateHooks();
  const { isParticipantVideoEnabled } = useIncomingVideoSettings2();
  const participantViewContextValue = (0, import_react2.useMemo)(() => ({
    participant,
    participantViewElement: trackedElement,
    videoElement: contextVideoElement,
    videoPlaceholderElement: contextVideoPlaceholderElement,
    trackType
  }), [
    contextVideoElement,
    contextVideoPlaceholderElement,
    participant,
    trackedElement,
    trackType
  ]);
  const videoRefs = (0, import_react2.useMemo)(() => ({
    setVideoElement: (element) => {
      setVideoElement?.(element);
      setContextVideoElement(element);
    },
    setVideoPlaceholderElement: (element) => {
      setVideoPlaceholderElement?.(element);
      setContextVideoPlaceholderElement(element);
    }
  }), [setVideoElement, setVideoPlaceholderElement]);
  return (0, import_jsx_runtime2.jsx)("div", { "data-testid": "participant-view", ref: (element) => {
    applyElementToRef(ref, element);
    setTrackedElement(element);
  }, className: clsx_default("str-video__participant-view", isDominantSpeaker && "str-video__participant-view--dominant-speaker", isSpeaking && "str-video__participant-view--speaking", !hasVideoTrack && "str-video__participant-view--no-video", !hasAudioTrack && "str-video__participant-view--no-audio", className), children: (0, import_jsx_runtime2.jsxs)(ParticipantViewContext.Provider, { value: participantViewContextValue, children: [!isLocalParticipant && !muteAudio && (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [hasAudioTrack && (0, import_jsx_runtime2.jsx)(Audio, { participant, trackType: "audioTrack" }), hasScreenShareAudioTrack && (0, import_jsx_runtime2.jsx)(Audio, { participant, trackType: "screenShareAudioTrack" })] }), (0, import_jsx_runtime2.jsx)(Video$1, { VideoPlaceholder, PictureInPicturePlaceholder, participant, trackType, refs: videoRefs, enabled: isLocalParticipant || trackType !== "videoTrack" || isParticipantVideoEnabled(participant.sessionId), mirror, autoPlay: true }), isComponentType(ParticipantViewUI) ? (0, import_jsx_runtime2.jsx)(ParticipantViewUI, {}) : ParticipantViewUI] }) });
});
ParticipantView.displayName = "ParticipantView";
var StreamCall = StreamCallProvider;
StreamCall.displayName = "StreamCall";
var Joining = "Joining";
var Mic = "Mic";
var Ringing = "Ringing";
var Speakers = "Speakers";
var Video = "Video";
var Live = "Live";
var Reactions = "Reactions";
var Statistics = "Statistics";
var Invite = "Invite";
var Join = "Join";
var You = "You";
var Me2 = "Me";
var Unknown = "Unknown";
var Default = "Default";
var Refresh = "Refresh";
var Allow = "Allow";
var Revoke = "Revoke";
var Dismiss = "Dismiss";
var Pinned = "Pinned";
var Unpin = "Unpin";
var Pin2 = "Pin";
var Block = "Block";
var Kick = "Kick";
var Enter = "Enter";
var Leave = "Leave";
var Participants = "Participants";
var Anonymous = ", and ({{ count }}) anonymous";
var en2 = {
  Joining,
  Mic,
  "No internet connection": "No internet connection",
  "Re-connecting": "Re-connecting",
  Ringing,
  "Screen Share": "Screen Share",
  "Select a Camera": "Select a Camera",
  "Select a Mic": "Select a Mic",
  "Select Speakers": "Select Speakers",
  Speakers,
  Video,
  "You are muted. Unmute to speak.": "You are muted. Unmute to speak.",
  "Background filters performance is degraded. Consider disabling filters for better performance.": "Background filters performance is degraded. Consider disabling filters for better performance.",
  Live,
  "Livestream starts soon": "Livestream starts soon",
  "Livestream starts at {{ startsAt }}": "Livestream starts at {{ startsAt, datetime }}",
  "{{ count }} participants joined early_one": "{{ count }} participant joined early",
  "{{ count }} participants joined early_other": "{{ count }} participants joined early",
  "You can now speak.": "You can now speak.",
  "Awaiting for an approval to speak.": "Awaiting for an approval to speak.",
  "You can no longer speak.": "You can no longer speak.",
  "You can now share your video.": "You can now share your video.",
  "Awaiting for an approval to share your video.": "Awaiting for an approval to share your video.",
  "You can no longer share your video.": "You can no longer share your video.",
  "Waiting for recording to stop...": "Waiting for recording to stop...",
  "Waiting for recording to start...": "Waiting for recording to start...",
  "Record call": "Record call",
  Reactions,
  Statistics,
  "You can now share your screen.": "You can now share your screen.",
  "Awaiting for an approval to share screen.": "Awaiting for an approval to share screen.",
  "You can no longer share your screen.": "You can no longer share your screen.",
  "Share screen": "Share screen",
  "Incoming Call...": "Incoming Call...",
  "Calling...": "Calling...",
  "Mute All": "Mute All",
  Invite,
  Join,
  You,
  Me: Me2,
  Unknown,
  "Toggle device menu": "Toggle device menu",
  Default,
  "Call Recordings": "Call Recordings",
  Refresh,
  "Check your browser video permissions": "Check your browser video permissions",
  "Video publishing is disabled by the system": "Video publishing is disabled by the system",
  "You have no permission to share your video": "You have no permission to share your video",
  "You have no permission to share your audio": "You have no permission to share your audio",
  "You are presenting your screen": "You are presenting your screen",
  "Stop Screen Sharing": "Stop Screen Sharing",
  Allow,
  Revoke,
  Dismiss,
  "Microphone on": "Microphone on",
  "Microphone off": "Microphone off",
  "Camera on": "Camera on",
  "Camera off": "Camera off",
  "No camera found": "No camera found",
  "Video is disabled": "Video is disabled",
  Pinned,
  Unpin,
  Pin: Pin2,
  "Pin for everyone": "Pin for everyone",
  "Unpin for everyone": "Unpin for everyone",
  Block,
  Kick,
  "Turn off video": "Turn off video",
  "Turn off screen share": "Turn off screen share",
  "Mute audio": "Mute audio",
  "Mute screen share audio": "Mute screen share audio",
  "Allow audio": "Allow audio",
  "Allow video": "Allow video",
  "Allow screen sharing": "Allow screen sharing",
  "Disable audio": "Disable audio",
  "Disable video": "Disable video",
  "Disable screen sharing": "Disable screen sharing",
  Enter,
  Leave,
  "Leave call": "Leave call",
  "End call for all": "End call for all",
  "{{ direction }} fullscreen": "{{ direction }} fullscreen",
  "{{ direction }} picture-in-picture": "{{ direction }} picture-in-picture",
  "Dominant Speaker": "Dominant Speaker",
  "Poor connection quality": "Poor connection quality. Please check your internet connection.",
  "Video paused due to insufficient bandwidth": "Video paused due to insufficient bandwidth",
  Participants,
  Anonymous,
  "No participants found": "No participants found",
  "Participants ({{ numberOfParticipants }})": "Participants ({{ numberOfParticipants }})",
  "{{ userName }} is sharing their screen": "{{ userName }} is sharing their screen",
  "{{ userName }} is requesting to speak": "{{ userName }} is requesting to speak",
  "{{ userName }} is requesting to share their camera": "{{ userName }} is requesting to share their camera",
  "{{ userName }} is requesting to present their screen": "{{ userName }} is requesting to present their screen",
  "{{ userName }} is requesting permission: {{ permission }}": "{{ userName }} is requesting permission: {{ permission }}"
};
var translations = { en: en2 };
var StreamVideo = (props) => {
  return (0, import_jsx_runtime2.jsx)(StreamVideoProvider, { translationsOverrides: translations, ...props });
};
StreamVideo.displayName = "StreamVideo";
function applyFilter(obj, filter2) {
  if ("$and" in filter2) {
    return filter2.$and.every((f) => applyFilter(obj, f));
  }
  if ("$or" in filter2) {
    return filter2.$or.some((f) => applyFilter(obj, f));
  }
  if ("$not" in filter2) {
    return !applyFilter(obj, filter2.$not);
  }
  return checkConditions(obj, filter2);
}
var isDateString = (value) => typeof value === "string" && /^((?:(\d{4}-\d{2}-\d{2})T(\d{2}:\d{2}:\d{2}(?:\.\d+)?))(Z|[+-]\d{2}:\d{2})?)$/.test(value);
function checkConditions(obj, conditions) {
  let match = true;
  for (const key of Object.keys(conditions)) {
    const operator = conditions[key];
    const maybeOperator = operator && typeof operator === "object";
    let value = obj[key];
    if (value instanceof Date) {
      value = value.getTime();
    } else if (isDateString(value)) {
      value = new Date(value).getTime();
    }
    if (maybeOperator && "$eq" in operator) {
      const eqOperator = operator;
      const eqOperatorValue = isDateString(eqOperator.$eq) ? new Date(eqOperator.$eq).getTime() : eqOperator.$eq;
      match && (match = eqOperatorValue === value);
    } else if (maybeOperator && "$neq" in operator) {
      const neqOperator = operator;
      match && (match = neqOperator.$neq !== value);
    } else if (maybeOperator && "$in" in operator) {
      const inOperator = operator;
      match && (match = inOperator.$in.includes(value));
    } else if (maybeOperator && "$contains" in operator) {
      if (Array.isArray(value)) {
        const containsOperator = operator;
        match && (match = value.includes(containsOperator.$contains));
      } else {
        match = false;
      }
    } else if (maybeOperator && "$gt" in operator) {
      const gtOperator = operator;
      const gtOperatorValue = isDateString(gtOperator.$gt) ? new Date(gtOperator.$gt).getTime() : gtOperator.$gt;
      match && (match = value > gtOperatorValue);
    } else if (maybeOperator && "$gte" in operator) {
      const gteOperator = operator;
      const gteOperatorValue = isDateString(gteOperator.$gte) ? new Date(gteOperator.$gte).getTime() : gteOperator.$gte;
      match && (match = value >= gteOperatorValue);
    } else if (maybeOperator && "$lt" in operator) {
      const ltOperator = operator;
      const ltOperatorValue = isDateString(ltOperator.$lt) ? new Date(ltOperator.$lt).getTime() : ltOperator.$lt;
      match && (match = value < ltOperatorValue);
    } else if (maybeOperator && "$lte" in operator) {
      const lteOperator = operator;
      const lteOperatorValue = isDateString(lteOperator.$lte) ? new Date(lteOperator.$lte).getTime() : lteOperator.$lte;
      match && (match = value <= lteOperatorValue);
    } else {
      const eqValue = operator;
      match && (match = eqValue === value);
    }
    if (!match) {
      return false;
    }
  }
  return true;
}
var useFilteredParticipants = ({ excludeLocalParticipant = false, filterParticipants }) => {
  const { useParticipants: useParticipants2, useRemoteParticipants: useRemoteParticipants2 } = useCallStateHooks();
  const allParticipants = useParticipants2();
  const remoteParticipants = useRemoteParticipants2();
  return (0, import_react2.useMemo)(() => {
    const unfilteredParticipants = excludeLocalParticipant ? remoteParticipants : allParticipants;
    return filterParticipants ? applyParticipantsFilter(unfilteredParticipants, filterParticipants) : unfilteredParticipants;
  }, [
    allParticipants,
    remoteParticipants,
    excludeLocalParticipant,
    filterParticipants
  ]);
};
var applyParticipantsFilter = (participants, filter2) => {
  const filterCallback = typeof filter2 === "function" ? filter2 : (participant) => applyFilter({
    userId: participant.userId,
    isSpeaking: participant.isSpeaking,
    isDominantSpeaker: participant.isDominantSpeaker,
    name: participant.name,
    roles: participant.roles,
    isPinned: isPinned(participant),
    hasVideo: hasVideo(participant),
    hasAudio: hasAudio(participant),
    hasScreenShare: hasScreenShare(participant)
  }, filter2);
  return participants.filter(filterCallback);
};
var usePaginatedLayoutSortPreset = (call) => {
  (0, import_react2.useEffect)(() => {
    if (!call)
      return;
    call.setSortParticipantsBy(paginatedLayoutSortPreset);
    return () => {
      resetSortPreset(call);
    };
  }, [call]);
};
var useSpeakerLayoutSortPreset = (call, isOneOnOneCall) => {
  (0, import_react2.useEffect)(() => {
    if (!call)
      return;
    if (isOneOnOneCall) {
      call.setSortParticipantsBy(combineComparators(screenSharing, loggedIn));
    } else {
      call.setSortParticipantsBy(speakerLayoutSortPreset);
    }
    return () => {
      resetSortPreset(call);
    };
  }, [call, isOneOnOneCall]);
};
var useRawRemoteParticipants = () => {
  const { useRawParticipants: useRawParticipants2 } = useCallStateHooks();
  const rawParticipants = useRawParticipants2();
  return (0, import_react2.useMemo)(() => rawParticipants.filter((p2) => !p2.isLocalParticipant), [rawParticipants]);
};
var resetSortPreset = (call) => {
  const callConfig = CallTypes.get(call.type);
  call.setSortParticipantsBy(callConfig.options.sortParticipantsBy || defaultSortPreset);
};
var loggedIn = (a2, b2) => {
  if (a2.isLocalParticipant)
    return 1;
  if (b2.isLocalParticipant)
    return -1;
  return 0;
};
var LivestreamLayout = (props) => {
  const { useParticipants: useParticipants2, useHasOngoingScreenShare: useHasOngoingScreenShare2 } = useCallStateHooks();
  const call = useCall();
  const participants = useParticipants2();
  const [currentSpeaker] = participants;
  const remoteParticipants = useRawRemoteParticipants();
  const hasOngoingScreenShare = useHasOngoingScreenShare2();
  const presenter = hasOngoingScreenShare ? participants.find(hasScreenShare) : void 0;
  usePaginatedLayoutSortPreset(call);
  const { floatingParticipantProps, muted, ParticipantViewUI } = props;
  const overlay = ParticipantViewUI ?? (0, import_jsx_runtime2.jsx)(ParticipantOverlay, { showParticipantCount: props.showParticipantCount, showDuration: props.showDuration, showLiveBadge: props.showLiveBadge, showSpeakerName: props.showSpeakerName, enableFullScreen: props.enableFullScreen });
  const floatingParticipantOverlay = hasOngoingScreenShare && (ParticipantViewUI ?? (0, import_jsx_runtime2.jsx)(
    ParticipantOverlay,
    {
      // these elements aren't needed for the video feed
      showParticipantCount: floatingParticipantProps?.showParticipantCount ?? false,
      showDuration: floatingParticipantProps?.showDuration ?? false,
      showLiveBadge: floatingParticipantProps?.showLiveBadge ?? false,
      showSpeakerName: floatingParticipantProps?.showSpeakerName ?? true,
      enableFullScreen: floatingParticipantProps?.enableFullScreen ?? true
    }
  ));
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__livestream-layout__wrapper", children: [!muted && (0, import_jsx_runtime2.jsx)(ParticipantsAudio, { participants: remoteParticipants }), hasOngoingScreenShare && presenter && (0, import_jsx_runtime2.jsx)(ParticipantView, { className: "str-video__livestream-layout__screen-share", participant: presenter, ParticipantViewUI: overlay, trackType: "screenShareTrack", muteAudio: true }), currentSpeaker && (0, import_jsx_runtime2.jsx)(ParticipantView, { className: clsx_default(hasOngoingScreenShare && clsx_default("str-video__livestream-layout__floating-participant", `str-video__livestream-layout__floating-participant--${floatingParticipantProps?.position ?? "top-right"}`)), participant: currentSpeaker, ParticipantViewUI: floatingParticipantOverlay || overlay, mirror: props.mirrorLocalParticipantVideo !== false ? void 0 : false, muteAudio: true })] });
};
LivestreamLayout.displayName = "LivestreamLayout";
var BackstageLayout = (props) => {
  const { showEarlyParticipantCount = true } = props;
  const { useParticipantCount: useParticipantCount2, useCallStartsAt: useCallStartsAt2 } = useCallStateHooks();
  const participantCount = useParticipantCount2();
  const startsAt = useCallStartsAt2();
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__livestream-layout__wrapper", children: (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__livestream-layout__backstage", children: [startsAt && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__livestream-layout__starts-at", children: startsAt.getTime() < Date.now() ? t2("Livestream starts soon") : t2("Livestream starts at {{ startsAt }}", { startsAt }) }), showEarlyParticipantCount && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__livestream-layout__early-viewers-count", children: t2("{{ count }} participants joined early", {
    count: participantCount
  }) })] }) });
};
BackstageLayout.displayName = "BackstageLayout";
var ParticipantOverlay = (props) => {
  const { enableFullScreen = true, showParticipantCount = true, showDuration = true, showLiveBadge = true, showSpeakerName = false } = props;
  const overlayBarVisible = enableFullScreen || showParticipantCount || showDuration || showLiveBadge || showSpeakerName;
  const { participant } = useParticipantViewContext();
  const { useParticipantCount: useParticipantCount2 } = useCallStateHooks();
  const participantCount = useParticipantCount2();
  const duration = useUpdateCallDuration();
  const toggleFullScreen = useToggleFullScreen();
  const { t: t2 } = useI18n();
  return (0, import_jsx_runtime2.jsx)("div", { className: "str-video__livestream-layout__overlay", children: overlayBarVisible && (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__livestream-layout__overlay__bar", children: [showLiveBadge && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__livestream-layout__live-badge", children: t2("Live") }), showParticipantCount && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__livestream-layout__viewers-count", children: participantCount }), showSpeakerName && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__livestream-layout__speaker-name", title: participant.name || participant.userId || "", children: participant.name || participant.userId || "" }), showDuration && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__livestream-layout__duration", children: formatDuration(duration) }), enableFullScreen && (0, import_jsx_runtime2.jsx)("span", { className: "str-video__livestream-layout__go-fullscreen", onClick: toggleFullScreen })] }) });
};
var useUpdateCallDuration = () => {
  const { useIsCallLive: useIsCallLive2, useCallSession: useCallSession2 } = useCallStateHooks();
  const isCallLive = useIsCallLive2();
  const session = useCallSession2();
  const [duration, setDuration] = (0, import_react2.useState)(() => {
    if (!session || !session.live_started_at)
      return 0;
    const liveStartTime = new Date(session.live_started_at);
    const now = /* @__PURE__ */ new Date();
    return Math.floor((now.getTime() - liveStartTime.getTime()) / 1e3);
  });
  (0, import_react2.useEffect)(() => {
    if (!isCallLive)
      return;
    const interval2 = setInterval(() => {
      setDuration((d) => d + 1);
    }, 1e3);
    return () => {
      clearInterval(interval2);
    };
  }, [isCallLive]);
  return duration;
};
var useToggleFullScreen = () => {
  const { participantViewElement } = useParticipantViewContext();
  const [isFullscreen, setIsFullscreen] = (0, import_react2.useState)(!!document.fullscreenElement);
  (0, import_react2.useEffect)(() => {
    const handler = () => setIsFullscreen(!!document.fullscreenElement);
    document.addEventListener("fullscreenchange", handler);
    return () => {
      document.removeEventListener("fullscreenchange", handler);
    };
  }, []);
  return (0, import_react2.useCallback)(() => {
    if (isFullscreen) {
      document.exitFullscreen().catch((err) => {
        console.error("Failed to exit fullscreen", err);
      });
    } else {
      participantViewElement?.requestFullscreen().catch((err) => {
        console.error("Failed to enter fullscreen", err);
      });
    }
  }, [isFullscreen, participantViewElement]);
};
var formatDuration = (durationInMs) => {
  const days = Math.floor(durationInMs / 86400);
  const hours = Math.floor(durationInMs / 3600);
  const minutes = Math.floor(durationInMs % 3600 / 60);
  const seconds = durationInMs % 60;
  return `${days ? days + " " : ""}${hours ? hours + ":" : ""}${minutes < 10 ? "0" : ""}${minutes}:${seconds < 10 ? "0" : ""}${seconds}`;
};
var GROUP_SIZE = 16;
var PaginatedGridLayoutGroup = ({ group, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI }) => {
  return (0, import_jsx_runtime2.jsx)("div", { className: clsx_default("str-video__paginated-grid-layout__group", {
    "str-video__paginated-grid-layout--one": group.length === 1,
    "str-video__paginated-grid-layout--two-four": group.length >= 2 && group.length <= 4,
    "str-video__paginated-grid-layout--five-nine": group.length >= 5 && group.length <= 9
  }), children: group.map((participant) => (0, import_jsx_runtime2.jsx)(ParticipantView, { participant, muteAudio: true, mirror, VideoPlaceholder, PictureInPicturePlaceholder, ParticipantViewUI }, participant.sessionId)) });
};
var PaginatedGridLayout = (props) => {
  const { groupSize = (props.groupSize || 0) > 0 ? props.groupSize || GROUP_SIZE : GROUP_SIZE, excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, pageArrowsVisible = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI, PictureInPicturePlaceholder, muted } = props;
  const [page, setPage] = (0, import_react2.useState)(0);
  const [paginatedGridLayoutWrapperElement, setPaginatedGridLayoutWrapperElement] = (0, import_react2.useState)(null);
  const call = useCall();
  const remoteParticipants = useRawRemoteParticipants();
  const participants = useFilteredParticipants({
    excludeLocalParticipant,
    filterParticipants
  });
  usePaginatedLayoutSortPreset(call);
  (0, import_react2.useEffect)(() => {
    if (!paginatedGridLayoutWrapperElement || !call)
      return;
    const cleanup = call.setViewport(paginatedGridLayoutWrapperElement);
    return () => cleanup();
  }, [paginatedGridLayoutWrapperElement, call]);
  const participantGroups = (0, import_react2.useMemo)(() => chunk(participants, groupSize), [participants, groupSize]);
  const pageCount = participantGroups.length;
  (0, import_react2.useEffect)(() => {
    if (page > pageCount - 1) {
      setPage(Math.max(0, pageCount - 1));
    }
  }, [page, pageCount]);
  const selectedGroup = participantGroups[page];
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__paginated-grid-layout__wrapper", ref: setPaginatedGridLayoutWrapperElement, children: [!muted && (0, import_jsx_runtime2.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__paginated-grid-layout", children: [pageArrowsVisible && pageCount > 1 && (0, import_jsx_runtime2.jsx)(IconButton, { icon: "caret-left", disabled: page === 0, onClick: () => setPage((currentPage) => Math.max(0, currentPage - 1)) }), selectedGroup && (0, import_jsx_runtime2.jsx)(PaginatedGridLayoutGroup, { group: selectedGroup, mirror, VideoPlaceholder, ParticipantViewUI, PictureInPicturePlaceholder }), pageArrowsVisible && pageCount > 1 && (0, import_jsx_runtime2.jsx)(IconButton, { disabled: page === pageCount - 1, icon: "caret-right", onClick: () => setPage((currentPage) => Math.min(pageCount - 1, currentPage + 1)) })] })] });
};
PaginatedGridLayout.displayName = "PaginatedGridLayout";
var useCalculateHardLimit = (wrapperElement, hostElement, limit) => {
  const [calculatedLimit, setCalculatedLimit] = (0, import_react2.useState)({
    vertical: typeof limit === "number" ? limit : null,
    horizontal: typeof limit === "number" ? limit : null
  });
  (0, import_react2.useEffect)(() => {
    if (!hostElement || !wrapperElement || typeof limit === "number" || typeof limit === "undefined")
      return;
    let childWidth = null;
    let childHeight = null;
    const resizeObserver = new ResizeObserver((entries, observer) => {
      if (entries.length > 1) {
        const child = hostElement.firstChild;
        if (child) {
          childHeight = child.clientHeight;
          childWidth = child.clientWidth;
          observer.unobserve(hostElement);
        }
      }
      if (childHeight === null || childWidth === null)
        return;
      const vertical = Math.floor(wrapperElement.clientHeight / childHeight);
      const horizontal = Math.floor(wrapperElement.clientWidth / childWidth);
      setCalculatedLimit((pv) => {
        if (pv.vertical !== vertical || pv.horizontal !== horizontal)
          return { vertical, horizontal };
        return pv;
      });
    });
    resizeObserver.observe(wrapperElement);
    resizeObserver.observe(hostElement);
    return () => {
      resizeObserver.disconnect();
    };
  }, [hostElement, limit, wrapperElement]);
  return calculatedLimit;
};
var DefaultParticipantViewUIBar = () => (0, import_jsx_runtime2.jsx)(DefaultParticipantViewUI, { menuPlacement: "top-end" });
var SpeakerLayout = ({ ParticipantViewUIBar = DefaultParticipantViewUIBar, ParticipantViewUISpotlight = DefaultParticipantViewUI, VideoPlaceholder, PictureInPicturePlaceholder, participantsBarPosition = "bottom", participantsBarLimit, mirrorLocalParticipantVideo = true, excludeLocalParticipant = false, filterParticipants, pageArrowsVisible = true, muted }) => {
  const call = useCall();
  const { useParticipants: useParticipants2 } = useCallStateHooks();
  const allParticipants = useParticipants2();
  const remoteParticipants = useRawRemoteParticipants();
  const [participantInSpotlight, ...otherParticipants] = useFilteredParticipants({ excludeLocalParticipant, filterParticipants });
  const [participantsBarWrapperElement, setParticipantsBarWrapperElement] = (0, import_react2.useState)(null);
  const [participantsBarElement, setParticipantsBarElement] = (0, import_react2.useState)(null);
  const [buttonsWrapperElement, setButtonsWrapperElement] = (0, import_react2.useState)(null);
  const isSpeakerScreenSharing = participantInSpotlight && hasScreenShare(participantInSpotlight);
  const hardLimit = useCalculateHardLimit(buttonsWrapperElement, participantsBarElement, participantsBarLimit);
  const isVertical = participantsBarPosition === "left" || participantsBarPosition === "right";
  const isHorizontal = participantsBarPosition === "top" || participantsBarPosition === "bottom";
  (0, import_react2.useEffect)(() => {
    if (!participantsBarWrapperElement || !call)
      return;
    const cleanup = call.setViewport(participantsBarWrapperElement);
    return () => cleanup();
  }, [participantsBarWrapperElement, call]);
  const isOneOnOneCall = allParticipants.length === 2;
  useSpeakerLayoutSortPreset(call, isOneOnOneCall);
  let participantsWithAppliedLimit = otherParticipants;
  const hardLimitToApply = isVertical ? hardLimit.vertical : hardLimit.horizontal;
  if (typeof participantsBarLimit !== "undefined" && hardLimitToApply !== null) {
    participantsWithAppliedLimit = otherParticipants.slice(
      0,
      // subtract 1 if speaker is sharing screen as
      // that one is rendered independently from otherParticipants array
      hardLimitToApply - (isSpeakerScreenSharing ? 1 : 0)
    );
  }
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  const renderParticipantsBar = participantsBarPosition && (participantsWithAppliedLimit.length > 0 || isSpeakerScreenSharing);
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__speaker-layout__wrapper", children: [!muted && (0, import_jsx_runtime2.jsx)(ParticipantsAudio, { participants: remoteParticipants }), (0, import_jsx_runtime2.jsxs)("div", { className: clsx_default("str-video__speaker-layout", participantsBarPosition && `str-video__speaker-layout--variant-${participantsBarPosition}`), children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__speaker-layout__spotlight", children: participantInSpotlight && (0, import_jsx_runtime2.jsx)(ParticipantView, { participant: participantInSpotlight, muteAudio: true, mirror, trackType: isSpeakerScreenSharing ? "screenShareTrack" : "videoTrack", ParticipantViewUI: ParticipantViewUISpotlight, VideoPlaceholder, PictureInPicturePlaceholder }) }), renderParticipantsBar && (0, import_jsx_runtime2.jsxs)("div", { ref: setButtonsWrapperElement, className: "str-video__speaker-layout__participants-bar-buttons-wrapper", children: [(0, import_jsx_runtime2.jsx)("div", { className: "str-video__speaker-layout__participants-bar-wrapper", ref: setParticipantsBarWrapperElement, children: (0, import_jsx_runtime2.jsxs)("div", { ref: setParticipantsBarElement, className: "str-video__speaker-layout__participants-bar", children: [isSpeakerScreenSharing && (0, import_jsx_runtime2.jsx)("div", { className: "str-video__speaker-layout__participant-tile", children: (0, import_jsx_runtime2.jsx)(ParticipantView, { participant: participantInSpotlight, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder, PictureInPicturePlaceholder, mirror, muteAudio: true }) }, participantInSpotlight.sessionId), participantsWithAppliedLimit.map((participant) => (0, import_jsx_runtime2.jsx)("div", { className: "str-video__speaker-layout__participant-tile", children: (0, import_jsx_runtime2.jsx)(ParticipantView, { participant, ParticipantViewUI: ParticipantViewUIBar, VideoPlaceholder, PictureInPicturePlaceholder, mirror, muteAudio: true }) }, participant.sessionId))] }) }), pageArrowsVisible && isVertical && (0, import_jsx_runtime2.jsx)(VerticalScrollButtons, { scrollWrapper: participantsBarWrapperElement }), pageArrowsVisible && isHorizontal && (0, import_jsx_runtime2.jsx)(HorizontalScrollButtons, { scrollWrapper: participantsBarWrapperElement })] })] })] });
};
SpeakerLayout.displayName = "SpeakerLayout";
var HorizontalScrollButtons = ({ scrollWrapper }) => {
  const scrollPosition = useHorizontalScrollPosition(scrollWrapper);
  const scrollStartClickHandler = () => {
    scrollWrapper?.scrollBy({ left: -150, behavior: "smooth" });
  };
  const scrollEndClickHandler = () => {
    scrollWrapper?.scrollBy({ left: 150, behavior: "smooth" });
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [scrollPosition && scrollPosition !== "start" && (0, import_jsx_runtime2.jsx)(IconButton, { onClick: scrollStartClickHandler, icon: "caret-left", className: "str-video__speaker-layout__participants-bar--button-left" }), scrollPosition && scrollPosition !== "end" && (0, import_jsx_runtime2.jsx)(IconButton, { onClick: scrollEndClickHandler, icon: "caret-right", className: "str-video__speaker-layout__participants-bar--button-right" })] });
};
var VerticalScrollButtons = ({ scrollWrapper }) => {
  const scrollPosition = useVerticalScrollPosition(scrollWrapper);
  const scrollTopClickHandler = () => {
    scrollWrapper?.scrollBy({ top: -150, behavior: "smooth" });
  };
  const scrollBottomClickHandler = () => {
    scrollWrapper?.scrollBy({ top: 150, behavior: "smooth" });
  };
  return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [scrollPosition && scrollPosition !== "top" && (0, import_jsx_runtime2.jsx)(IconButton, { onClick: scrollTopClickHandler, icon: "caret-up", className: "str-video__speaker-layout__participants-bar--button-top" }), scrollPosition && scrollPosition !== "bottom" && (0, import_jsx_runtime2.jsx)(IconButton, { onClick: scrollBottomClickHandler, icon: "caret-down", className: "str-video__speaker-layout__participants-bar--button-bottom" })] });
};
var Pip = (props) => {
  const { t: t2 } = useI18n();
  const { excludeLocalParticipant = false, filterParticipants, mirrorLocalParticipantVideo = true, VideoPlaceholder, ParticipantViewUI = DefaultParticipantViewUI } = props;
  const [layoutWrapperElement, setLayoutWrapperElement] = (0, import_react2.useState)(null);
  const call = useCall();
  const participants = useFilteredParticipants({
    excludeLocalParticipant,
    filterParticipants
  });
  const screenSharingParticipant = participants.find((p2) => hasScreenShare(p2));
  usePaginatedLayoutSortPreset(call);
  (0, import_react2.useEffect)(() => {
    if (!layoutWrapperElement || !call)
      return;
    return call.setViewport(layoutWrapperElement);
  }, [layoutWrapperElement, call]);
  const mirror = mirrorLocalParticipantVideo ? void 0 : false;
  if (!call)
    return null;
  return (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__pip-layout", ref: setLayoutWrapperElement, children: [screenSharingParticipant && (screenSharingParticipant.isLocalParticipant ? (0, import_jsx_runtime2.jsxs)("div", { className: "str-video__pip-screen-share-local", children: [(0, import_jsx_runtime2.jsx)(Icon, { icon: "screen-share-off" }), (0, import_jsx_runtime2.jsx)("span", { className: "str-video__pip-screen-share-local__title", children: t2("You are presenting your screen") })] }) : (0, import_jsx_runtime2.jsx)(ParticipantView, { participant: screenSharingParticipant, trackType: "screenShareTrack", muteAudio: true, mirror: false, VideoPlaceholder, ParticipantViewUI })), participants.map((participant) => (0, import_jsx_runtime2.jsx)(ParticipantView, { participant, muteAudio: true, mirror, VideoPlaceholder, ParticipantViewUI }, participant.sessionId))] });
};
Pip.displayName = "PipLayout.Pip";
var Host = () => {
  const remoteParticipants = useRawRemoteParticipants();
  return (0, import_jsx_runtime2.jsx)(ParticipantsAudio, { participants: remoteParticipants });
};
Host.displayName = "PipLayout.Host";
var PipLayout = { Pip, Host };
var LivestreamPlayer = (props) => {
  const { callType, callId, children, ...restProps } = props;
  const client = useStreamVideoClient();
  const [call, setCall] = (0, import_react2.useState)();
  const onError = useEffectEvent(props.onError ?? (() => {
  }));
  (0, import_react2.useEffect)(() => {
    if (!client)
      return;
    const myCall = client.call(callType, callId);
    setCall(myCall);
    myCall.get().catch((e2) => {
      console.error("Failed to fetch call", e2);
      onError(e2);
    });
    return () => {
      myCall.leave().catch((e2) => {
        console.error("Failed to leave call", e2);
      });
      setCall(void 0);
    };
  }, [callId, callType, client]);
  if (!call) {
    return null;
  }
  return (0, import_jsx_runtime2.jsxs)(StreamCall, { call, children: [(0, import_jsx_runtime2.jsx)(LivestreamCall, { ...restProps }), children] });
};
var LivestreamCall = (props) => {
  const call = useLivestreamCall(props);
  const { useIsCallLive: useIsCallLive2 } = useCallStateHooks();
  const isLive = useIsCallLive2();
  if (!call)
    return null;
  if (isLive) {
    return (0, import_jsx_runtime2.jsx)(LivestreamLayout, { ...props.layoutProps });
  }
  return (0, import_jsx_runtime2.jsx)(BackstageLayout, { ...props.backstageProps });
};
var useLivestreamCall = (props) => {
  const call = useCall();
  const { useIsCallLive: useIsCallLive2, useOwnCapabilities: useOwnCapabilities2 } = useCallStateHooks();
  const canJoinLive = useIsCallLive2();
  const canJoinEarly = useCanJoinEarly();
  const canJoinBackstage = useOwnCapabilities2()?.includes("join-backstage") ?? false;
  const canJoinAsap = canJoinLive || canJoinEarly || canJoinBackstage;
  const joinBehavior = props.joinBehavior ?? "asap";
  const canJoin = joinBehavior === "asap" && canJoinAsap || joinBehavior === "live" && canJoinLive;
  const onError = useEffectEvent(props.onError ?? (() => {
  }));
  (0, import_react2.useEffect)(() => {
    if (call && call.state.callingState === CallingState.IDLE && canJoin) {
      call.join().catch((e2) => {
        console.error("Failed to join call", e2);
        onError(e2);
      });
    }
  }, [call, canJoin]);
  return call;
};
var useCanJoinEarly = () => {
  const { useCallStartsAt: useCallStartsAt2, useCallSettings: useCallSettings2 } = useCallStateHooks();
  const startsAt = useCallStartsAt2();
  const settings = useCallSettings2();
  const joinAheadTimeSeconds = settings?.backstage.join_ahead_time_seconds;
  const [canJoinEarly, setCanJoinEarly] = (0, import_react2.useState)(() => checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
  (0, import_react2.useEffect)(() => {
    if (!canJoinEarly) {
      const handle = setInterval(() => {
        setCanJoinEarly(checkCanJoinEarly(startsAt, joinAheadTimeSeconds));
      }, 1e3);
      return () => clearInterval(handle);
    }
  }, [canJoinEarly, startsAt, joinAheadTimeSeconds]);
  return canJoinEarly;
};
var checkCanJoinEarly = (startsAt, joinAheadTimeSeconds) => {
  if (!startsAt) {
    return false;
  }
  return Date.now() >= +startsAt - (joinAheadTimeSeconds ?? 0) * 1e3;
};
var [major2, minor2, patch2] = "1.27.2".split(".");
setSdkInfo({
  type: models.SdkType.REACT,
  major: major2,
  minor: minor2,
  patch: patch2
});
export {
  AcceptCallButton,
  Audio,
  AudioSettingsRequestDefaultDeviceEnum,
  AudioSettingsResponseDefaultDeviceEnum,
  AudioVolumeIndicator,
  Avatar,
  AvatarFallback,
  AxiosError,
  BackgroundFiltersProvider,
  BackstageLayout,
  BaseVideo,
  browsers as Browsers,
  Call,
  CallControls,
  CallParticipantListing,
  CallParticipantListingItem,
  CallParticipantsList,
  CallPreview,
  CallRecordingList,
  CallRecordingListHeader,
  CallRecordingListItem,
  CallState,
  CallStats,
  CallStatsButton,
  CallType,
  CallTypes,
  CallingState,
  CameraManager,
  CameraManagerState,
  CancelCallButton,
  CancelCallConfirmButton,
  CompositeButton,
  CreateDeviceRequestPushProviderEnum,
  DebounceType,
  DefaultParticipantViewUI,
  DefaultReactionsMenu,
  DefaultScreenShareOverlay,
  DefaultVideoPlaceholder2 as DefaultVideoPlaceholder,
  DeviceManager,
  DeviceManagerState,
  DeviceSelector,
  DeviceSelectorAudioInput,
  DeviceSelectorAudioOutput,
  DeviceSelectorVideo,
  DeviceSettings,
  DropDownSelect,
  DropDownSelectOption,
  DynascaleManager,
  EmptyCallRecordingListing,
  ErrorFromResponse,
  FrameRecordingSettingsRequestModeEnum,
  FrameRecordingSettingsRequestQualityEnum,
  FrameRecordingSettingsResponseModeEnum,
  GenericMenu,
  GenericMenuButtonItem,
  Icon,
  IconButton,
  IngressAudioEncodingOptionsRequestChannelsEnum,
  IngressSourceRequestFpsEnum,
  IngressVideoLayerRequestCodecEnum,
  LayoutSettingsRequestNameEnum,
  LivestreamLayout,
  LivestreamPlayer,
  LoadingCallRecordingListing,
  LoadingIndicator,
  LogLevelEnum,
  MenuToggle,
  MenuVisualType,
  MicrophoneManager,
  MicrophoneManagerState,
  NoiseCancellationProvider,
  NoiseCancellationSettingsModeEnum,
  Notification2 as Notification,
  OwnCapability,
  PaginatedGridLayout,
  ParticipantActionsContextMenu,
  ParticipantDetails,
  ParticipantView,
  ParticipantViewContext,
  ParticipantsAudio,
  PerformanceDegradationReason,
  PermissionNotification,
  PermissionRequestList,
  PermissionRequests,
  PipLayout,
  RNSpeechDetector,
  RTMPBroadcastRequestQualityEnum,
  RTMPSettingsRequestQualityEnum,
  Reaction,
  ReactionsButton,
  RecordCallButton,
  RecordCallConfirmationButton,
  RecordSettingsRequestModeEnum,
  RecordSettingsRequestQualityEnum,
  RecordingInProgressNotification,
  Restricted,
  RingingCall,
  RingingCallControls,
  rxUtils as RxUtils,
  ScreenShareButton,
  ScreenShareManager,
  ScreenShareState,
  SearchInput,
  SearchResults,
  events as SfuEvents,
  models as SfuModels,
  SpeakerLayout,
  SpeakerManager,
  SpeakerState,
  SpeakerTest,
  SpeakingWhileMutedNotification,
  SpeechIndicator,
  StartClosedCaptionsRequestLanguageEnum,
  StartTranscriptionRequestLanguageEnum,
  StatCard,
  StreamCall,
  StreamCallProvider,
  StreamI18n,
  StreamI18nProvider,
  StreamSfuClient,
  StreamTheme,
  StreamVideo,
  StreamVideoClient,
  StreamVideoProvider,
  StreamVideoReadOnlyStateStore,
  StreamVideoWriteableStateStore,
  TextButton,
  ToggleAudioOutputButton,
  ToggleAudioPreviewButton,
  ToggleAudioPublishingButton,
  ToggleVideoPreviewButton,
  ToggleVideoPublishingButton,
  Tooltip,
  TranscriptionSettingsRequestClosedCaptionModeEnum,
  TranscriptionSettingsRequestLanguageEnum,
  TranscriptionSettingsRequestModeEnum,
  TranscriptionSettingsResponseClosedCaptionModeEnum,
  TranscriptionSettingsResponseLanguageEnum,
  TranscriptionSettingsResponseModeEnum,
  Video$1 as Video,
  VideoPreview,
  VideoSettingsRequestCameraFacingEnum,
  VideoSettingsResponseCameraFacingEnum,
  ViewportTracker,
  VisibilityState,
  WithTooltip,
  applyFilter,
  checkIfAudioOutputChangeSupported,
  combineComparators,
  conditional,
  createSoundDetector,
  defaultEmojiReactionMap,
  defaultReactions,
  defaultSortPreset,
  defaultTranslationFunction,
  descending,
  deviceIds$,
  disposeOfMediaStream,
  dominantSpeaker,
  getAudioBrowserPermission,
  getAudioDevices,
  getAudioOutputDevices,
  getAudioStream,
  getClientDetails,
  getDeviceState,
  getScreenShareStream,
  getSdkInfo,
  getVideoBrowserPermission,
  getVideoDevices,
  getVideoStream,
  getWebRTCInfo,
  hasAudio,
  hasPausedTrack,
  hasScreenShare,
  hasScreenShareAudio,
  hasVideo,
  isPinned,
  livestreamOrAudioRoomSortPreset,
  logToConsole2 as logToConsole,
  name,
  noopComparator,
  paginatedLayoutSortPreset,
  pinned,
  publishingAudio,
  publishingVideo,
  reactionType,
  resolveDeviceId,
  role,
  screenSharing,
  setDeviceInfo,
  setOSInfo,
  setPowerState,
  setSdkInfo,
  setThermalState,
  setWebRTCInfo,
  speakerLayoutSortPreset,
  speaking,
  translations,
  useBackgroundFilters,
  useCall,
  useCallStateHooks,
  useCalls,
  useConnectedUser,
  useDeviceList,
  useEffectEvent,
  useFilteredParticipants,
  useHorizontalScrollPosition,
  useI18n,
  useMenuContext,
  useNoiseCancellation,
  useObservableValue,
  useParticipantViewContext,
  usePersistedDevicePreferences,
  useRequestPermission,
  useStore,
  useStreamVideoClient,
  useToggleCallRecording,
  useTrackElementVisibility,
  useVerticalScrollPosition,
  videoLoggerSystem,
  withParticipantSource
};
//# sourceMappingURL=@stream-io_video-react-sdk.js.map
